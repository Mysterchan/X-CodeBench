{
    "Title": "Panasonic Programming Contest 2025（AtCoder Beginner Contest 406）",
    "Source": "atcoder",
    "Name": "Compare Tree Weights",
    "Time Limit": "2 sec",
    "Memory Limit": "1024 MiB",
    "Problem Statement": "有一棵樹 T，擁有 N 個頂點。\n這些頂點標記為頂點 1、頂點 2、...、頂點 N，邊緣則標記為邊 1、邊 2、...、邊 (N-1)。\n邊 i (1≤ i≤ N-1) 連接頂點 U_i 和 V_i。\n每個頂點都有一個權重；最初，每個頂點的權重為 1。\n你將依序獲得 Q 個查詢。\n每個查詢有以下兩種類型之一：\n- 1 x w : 將頂點 x 的權重增加 w。\n- 2 y : 如果邊 y 被移除，樹 T 將分成兩棵子樹（連通分量）。對於每棵子樹，令其權重為其頂點的權重總和。輸出兩棵子樹權重之間的差值。\n對於第二種類型的查詢，可以證明移除 T 的任何邊總是將其分成恰好兩棵子樹。\n請注意，第二種類型的查詢並不實際刪除邊。",
    "Statement Images": [],
    "Constraints": "- 2 ≤ N ≤ 3 \\times 10^5\n- 1 ≤ U_i, V_i ≤ N\n- 1 ≤ Q ≤ 3 \\times 10^5\n- 1 ≤ x ≤ N\n- 1 ≤ w ≤ 1000\n- 1 ≤ y ≤ N-1\n- 所有輸入值均為整數。\n- 給定的圖是一棵樹。\n- 至少有一個第二種類型的查詢。",
    "IO Styles": "輸入\n輸入是以以下格式從標準輸入給出：\nN\nU_1 V_1\nU_2 V_2\n\\vdots\nU_{N-1} V_{N-1}\nQ\n\\mathrm{query}_1\n\\mathrm{query}_2\n\\vdots\n\\mathrm{query}_Q\n每個查詢 \\mathrm{query}_i (1≤ i≤ Q) 以以下格式之一給出：\n1 x w\n2 y\n輸出\n設 K 為第二類查詢的數量。\n輸出 K 行；第 i 行 (1 ≤ i ≤ K) 應該包含第二類查詢的第 i 個答案。",
    "Sample Detail": [
        {
            "input": "6\n1 2\n1 3\n2 4\n4 5\n4 6\n5\n2 1\n1 1 3\n2 1\n1 4 10\n2 5\n",
            "output": "2\n1\n17\n",
            "explanation": "樹 T 的結構和頂點編號如下面左側的圖所示。最初，每個頂點的權重為 1。\n\n在第一次查詢中，考慮刪除邊 1。\n樹分裂成包含頂點 1 的子樹和包含頂點 2 的子樹。\n包含頂點 1 的子樹的權重為 2；包含頂點 2 的子樹的權重為 4。輸出它們的差值，2（見下面右側的圖）。\n\n![image](1.png)\n\n第二次查詢將頂點 1 的權重增加 3。\n\n在第三次查詢中，考慮刪除邊 1。\n包含頂點 1 的子樹的權重為 5；包含頂點 2 的子樹的權重為 4。輸出它們的差值，1（見下面左側的圖）。\n\n第四次查詢將頂點 4 的權重增加 10。\n\n在第五次查詢中，考慮刪除邊 5。\n樹分裂成包含頂點 4 的子樹和僅由頂點 6 組成的子樹。\n包含頂點 4 的子樹的權重為 18；包含頂點 6 的子樹的權重為 1。輸出它們的差值，17（見下面右側的圖）。\n\n![image](2.png)\n\n因此，按順序輸出第二類查詢的答案：2、1 和 17，並以換行符分隔。",
            "images": [
                "https://img.atcoder.jp/abc406/6f17e951940c2460b3ae5fe8e6bddc52.png",
                "https://img.atcoder.jp/abc406/c5eacf2967bcc2b09866a0d8b83104c4.png"
            ]
        }
    ],
    "Language": "cn"
}