{
    "Title": "AtCoder Regular Contest 205 (Div. 2)",
    "Source": "atcoder",
    "Name": "2x2 Erasing",
    "Time Limit": "2 sec",
    "Memory Limit": "1024 MiB",
    "Problem Statement": "有一個 N 行 N 列的網格。讓 (r,c) 表示從上方數第 r 行和從左側數第 c 列的單元格。每個單元格被塗成黑色或白色。當 S_{r,c} 是 # 時，單元格 (r,c) 被塗成黑色；當 S_{r,c} 是 . 時，則被塗成白色。\n\n你將得到 Q 個關於這個網格的問題，因此請對每個問題做出回答。在第 i 個問題中 (1≤ i≤ Q)，給定整數 U_i,D_i,L_i,R_i，因此找出以下問題的答案：\n- 在將所有不滿足 U_i ≤ r ≤ D_i 和 L_i ≤ c ≤ R_i 的單元格塗成黑色後，找到你可以執行以下操作的最大次數。\n- 選擇一對整數 (r,c)，使得單元格 (r,c),(r,c+1),(r+1,c),(r+1,c+1) 都是白色，並將這四個單元格中的一個塗成黑色。\n\n獨立地解決每個問題。換句話說，每個問題中每個單元格的顏色都重置為初始狀態。",
    "Statement Images": [],
    "Constraints": "- 2≤ N≤ 500\n- 1≤ Q≤ 2\\times 10^5\n- S_{r,c} 是 . 或 #。\n- 1≤ U_i < D_i ≤ N\n- 1≤ L_i < R_i ≤ N\n- N,Q,U_i,D_i,L_i,R_i 都是整數。",
    "IO Styles": "輸入\n輸入是以以下格式從標準輸入給出：\nN Q\nS_{1,1}S_{1,2}... S_{1,N}\nS_{2,1}S_{2,2}... S_{2,N}\n\\vdots\nS_{N,1}S_{N,2}... S_{N,N}\nU_1 D_1 L_1 R_1\nU_2 D_2 L_2 R_2\n\\vdots\nU_Q D_Q L_Q R_Q\n\n輸出\n輸出 Q 行。\n第 i 行 (1≤ i≤ Q) 應該包含第 i 個問題的答案。",
    "Sample Detail": [
        {
            "input": "5 4\n..#.#\n.....\n#....\n...#.\n.#...\n1 3 1 3\n3 5 3 5\n2 3 1 4\n1 5 1 5\n",
            "output": "2\n0\n2\n5\n",
            "explanation": "考慮第一個問題。\n\n在將所有不滿足 1≤ r≤ 3 和 1≤ c≤ 3 的單元格顏色塗黑後，網格變為如下：\n..###\n...##\n#..##\n#####\n#####\n\n\n您可以對此網格執行兩次操作，如下所示。\n\n- 選擇 (r,c)=(1,1)。在單元格 (1,1),(1,2),(2,1),(2,2) 中，選擇單元格 (1,2) 並將其塗黑。\n- 選擇 (r,c)=(2,2)。在單元格 (2,2),(2,3),(3,2),(3,3) 中，選擇單元格 (2,2) 並將其塗黑。\n\n\n您不能執行超過兩次操作，因此在第一行輸出 2。",
            "images": []
        },
        {
            "input": "7 6\n#.#....\n.....#.\n.......\n.#..#.#\n#....#.\n.......\n....##.\n1 3 2 7\n4 6 1 6\n6 7 2 7\n3 5 4 6\n1 6 2 4\n1 7 1 7\n",
            "output": "4\n4\n2\n0\n6\n13\n",
            "explanation": "",
            "images": []
        }
    ],
    "Language": "cn"
}