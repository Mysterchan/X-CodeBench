{
    "Title": "AtCoder Regular Contest 201",
    "Source": "atcoder",
    "Name": "Match, Mod, Minimize",
    "Time Limit": "2 sec",
    "Memory Limit": "1024 MiB",
    "Problem Statement": "給定非負整數數列 A=(A_1,A_2,\\dots ,A_N),B=(B_1,B_2,\\dots ,B_N)，長度為 N，及一個正整數 M。\n當 A 的元素可以自由重新排列時，找出 \\max_{1≤ i≤ N} ((A_i+B_i) \\bmod M) 的最小可能值。\n給定 T 個測試案例，請為每個案例找出答案。",
    "Statement Images": [],
    "Constraints": "- 1 ≤ T ≤ 10^5\n- 1 ≤ N ≤ 3 \\times 10^5\n- 1 ≤ M ≤ 10^9\n- 0 ≤ A_i,B_i < M\n- 所有測試案例中 N 的總和至多為 3 \\times 10^5。\n- 所有輸入值都是整數。",
    "IO Styles": "輸入\n輸入是以以下格式從標準輸入給出：\nT\n\\text{case}_1\n\\text{case}_2\n\\vdots\n\\text{case}_T\n每個測試案例的格式如下：\nN M\nA_1 A_2 ... A_N\nB_1 B_2 ... B_N\n輸出\n輸出 T 行。\n第 j 行應該包含第 j 個測試案例中 \\max_{1≤ i≤ N} ((A_i+B_i) \\bmod M) 的最小可能值。",
    "Sample Detail": [
        {
            "input": "3\n3 6\n3 1 4\n2 0 1\n1 1000000000\n999999999\n999999999\n10 201\n144 150 176 154 110 187 38 136 111 46\n96 109 73 63 85 1 156 7 13 171\n",
            "output": "3\n999999998\n111\n",
            "explanation": "對於第一個測試用例，如果我們將 A 重新排列為 4,3,1，那麼 (A_i+B_i) \\bmod M 將分別變為 0,3,2，這些的最大值為 3。",
            "images": []
        }
    ],
    "Language": "cn"
}