{
    "Title": "Codeforces Round 1048 (Div. 2)",
    "Source": "codeforces",
    "Name": "Antiamuny and Slider Movement",
    "Time Limit": "5 s",
    "Memory Limit": "512 mb",
    "Problem Statement": "アンティアムニは、長さ $m$ の一次元トラック上に $n$ 本のスライダーを管理しています。各スライダーは正確に1ユニットのスペースを占有し、異なる位置から始まります。スライダーは $1$ から $n$ まで番号が付けられており、左から右に配置されているため、$i$ 番目のスライダーは初期位置 $a_i$ にいます。  \nアンティアムニは $q$ 回の操作を受け取ります。各操作は、2 つの整数 $i$ と $x$（$1≤ i≤ n$, $i ≤ x ≤ m - n + i$）によって説明されます。この操作は、$i$ 番目のスライダーを位置 $x$ に移動します。しかし、もしこの移動が別のスライダーとの衝突を引き起こす場合（すなわち、$i$ 番目のスライダーの現在位置と目的地 $x$ の間に他のスライダーが存在する場合）、その衝突するスライダーは、$i$ 番目のスライダーとの衝突が解消されるまで、同じ方向に1ユニット押されます。これにより、スライダーが他のスライダーを押し、さらに押し続けるチェーン反応が引き起こされる可能性があります。最終的に、すべてのスライダーが再び異なる位置を占有することになります。  \n重要なことに、操作はスライダーの相対的な順序を変更しません：左から $i$ 番目のスライダーは、左から $i$ 番目のままです。さらに、$x$ に関する制約は、すべてのスライダーが常にトラック上に留まることを保証し、位置は $1$ から $m$ の間にあります。  \n例として、初期スライダー位置が $[1, 3, 5, 7, 9]$ の場合を考えます。5 番目のスライダー（位置 $9$）を位置 $6$ に移動すると、4 番目のスライダーは $7$ から $5$ へ押され、続いて3 番目のスライダーは $5$ から $4$ に押されます。結果として、位置は $[1, 3, \\textbf{4}, \\textbf{5}, \\textbf{6}]$ になります。  \n残念ながら、アンティアムニは $q$ 回の操作が適用された順序を忘れてしまいました。結果を回復するために、彼は $q!$ の可能な操作の順列を独立にシミュレーションすることに決めました。各長さ $q$ の順列 $p$ に対して、$f_i(p)$ を $i$ 番目のスライダーの最終位置と定義します。この操作の順序で操作を適用した後の位置です。  \n言い換えれば、初期位置 $a_1, a_2, ..., a_n$ からスタートし、アンティアムニは最初に $p_1$ 番目の操作を適用し、次に $p_2$ 番目の操作を適用し、以下同様に $p_q$ 番目の操作を適用します。$f_i(p)$ の値は、この操作のシーケンスの最後での $i$ 番目のスライダーの位置です。  \nあなたのタスクは、各スライダー $i$ ($1≤ i≤ n$) に対して、すべての $q!$ の操作の順列 $p$ にわたる $f_i(p)$ の合計を計算することです。結果が大きくなる可能性があるため、各合計を $10^9 + 7$ で割った余りを出力してください。  \n$^{\\text{∗}}$ 長さ $q$ の順列は、1 から $q$ までの $q$ 個の異なる整数からなる配列で、任意の順序で構成されています。例えば、$[2,3,1,5,4]$ は順列ですが、$[1,2,2]$ は順列ではありません（$2$ が二回出現しているため）、また $[1,3,4]$ も順列ではありません（$q=3$ なのに $4$ が配列に含まれているため）。",
    "Statement Images": [],
    "Constraints": "Time limit: 5 s\nMemory limit: 512 mb",
    "IO Styles": "入力\n各テストは複数のテストケースを含む。最初の行にはテストケースの数 $t$ （$1 ≤ t ≤ 10^3$）が含まれる。テストケースの説明が続く。\n各テストケースの最初の行には、スライダーの数 $n$、トラックの長さ $m$、および操作の数 $q$ （$1 ≤ n,q ≤ 5 \\cdot 10^3$、$n ≤ m ≤ 10^9$）の3つの整数が含まれる。\n各テストケースの2行目には、$n$ 個の整数 $a_1, a_2, ..., a_n$ （$1 ≤ a_1 < a_2 < ... < a_n ≤ m$）が含まれ、各スライダーの初期位置を示す。\n次の $q$ 行にはそれぞれ2つの整数 $i$ と $x$ （$1 ≤ i ≤ n$、$i ≤ x ≤ m - n + i$）が含まれ、移動するスライダーのインデックスとスライダーを移動する位置を示す。\nすべてのテストケースに対する $n$ の合計と $q$ の合計は $5\\cdot 10^3$ を超えないことが保証されている。\n出力\n各テストケースに対して、$n$ 個の整数を出力せよ。その $i$ 番目の整数は、操作のすべての $q!$ の順列 $p$ に対する $f_i(p)$ の合計を、$10^9 + 7$ で割った余りを表す。",
    "Sample Detail": [
        {
            "input": "3\n5 10 3\n1 3 5 7 9\n5 6\n2 6\n1 4\n5 10 5\n2 3 5 7 9\n1 6\n4 7\n3 3\n5 7\n4 9\n3 1000000000 3\n1 10 253746392\n3 100000000\n3 1000000000\n3 500000000",
            "output": "18 29 35 41 47 \n340 460 580 930 1090 \n6 60 199999979 ",
            "explanation": "",
            "images": []
        }
    ],
    "Notes": "注意\n最初のテストケースでは：- 操作を順番に $[2,1,3]$ のように実行すると、最初に2番目の操作を適用し、2番目のスライダーを位置6に移動します。次に1番目の操作を適用し、5番目のスライダーを位置6に移動し、最後に3番目の操作を適用して1番目のスライダーを位置4に移動します。各操作後のスライダーの位置は下の図に示されています。スライダーの最終的な位置は $[4,5,6,7,8]$ になります。 ![image](1.png) - 操作を順番に $[1,2,3]$ のように実行すると、スライダーの最終的な位置は $[4,6,7,8,9]$ になります。- 操作を順番に $[1,3,2]$ のように実行すると、スライダーの最終的な位置は $[4,6,7,8,9]$ になります。- 操作を順番に $[2,3,1]$ のように実行すると、スライダーの最終的な位置は $[2,3,4,5,6]$ になります。- 操作を順番に $[3,1,2]$ のように実行すると、スライダーの最終的な位置は $[2,6,7,8,9]$ になります。- 操作を順番に $[3,2,1]$ のように実行すると、スライダーの最終的な位置は $[2,3,4,5,6]$ になります。\nスライダー1について、6つの異なるシナリオの位置の合計は $4 + 4 + 4 + 2 + 2 + 2 = 18$ です。\nスライダー2について、6つの異なるシナリオの位置の合計は $5 + 6 + 6 + 3 + 6 + 3 = 29$ です。\nスライダー3について、6つの異なるシナリオの位置の合計は $6 + 7 + 7 + 4 + 7 + 4 = 35$ です。\nスライダー4について、6つの異なるシナリオの位置の合計は $7 + 8 + 8 + 5 + 8 + 5 = 41$ です。\nスライダー5について、6つの異なるシナリオの位置の合計は $8 + 9 + 9 + 6 + 9 + 6 = 47$ です。",
    "Note Images": [
        "https://espresso.codeforces.com/7d5398150d613f4b33f34da67e8d70aeac5bfd6a.png"
    ],
    "Language": "jp"
}