{
    "Title": "Codeforces Round 1024 (Div. 1)",
    "Source": "codeforces",
    "Name": "Kia Bakes a Cake",
    "Time Limit": "6 s",
    "Memory Limit": "512 mb",
    "Problem Statement": "与えられたバイナリ文字列 $s$ の長さは $n$ であり、$n$ 頂点を持つ木 $T$ が与えられます。$s$ における 1 の数を $k$ とします。次に、以下のようにして $k$ 頂点を持つ完全無向加重グラフを構築します：\n\n- $1 ≤ i ≤ n$ で $s_i = \\mathtt{1}$ のとき、ラベル $i$ の頂点を作成します。\n- 上記の手順で作成されたラベル $u$ および $v$ の2つの頂点間の辺の重み $w(u, v)$ は、木 $T$ における頂点 $u$ と頂点 $v$ の間の距離$^{\\text{∗}}$ と定義されます。\n\n頂点ラベル $v_1, v_2, ..., v_m$ をこの順序で訪れる単純パス$^{\\text{†}}$ は、「良い」ものであるためには、全ての $1 ≤ i ≤ m - 2$ に対して、条件 $2 \\cdot w(v_i, v_{i + 1}) ≤ w(v_{i + 1}, v_{i + 2})$ が成り立つ必要があります。つまり、パス内の各辺の重みは、前の辺の重みの少なくとも2倍以上でなければなりません。さらに、$s_{v_i} = \\mathtt{1}$ がすべての $1 ≤ i ≤ m$ に対して満たされる必要があります。さもなくば、対応するラベルを持つ頂点は存在しません。\n\n完全無向加重グラフにおけるラベル $i$ ($1 ≤ i ≤ n$ および $s_i = \\mathtt{1}$) の各頂点に対して、その頂点から出発する任意の「良い」単純パスの最大の頂点数を求めてください。\n\n$^{\\text{∗}}$2つの頂点 $a$ と $b$ の間の距離は、頂点 $a$ と頂点 $b$ の間の唯一の単純パス上の辺の数に等しいです。\n\n$^{\\text{†}}$パスとは、すべての $1 ≤ i ≤ m - 1$ に対して $v_i$ と $v_{i + 1}$ の間に辺が存在する頂点の列 $v_1, v_2, ..., v_m$ のことです。単純パスは、重複しない頂点を持つパスであり、すなわち $v_i \\neq v_j$ が全ての $1 ≤ i < j ≤ m$ に対して成立します。",
    "Statement Images": [],
    "Constraints": "Time limit: 6 s\nMemory limit: 512 mb",
    "IO Styles": "入力\n各テストには複数のテストケースが含まれています。最初の行にはテストケースの数 $t$ ($1 ≤ t ≤ 10^4$) が含まれています。その後にテストケースの説明があります。\n各テストケースの最初の行には、単一の整数 $n$ ($1≤ n≤ 7\\cdot10^4$) が含まれます。これは、バイナリ文字列 $s$ の長さおよび木 $T$ の頂点の数です。\n各テストケースの2行目には、$n$ 文字からなるバイナリ文字列 $s_1s_2... s_n$ ($s_i\\in \\{\\mathtt{0}, \\mathtt{1}\\}$) が含まれています。これは、完全無向加重グラフで構築する頂点を表します。\n次の $n - 1$ 行には、2つの整数 $u$ と $v$ ($1≤ u, v≤ n$) が含まれています。これは、木 $T$ の辺の端点を示します。\n与えられた辺が木を形成することは保証されています。\n全てのテストケースにおける $n$ の合計が $7\\cdot10^4$ を超えないことが保証されています。\n出力\n各テストケースに対して、$n$ 個の整数を出力します。$i$ 番目の整数は、ラベルが $i$ の頂点から始まる任意のニiceな単純経路における最大の頂点数を表します。もしラベル $i$ の頂点が存在しない場合、すなわち、$s_i = \\mathtt{0}$ の場合は、その代わりに $-1$ を出力してください。",
    "Sample Detail": [
        {
            "input": "3\n5\n01111\n1 2\n2 3\n3 4\n4 5\n17\n01101011110101101\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n10 11\n11 12\n12 13\n13 14\n14 15\n15 16\n16 17\n2\n01\n1 2",
            "output": "-1 3 3 3 3 \n-1 5 4 -1 4 -1 5 5 5 5 -1 4 -1 5 5 -1 3 \n-1 1 ",
            "explanation": "",
            "images": []
        }
    ],
    "Notes": "注意\n最初のテストケースでは、木 $T$ と構築されたグラフは次のようになります: ![image](1.png) 左側は選択されたノードが黄色で色付けされた木 $T$ です。右側は構築された完全グラフです。\n図に示された良いパスは $3\\rightarrow 4\\rightarrow 2$ です。このパスが良いのは、$w(4, 2) = 2$ が $w(3, 4) = 1$ の少なくとも2倍であるためです。 $2\\rightarrow 5$ を使ってパスを拡張することはできません。なぜなら、$w(2, 5) = 3$ は $w(4, 2) = 2$ の2倍未満だからです。\n2番目のテストケースでは、木 $T$ は長さ $17$ の単純なパスです。ラベル $2$ の頂点から始まる良いパスの例は $2\\rightarrow 3\\rightarrow 5\\rightarrow 9\\rightarrow 17$ であり、エッジの重みはそれぞれ $1, 2, 4, 8$ で、毎回倍増します。",
    "Note Images": [
        "https://espresso.codeforces.com/2c018d3678fcc993cea93af930f4bc10bd9d0bed.png"
    ],
    "Language": "jp"
}