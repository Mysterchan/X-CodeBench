{
    "Title": "Codeforces Round 1010 (Div. 1, Unrated)",
    "Source": "codeforces",
    "Name": "Quantifier",
    "Time Limit": "2.5 s",
    "Memory Limit": "1024 mb",
    "Problem Statement": "給定一個根樹，其有 $n+1$ 個節點，標籤從 $0$ 到 $n$，根節點是節點 $0$，而其唯一的子節點是節點 $1$。有 $m$ 個標籤從 $1$ 到 $m$ 的獨特晶片，每個晶片顏色為黑色或白色。初始時，它們沿著邊 $(0,1)$ 自上而下按標籤的升序排列。 ![image](1.png) 晶片的初始位置。樹的節點以藍色顯示。\n\n您可以執行以下操作任意次數（可能為零），且順序不拘：\n- 選擇兩條邊 $(u,v)$ 和 $(v,w)$，使得 $u$ 是 $v$ 的父節點，而 $v$ 是 $w$ 的父節點，且邊 $(u,v)$ 包含至少一個晶片。將邊 $(u,v)$ 上最底部的晶片移動到邊 $(v,w)$ 上最上方的位置，即，位於邊 $(v,w)$ 上所有現有晶片的上方。\n- 選擇兩條邊 $(u,v)$ 和 $(v,w)$，使得 $u$ 是 $v$ 的父節點，而 $v$ 是 $w$ 的父節點，且邊 $(v,w)$ 包含至少一個晶片。將邊 $(v,w)$ 上最上面的晶片移動到邊 $(u,v)$ 上最底部的位置，即，位於邊 $(u,v)$ 上所有現有晶片的下方。\n- 選擇同一邊上相鄰的兩個顏色相同的晶片，並交換它們的位置。 ![image](2.png) 允許的操作。\n\n每個晶片 $i$ 有一個移動範圍，定義為從根節點到節點 $d_i$ 的簡單路徑上的所有邊。在操作期間，您必須確保沒有晶片移動到其移動範圍之外的邊。\n\n最後，您必須將所有晶片移回邊 $(0,1)$。可以發現，晶片的順序可能會改變。計算最終排列在邊 $(0,1)$ 上的晶片可能排列數，取模 $998\\,244\\,353$。\n\n晶片的排列定義為長度為 $m$ 的序列，包含晶片的標籤，自上而下排列。",
    "Statement Images": [
        "https://espresso.codeforces.com/f79beceda869b93708d99a9c5c675f8ce5e85bb0.png",
        "https://espresso.codeforces.com/a22e8f28ba353e1412a98f45d7ba447d6438a0ec.png"
    ],
    "Constraints": "Time limit: 2.5 s\nMemory limit: 1024 mb",
    "IO Styles": "輸入\n每個測試包含多個測試案例。第一行包含測試案例的數量 $t$ ($1 ≤ t ≤ 5000$)。接下來是測試案例的描述。\n每個測試案例的第一行包含兩個整數 $n$ 和 $m$ ($1 ≤ n, m ≤ 5000$) — 樹的大小減一（即，樹有 $n+1$ 個節點）和棋子的數量。\n第二行包含 $n$ 個整數 $p_1, p_2, ..., p_n$ ($0 ≤ p_i < i$) — 從 $1$ 到 $n$ 的節點的父節點。保證當且僅當 $i = 1$ 時 $p_i = 0$（根的唯一子節點是節點 $1$）。\n第三行包含 $m$ 個整數 $c_1, c_2, ..., c_m$ ($c_i \\in \\{0, 1\\}$) — 每個棋子的顏色（$0$ 代表黑色，$1$ 代表白色）。\n第四行包含 $m$ 個整數 $d_1, d_2, ..., d_m$ ($1≤ d_i ≤ n$) — 每個棋子的移動範圍。\n保證所有測試案例中 $n$ 的總和不超過 $5000$，且 $m$ 的總和不超過 $5000$。\n輸出\n對於每個測試案例，輸出一個整數 — 棋子的可能排列數量模 $998\\,244\\,353$。",
    "Sample Detail": [
        {
            "input": "4\n3 2\n0 1 1\n0 1\n2 3\n4 4\n0 1 1 2\n0 0 1 1\n1 2 3 3\n6 6\n0 1 1 1 4 5\n0 0 0 0 1 1\n5 6 1 2 4 3\n16 15\n0 1 1 3 1 3 4 3 3 7 1 6 11 5 8 10\n1 0 1 1 0 1 1 1 1 0 1 1 0 0 0\n12 14 13 10 9 16 11 14 13 15 16 10 2 2 5",
            "output": "2\n8\n108\n328459046",
            "explanation": "",
            "images": []
        }
    ],
    "Notes": "注意\n在第一個測試案例中，我們可以達到以下 $2$ 種排列：($1,2$) 和 ($2,1$)。\n在第二個測試案例中，我們可以達到以下 $8$ 種排列：($1,2,3,4$)、($1,2,4,3$)、($1,3,2,4$)、($1,3,4,2$)、($1,4,2,3$)、($1,4,3,2$)、($2,1,3,4$) 和 ($2,1,4,3$)。",
    "Note Images": [],
    "Language": "cn"
}