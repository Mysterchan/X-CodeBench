{
    "Title": "Codeforces Round 1042 (Div. 3)",
    "Source": "codeforces",
    "Name": "Arboris Contractio",
    "Time Limit": "2 s",
    "Memory Limit": "256 mb",
    "Problem Statement": "Kagari 正在準備為一棵樹進行檔案存檔，而她知道這樣做的成本將取決於樹的直徑$^{\\text{∗}}$。為了降低開支，她的目標是首先儘可能縮小直徑。她可以對樹執行以下操作：\n- 選擇兩個頂點 $s$ 和 $t$。讓從 $s$ 到 $t$ 的簡單路徑上的頂點序列為 $v_0, v_1, \\dots, v_k$，其中 $v_0 = s$ 且 $v_k = t$。\n- 移除沿著路徑的所有邊。換句話說，移除邊 $(v_0, v_1), (v_1, v_2), \\dots, (v_{k-1}, v_k)$。\n- 將頂點 $v_1, v_2, \\dots, v_k$ 直接連接到 $v_0$。換句話說，新增邊 $(v_0, v_1), (v_0, v_2), \\dots, (v_0, v_k)$。\n\n可以證明，在執行此操作後，圖形仍然是一棵樹。\n幫助她計算實現最小直徑所需的最少操作次數。\n$^{\\text{∗}}$樹的直徑是任意一對頂點之間可能的最長距離。距離本身是通過連接它們的唯一簡單路徑上的邊數來測量的。\n$^{\\text{†}}$簡單路徑是樹中兩個頂點之間不會重複拜訪任何頂點的路徑。可以證明，任意兩個頂點之間的簡單路徑始終是唯一的。",
    "Statement Images": [],
    "Constraints": "Time limit: 2 s\nMemory limit: 256 mb",
    "IO Styles": "輸入\n每個測試包含多個測試案例。第一行包含測試案例的數量 $t$ ($1 ≤ t ≤ 10^4$)。接下來是每個測試案例的描述。\n每個測試案例的第一行包含一個整數 $n$ ($2 ≤ n ≤ 2 \\cdot 10^5$) — 樹中頂點的數量。\n每個測試案例接下來的 $n-1$ 行描述了樹。每行包含兩個整數 $u$ 和 $v$ ($1 ≤ u, v ≤ n$, $u \\neq v$)，表示頂點 $u$ 和 $v$ 之間的邊。這些邊保證形成一棵樹。\n所有測試案例中 $n$ 的總和不超過 $2 \\cdot 10^5$。\n輸出\n對於每個測試案例，輸出一個整數 — 最小化樹直徑所需的最小操作次數。",
    "Sample Detail": [
        {
            "input": "4\n4\n1 2\n1 3\n2 4\n2\n2 1\n4\n1 2\n2 3\n2 4\n11\n1 2\n1 3\n2 4\n3 5\n3 8\n5 6\n5 7\n7 9\n7 10\n5 11",
            "output": "1\n0\n0\n4",
            "explanation": "",
            "images": []
        }
    ],
    "Notes": "註\n在第一個測試案例中，原始樹的直徑為 $3$。Kagari 可以執行操作，在 $s = 3$ 和 $t = 4$。如圖所示，操作包括以下步驟：\n- 移除邊 $(3, 1)$、$(1, 2)$ 和 $(2, 4)$。\n- 添加邊 $(3, 1)$、$(3, 2)$ 和 $(3, 4)$。\n![image](1.png) \n在操作後，直徑減少為 $2$。可以證明 $2$ 是最小直徑。\n在第二個測試案例中，樹的直徑為 $1$。可以證明 $1$ 已經是最小值，因此 Kagari 無法執行任何操作。",
    "Note Images": [
        "https://espresso.codeforces.com/467bf647ed9e08a9d0b5a5ae0054b9dd76da0a9e.png"
    ],
    "Language": "cn"
}