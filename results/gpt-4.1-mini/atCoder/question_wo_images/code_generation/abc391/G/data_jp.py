MOD = 998244353

def main():
    import sys
    input = sys.stdin.readline

    N, M = map(int, input().split())
    S = input().strip()

    # dp[i][j][k]: i文字目までのS, j文字目までのTでのLCS長がkの文字列の個数
    # i: 0..N, j: 0..M, k: 0..min(i,j)
    # ただし、jは最大M=100, i最大10なのでメモリ的に問題なし

    # しかし、Tは全ての長さMの文字列を考えるため、Tの文字列を列挙は不可能。
    # そこでDPで「Sのi文字目まで見て、Tのj文字目まで見て、LCS長がkの文字列の個数」を計算する。

    # 状態遷移:
    # dp[i][j][k] = number of T[:j] strings such that LCS(S[:i], T[:j]) = k

    # 初期条件:
    # dp[0][0][0] = 1 (空文字列同士のLCSは0)
    # dp[0][j][0] = 26^j (Sが空なのでLCSは0で固定)
    # dp[i][0][0] = 1 (Tが空なのでLCSは0)

    # 遷移:
    # S[i-1], T[j-1]を比較
    # T[j-1]は26通りの文字のいずれか
    # それぞれの文字cについて
    # if c == S[i-1]:
    #   dp[i][j][k] += dp[i-1][j-1][k-1]
    # else:
    #   dp[i][j][k] += dp[i-1][j-1][k]

    # しかし、T[j-1]は26通りの文字があるため、
    # dp[i][j][k] = dp[i][j][k] + dp[i-1][j-1][k-1] * 1 (for c == S[i-1])
    #                + dp[i-1][j-1][k] * 25 (for c != S[i-1])

    # さらに、T[j-1]を使わない場合もあるので、
    # dp[i][j][k] += dp[i][j-1][k] * 26 (Tのj文字目を決める)

    # しかし、上記は誤り。Tの文字列は長さM固定で、全ての文字列を考える。
    # dp[i][j][k]は「Sのi文字目まで、Tのj文字目まで見てLCSがkの文字列の個数」ではなく、
    # 「Sのi文字目まで、Tのj文字目までの部分文字列でLCSがkの文字列の個数」ではない。

    # 正しい考え方:
    # dp[i][j][k]: Sのi文字目まで、Tのj文字目までの部分文字列でLCSがkの文字列の個数
    # ここでTは全ての長さjの文字列を考慮している。

    # つまり、dp[i][j][k]は「S[:i]と長さjの全ての文字列のうちLCSがkのものの個数」

    # 初期化
    dp = [[[0]*(N+1) for _ in range(M+1)] for __ in range(N+1)]
    dp[0][0][0] = 1

    # 26^jの計算用
    pow26 = [1]*(M+1)
    for x in range(1, M+1):
        pow26[x] = (pow26[x-1]*26)%MOD

    for i in range(N+1):
        for j in range(M+1):
            for k in range(N+1):
                if dp[i][j][k] == 0:
                    continue
                val = dp[i][j][k]
                if j == M:
                    continue
                # 次の文字を決める
                # 26通りの文字を考える
                # そのうち1文字はS[i]と一致するかもしれない（ただしi<N）
                # それ以外は不一致

                # 1. 不一致文字を選ぶ場合
                # LCSは変わらない
                dp[i][j+1][k] = (dp[i][j+1][k] + val * 25) % MOD

                # 2. 一致文字を選ぶ場合
                if i < N:
                    # LCSがk+1になる場合
                    if k+1 <= N:
                        dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + val) % MOD
                    # または一致文字を選んでもLCSがkのままの場合もあるが、
                    # それはdp[i][j][k]から遷移しない（LCSは増えるか同じかだが一致文字で増えないのはない）
                    # ここでLCSは最長共通部分列なので、文字が一致したらLCSは増えるか同じか？
                    # 一致文字を使ってLCSが増えないことはないので、増える場合のみ考える。

                # 3. 一致文字がない場合（i==N）
                # つまりSの文字がもうないので、すべて不一致文字
                if i == N:
                    # すべて不一致文字なのでLCSは変わらない
                    # 25文字の不一致文字はすでに加算済み
                    # 1文字の一致文字はないのでここはスキップ
                    pass

    # dp[N][M][k]はS全体と長さMの文字列のうちLCSがkのものの個数
    # しかし、dp[N][M][k]はSのN文字目まで見ているのでOK

    # ただし、dp[N][M][k]は「SのN文字目まで、TのM文字目までの文字列でLCSがkのものの個数」
    # これが求める答え

    # しかし、上記の遷移は誤り。なぜなら、dp[i][j][k]は「Sのi文字目まで、Tのj文字目までの文字列のうちLCSがkのものの個数」ではなく、
    # 「Sのi文字目まで、Tのj文字目までの文字列のうちLCSがkのものの個数の合計」ではない。

    # もう一度考え直す。

    # 正しいDPの定義:
    # dp[i][j][k]: Sのi文字目まで、Tのj文字目までの文字列のうちLCSがkのものの個数

    # 遷移:
    # Tのj文字目にcを選ぶ(26通り)
    # もし i>0かつ c == S[i-1]:
    #   dp[i][j][k] += dp[i-1][j-1][k-1]
    # else:
    #   dp[i][j][k] += dp[i][j-1][k] * 26

    # しかし、これはTの文字列を1文字ずつ決めていくDPで、Sは固定。

    # ここで、Sは固定で長さN、Tは長さMの文字列全体を考える。

    # そこで、dp[i][k]: i文字目まで見て、LCSがkの文字列の個数を管理し、Tの文字列は1文字ずつ決めていく。

    # つまり、Tの文字列を1文字ずつ決めていくDPを作る。

    # dp[j][k]: Tのj文字目まで決めて、SのLCSがkの文字列の個数

    # 遷移:
    # dp[j+1][k'] += dp[j][k] * (文字cの選び方)

    # 文字cを選ぶとき、LCSがkからk'にどう変わるかを考える。

    # ここで、Sは長さN、Tは長さM。

    # 文字cを選ぶとき、LCSがkからk'に変わるかはSのどの位置にcがあるかによる。

    # しかし、LCSは部分列なので、文字cがSのどの位置にあるかでLCSが増えるかどうか決まる。

    # そこで、Sの文字列の位置を管理する必要がある。

    # つまり、状態にSのどこまでマッチしたかを含める。

    # これを「部分列DP」と呼ぶ。

    # 状態:
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数

    # しかし、LCSは部分列なので、どの位置までSをマッチさせたかを管理する必要がある。

    # そこで、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # だけではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # で十分か？

    # いいえ。LCSの長さは部分列の長さなので、どの位置までSを使ったかを管理しないと正確に計算できない。

    # そこで、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # そこで、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここで、Sの長さNは最大10なので、Sのどこまでマッチしたかを状態に含めることができる。

    # つまり、状態を
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # ではなく、
    # dp[j][k]: Tのj文字目まで決めて、LCSがkの文字列の個数
    # かつ、Sのどこまでマッチしたかを管理する必要がある。

    # ここ