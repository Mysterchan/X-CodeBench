import sys
sys.setrecursionlimit(10**7)

N = int(sys.stdin.readline())
A = sys.stdin.readline().strip()

# dp(pos, level) будет возвращать кортеж (cost0, cost1)
# cost0 - минимальное количество изменений, чтобы поддерево с корнем pos на уровне level дало 0
# cost1 - минимальное количество изменений, чтобы поддерево с корнем pos на уровне level дало 1
# уровень 0 - листья (элементы A)
# длина поддерева на уровне level = 3^(N - level)

# Для уровня 0 (листья) cost0 = 0 если A[pos] == '0' иначе 1
# cost1 = 0 если A[pos] == '1' иначе 1

# Для уровня > 0:
# Поддерево разбивается на 3 поддерева уровня level-1:
# pos, pos+size, pos+2*size, где size = 3^(N - level)
# Для каждого из 3 поддеревьев есть cost0 и cost1
# Нужно выбрать значения для 3 поддеревьев, чтобы мажоритарное значение был 0 или 1
# Мажоритарное значение 0: минимум 2 из 3 поддеревьев должны быть 0
# Мажоритарное значение 1: минимум 2 из 3 поддеревьев должны быть 1

# Перебираем все варианты выбора значений поддеревьев, удовлетворяющих мажоритарному условию,
# и выбираем минимальную сумму cost.

from functools import lru_cache

pow3 = [1]*(N+1)
for i in range(1, N+1):
    pow3[i] = pow3[i-1]*3

@lru_cache(None)
def dp(pos, level):
    if level == 0:
        # leaf
        c0 = 0 if A[pos] == '0' else 1
        c1 = 0 if A[pos] == '1' else 1
        return (c0, c1)
    size = pow3[N - level]
    children = [dp(pos + i*size, level - 1) for i in range(3)]
    # children[i] = (cost0_i, cost1_i)

    # Для получения результата 0 нужно, чтобы минимум 2 из 3 были 0
    # Для получения результата 1 нужно, чтобы минимум 2 из 3 были 1

    # Перебираем все варианты выбора значений для 3 детей, удовлетворяющих мажоритарному условию
    # Для результата 0: выбираем все варианты, где количество 0 >= 2
    # Для результата 1: выбираем все варианты, где количество 1 >= 2

    # Для каждого варианта считаем сумму cost

    # Варианты для результата 0 (выбираем для каждого child 0 или 1):
    # Нужно, чтобы количество выбранных 0 >= 2
    # Переберем все 8 вариантов (2^3), выберем те, где количество 0 >= 2

    # Аналогично для результата 1: количество выбранных 1 >= 2

    # Для оптимизации: перебор 8 вариантов

    # cost0
    min_cost0 = 10**9
    for mask in range(8):
        # mask битами: 0 - child0, 1 - child1, 2 - child2
        # если бит=0, выбираем cost0, если 1 - cost1
        vals = []
        for i in range(3):
            if (mask >> i) & 1:
                vals.append(children[i][1])
            else:
                vals.append(children[i][0])
        zeros = sum(1 for i in range(3) if ((mask >> i) & 1) == 0)
        if zeros >= 2:
            s = sum(vals)
            if s < min_cost0:
                min_cost0 = s

    # cost1
    min_cost1 = 10**9
    for mask in range(8):
        vals = []
        for i in range(3):
            if (mask >> i) & 1:
                vals.append(children[i][1])
            else:
                vals.append(children[i][0])
        ones = sum(1 for i in range(3) if ((mask >> i) & 1) == 1)
        if ones >= 2:
            s = sum(vals)
            if s < min_cost1:
                min_cost1 = s

    return (min_cost0, min_cost1)

cost0, cost1 = dp(0, N)
# A' = dp(0, N) gives cost to get 0 or 1 at root
# Начальное значение A'_1 - это majority от A
# Нужно минимальное количество изменений, чтобы изменить A'_1

# Определим исходное значение A'_1
# Для этого можно просто вычислить majority N раз, но это дорого
# Можно определить исходное значение по dp:
# dp(0,N) возвращает cost0 и cost1 - минимальные изменения для получения 0 или 1
# Исходное значение - то, для которого cost = 0 (т.к. без изменений)
# Если cost0 == 0, значит исходное значение 0
# Если cost1 == 0, значит исходное значение 1

if cost0 == 0:
    # исходное значение 0, нужно изменить на 1
    print(cost1)
else:
    # исходное значение 1, нужно изменить на 0
    print(cost0)