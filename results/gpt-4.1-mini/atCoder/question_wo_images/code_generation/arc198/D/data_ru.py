import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N = int(input())
edges = [[] for _ in range(N)]
for _ in range(N-1):
    u,v = map(int,input().split())
    u -= 1
    v -= 1
    edges[u].append(v)
    edges[v].append(u)

A = [list(map(int,list(input().strip()))) for _ in range(N)]

# Проверка симметричности и диагонали A (по условию гарантируется, но проверим для безопасности)
for i in range(N):
    if A[i][i] != 1:
        print(10**100)
        exit(0)
    for j in range(i+1,N):
        if A[i][j] != A[j][i]:
            print(10**100)
            exit(0)

# Идея решения:
# Нам нужно найти целочисленную последовательность x, такую что:
# Для каждой пары (i,j) с A[i][j] = 1 путь от i до j в дереве по x должен быть палиндромом.
# Если для какой-то пары (i,j) с A[i][j]=1 путь не палиндром, оценка = 10^100.
# Иначе оценка = количество палиндромных пар (i,j).

# Минимизировать оценку означает:
# - Если есть пара (i,j) с A[i][j]=1, которая не палиндром, оценка = 10^100 (хуже)
# - Иначе оценка = количество палиндромных пар (i,j).

# Заметим, что если A[i][j]=1, то x на пути i->j должен быть палиндромом.
# Значит, для всех таких путей, значения x на вершинах должны удовлетворять условию палиндрома.

# Рассмотрим граф пар вершин (u,v), где u,v - вершины дерева.
# Для каждой пары (i,j) с A[i][j]=1, путь i->j должен быть палиндромом.
# Пусть путь i->j: v_1=i, v_2, ..., v_n=j.
# Тогда x[v_k] = x[v_{n+1-k}] для всех k.

# Это накладывает равенства между x[u] и x[v] для некоторых пар (u,v).
# Построим граф равенств между вершинами x[u] и x[v].

# Для каждой пары (i,j) с A[i][j]=1:
# - Найдем путь i->j (уникальный в дереве)
# - Для k=1..len(path)//2:
#   x[path[k]] = x[path[len(path)-1-k]]

# Построим граф равенств между вершинами x[u].
# Если в графе равенств есть конфликт (например, x[u] != x[u]), то оценка = 10^100.

# После построения графа равенств, каждая компонента связности должна иметь одинаковое значение x.
# Значения x - целочисленные, но нам не важны конкретные значения, важна только возможность присвоить значения без конфликтов.

# Если конфликтов нет, то оценка = количество палиндромных пар (i,j).

# Теперь, как посчитать количество палиндромных пар (i,j) для найденной x?

# Пары (i,j) палиндромны, если путь i->j палиндромен по x.
# Для x, где вершины в одной компоненте равны, путь палиндромен, если для каждой пары вершин на пути, соответствующие вершины равны.

# Но мы уже гарантировали, что для пар (i,j) с A[i][j]=1 путь палиндромен.

# Для пар (i,j) с A[i][j]=0, путь может быть палиндромен или нет.

# Чтобы минимизировать оценку, нам нужно минимизировать количество палиндромных пар (i,j).

# Но оценка - это количество палиндромных пар (i,j) среди всех пар (i,j).

# Минимальная оценка достигается, когда x минимально палиндромен, то есть
# палиндромны только те пары, которые обязаны быть палиндромными (A[i][j]=1),
# и остальные пары не палиндромны.

# Но мы не можем сделать так, чтобы путь был не палиндромом, если вершины в пути равны по компонентам.

# Значит, палиндромность зависит от равенства x на вершинах пути.

# Если вершины пути принадлежат к разным компонентам равенств, то x[u] != x[v], и путь не палиндром.

# Если вершины пути принадлежат одной компоненте, то путь палиндромен.

# Таким образом, палиндромность пары (i,j) равна True тогда и только тогда, когда
# для всех k: x[v_k] = x[v_{n+1-k}], то есть вершины на пути парно равны.

# Но мы уже связали вершины, которые должны быть равны.

# Значит, палиндромность пары (i,j) равна True тогда и только тогда, когда
# для каждой пары вершин на пути (v_k, v_{n+1-k}) они принадлежат к одной компоненте равенств.

# Если для пары (i,j) с A[i][j]=1 это условие не выполняется, оценка = 10^100.

# Иначе оценка = количество пар (i,j), для которых условие выполняется.

# Теперь алгоритм:

# 1) Построить дерево.
# 2) Для каждой пары (i,j) с A[i][j]=1:
#    - Найти путь i->j.
#    - Для каждой пары вершин (v_k, v_{n+1-k}) на пути добавить ребро равенства.
# 3) Построить DSU (Disjoint Set Union) для вершин.
# 4) Объединить вершины, которые должны быть равны.
# 5) Проверить, нет ли конфликтов (например, если вершина должна быть равна двум разным значениям, но у нас нет ограничений на значения, конфликтов не будет).
# 6) Для подсчёта палиндромных пар (i,j):
#    - Для всех пар (i,j):
#      - Найти путь i->j.
#      - Проверить, что для каждой пары (v_k, v_{n+1-k}) они принадлежат к одной компоненте DSU.
#      - Если да, увеличить счётчик.
# 7) Вывести счётчик.

# Но N=3000, перебор всех пар (i,j) и поиск пути - O(N^3) - слишком много.

# Оптимизация:

# - Для поиска пути i->j можно использовать LCA (Lowest Common Ancestor).
# - Путь i->j = путь i->LCA + путь LCA->j.
# - Можно быстро получить вершины на пути.
# - Но проверять для всех пар (i,j) - O(N^2) - возможно, но надо оптимизировать.

# - Для проверки палиндромности пути (i,j):
#   Нужно проверить, что для каждой пары вершин на пути (v_k, v_{n+1-k}) они в одной компоненте DSU.

# - Можно заметить, что палиндромность пути зависит от "симметричных" пар вершин на пути.

# - Можно для каждой вершины v хранить её компоненту DSU.

# - Для проверки палиндромности пути (i,j), можно проверить для всех пар вершин на пути.

# Но это дорого.

# Можно сделать так:

# Для каждой вершины v, определим её "label" = DSU.find(v).

# Пусть dist(u,v) - длина пути между u и v.

# Пусть path i->j: v_1=i, v_2, ..., v_n=j, n=dist(i,j)+1.

# Палиндромность пути означает:
# label[v_k] == label[v_{n+1-k}] для всех k=1..n.

# Можно проверить это, если для k=1..n//2 проверить пары.

# Но для всех пар (i,j) это O(N^3).

# Нужно оптимизировать.

# Решение:

# 1) Построим DSU по равенствам.

# 2) Для каждой вершины v, label[v] = DSU.find(v).

# 3) Построим массив euler-tour дерева и массив глубин.

# 4) Для каждого узла v, запишем label[v].

# 5) Для проверки палиндромности пути i->j:

#    - Найдем LCA(i,j).

#    - Путь i->j состоит из пути i->LCA и LCA->j.

#    - Путь i->LCA: вершины v_i, v_{i-1}, ..., LCA

#    - Путь LCA->j: вершины LCA, v_{LCA+1}, ..., v_j

#    - Объединим путь в массив path.

#    - Проверим палиндромность path по label.

# Но это дорого.

# 6) Оптимизация:

# Для каждого узла v, определим массив label[v].

# Для каждого узла v, построим массив label по глубине.

# Для проверки палиндромности пути i->j:

# - Пусть d_i = depth[i], d_j = depth[j], d_l = depth[LCA(i,j)]

# - Длина пути = d_i + d_j - 2*d_l + 1

# - Путь: i->LCA (вниз по дереву), LCA->j (вверх по дереву)

# - Можно представить путь как конкатенация двух цепочек.

# - Палиндромность пути означает, что label на позициях симметричны.

# Можно проверить палиндромность пути, если label[v] = label[u] для пар вершин на пути.

# Но это сложно.

# 7) Другой подход:

# Построим граф пар вершин (u,v), которые должны быть равны (DSU).

# Теперь, для каждой пары (i,j) с A[i][j]=1, путь i->j палиндромен.

# Для каждой пары (i,j) с A[i][j]=0, если путь i->j палиндромен, то пара (i,j) считается палиндромной.

# Нам нужно посчитать количество палиндромных пар (i,j).

# 8) Для подсчёта палиндромных пар (i,j):

# Можно заметить, что палиндромность пути зависит от равенства меток на вершинах пути.

# Если мы заменим каждую вершину на её DSU-компоненту, то путь палиндромен, если последовательность меток на пути - палиндром.

# Но метки - это компоненты DSU.

# Если в пути встречается метка, которая не симметрична, то путь не палиндром.

# 9) Для упрощения, заметим, что если в пути i->j все вершины принадлежат к одной и той же DSU-компоненте, то путь палиндромен (все x равны).

# Если путь содержит вершины из разных компонент, то путь не палиндром, так как x[u] != x[v].

# Но это слишком строго.

# Палиндромность требует, чтобы для каждой пары вершин (v_k, v_{n+1-k}) метки совпадали.

# Значит, если путь i->j имеет длину 1 (i=j), палиндром.

# Если длина >1, нужно проверить пары.

# 10) Для оптимизации:

# Построим для каждой вершины v массив label[v] = DSU.find(v).

# Для каждого ребра дерева (u,v), label[u], label[v].

# Построим массив label по глубине.

# Для проверки палиндромности пути i->j:

# - Найдем LCA(i,j).

# - Путь i->j: вершины i->LCA и LCA->j.

# - Можно представить путь как массив меток.

# - Проверим палиндромность меток.

# Но это дорого.

# 11) Итог:

# Мы не можем проверить палиндромность для всех пар (i,j) напрямую.

# Но нам нужно минимизировать оценку.

# Если существует пара (i,j) с A[i][j]=1 и путь не палиндром, оценка = 10^100.

# Иначе оценка = количество палиндромных пар.

# Минимальная оценка достигается, когда палиндромны только пары (i,j) с A[i][j]=1 и пары (i,i).

# Но пары (i,i) всегда палиндромны.

# Значит, минимальная оценка = количество пар (i,j) с A[i][j]=1 + N (диагональ).

# Но в условии A[i,i]=1, значит диагональ уже учтена.

# Значит минимальная оценка >= количество единиц в A.

# Но в примерах оценка больше.

# 12) В примерах оценка равна количеству палиндромных пар (i,j).

# В примере 1:

# Палиндромные пары: (1,1),(2,2),(3,3),(4,4),(2,4),(4,2) = 6.

# Значит, палиндромность распространяется и на пары (2,4) и (4,2), где A[2][4]=1.

# 13) Предлагаемое решение:

# Построим DSU по равенствам из пар (i,j) с A[i][j]=1.

# Для каждой пары (i,j) с A[i][j]=1:

# - Найдем путь i->j.

# - Для каждой пары вершин (v_k, v_{n+1-k}) на пути объединим их в DSU.

# Если в процессе возникает конфликт (например, вершина должна быть равна двум разным значениям), то оценка = 10^100.

# После построения DSU, для каждой вершины v определим label[v] = DSU.find(v).

# Теперь, для подсчёта палиндромных пар (i,j):

# - Для всех пар (i,j):

#   - Найдем путь i->j.

#   - Проверим, что для каждой пары вершин (v_k, v_{n+1-k}) на пути label[v_k] == label[v_{n+1-k}].

#   - Если да, увеличим счётчик.

# 14) Оптимизация подсчёта:

# - Для каждого узла v, построим массив label[v].

# - Для каждого узла v, построим массив глубин.

# - Для каждого узла v, построим массив parent для LCA.

# - Для каждого узла v, построим массив label по глубине.

# - Для проверки палиндромности пути i->j:

#   - Найдем LCA(i,j).

#   - Длина пути = d_i + d_j - 2*d_l + 1.

#   - Путь: i->LCA (обратный путь), LCA->j (прямой путь).

#   - Получим массив меток на пути.

#   - Проверим палиндромность меток.

# Но это O(N^3).

# 15) Для ускорения:

# - Можно использовать хеширование для проверки палиндромности.

# - Построим для каждого узла v массив label[v].

# - Построим префиксные хеши по глубине.

# - Для пути i->j, получим хеш прямого и обратного пути и сравним.

# Но это сложно.

# 16) Альтернативный подход:

# - Для каждой вершины v, определим label[v].

# - Для каждой вершины v, построим массив label[v] по глубине.

# - Для каждого узла v, построим массив label[v] по euler-tour.

# - Для проверки палиндромности пути i->j:

#   - Разобьем путь на две части: i->LCA и LCA->j.

#   - Проверим палиндромность.

# 17) Но это сложно реализовать за время.

# 18) Предлагаем решение с ограничением:

# - Построим DSU по равенствам.

# - Проверим, что для каждой пары (i,j) с A[i][j]=1, путь i->j палиндромен (то есть для каждой пары вершин (v_k, v_{n+1-k}) label[v_k] == label[v_{n+1-k}]).

# - Если нет, вывести 10^100.

# - Иначе, оценка = количество пар (i,j), для которых путь i->j палиндромен.

# - Для подсчёта палиндромных пар (i,j) переберем все пары (i,j) и проверим палиндромность.

# - Для N=3000 это O(N^3), но с оптимизациями и быстрым LCA можно пройти.

# 19) Реализация:

# - Построим дерево.

# - Построим LCA с бинарным подъёмом.

# - Для каждой пары (i,j) с A[i][j]=1:

#   - Найдем путь i->j.

#   - Для каждой пары вершин (v_k, v_{n+1-k}) объединим их в DSU.

# - Проверим, что для каждой пары (i,j) с A[i][j]=1 путь палиндромен.

# - Если нет, вывести 10^100.

# - Иначе, переберем все пары (i,j):

#   - Проверим палиндромность пути i->j.

#   - Если палиндром, увеличить счётчик.

# - Вывести счётчик.

# 20) Для перебора всех пар (i,j) и проверки палиндромности пути:

# - Для каждого i:

#   - Для каждого j:

#     - Найдем LCA(i,j).

#     - Получим длину пути.

#     - Для k=0..(len(path)//2):

#       - Получим вершины v_k и v_{n-1-k} на пути.

#       - Проверим label[v_k] == label[v_{n-1-k}].

#     - Если все совпадают, увеличить счётчик.

# 21) Для получения вершин на пути:

# - Можно получить k-ю вершину на пути i->j с помощью LCA и бинарного подъёма.

# - Для k < depth[i]-depth[lca]+1:

#   - k-я вершина на пути i->j - это k-я вершина на пути i->lca (поднимаемся вверх).

# - Иначе:

#   - k-я вершина на пути i->j - это (len(path)-k-1)-я вершина на пути j->lca (поднимаемся вверх).

# 22) Реализуем функцию get_kth_vertex(i,j,k):

# - k от 0 до len(path)-1

# - len(path) = depth[i] + depth[j] - 2*depth[lca] + 1

# - Если k <= depth[i]-depth[lca]:

#   - Поднимаемся на k шагов вверх от i.

# - Иначе:

#   - Поднимаемся на (len(path)-k-1) шагов вверх от j.

# 23) Реализация DSU, LCA, get_kth_vertex, проверка палиндромности.

# 24) Вывод результата.

# 25) Если оценка = 10^100, вывести 10^100.

# 26) Иначе вывести количество палиндромных пар.

# 27) Для ускорения можно прервать проверку палиндромности при первом несовпадении.

# 28) Для N=3000 решение может быть на грани, но с оптимизациями и PyPy возможно.

# 29) В задаче не указано ограничение по времени, предположим, что решение с оптимизациями пройдет.

# Реализация ниже.

class DSU:
    def __init__(self,n):
        self.p = list(range(n))
    def find(self,x):
        while self.p[x] != x:
            self.p[x] = self.p[self.p[x]]
            x = self.p[x]
        return x
    def union(self,a,b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return False
        self.p[b] = a
        return True

LOG = 15  # ~log2(3000)

parent = [[-1]*N for _ in range(LOG)]
depth = [0]*N

def dfs(v,p):
    for u in edges[v]:
        if u == p:
            continue
        depth[u] = depth[v]+1
        parent[0][u] = v
        dfs(u,v)

dfs(0,-1)

for k in range(1,LOG):
    for v in range(N):
        if parent[k-1][v] != -1:
            parent[k][v] = parent[k-1][parent[k-1][v]]

def lca(u,v):
    if depth[u] < depth[v]:
        u,v = v,u
    for k in reversed(range(LOG)):
        if parent[k][u] != -1 and depth[parent[k][u]] >= depth[v]:
            u = parent[k][u]
    if u == v:
        return u
    for k in reversed(range(LOG)):
        if parent[k][u] != -1 and parent[k][u] != parent[k][v]:
            u = parent[k][u]
            v = parent[k][v]
    return parent[0][u]

def up(u,steps):
    for k in range(LOG):
        if steps & (1<<k):
            u = parent[k][u]
    return u

def get_kth_vertex(i,j,k):
    # k from 0 to length-1
    l = lca(i,j)
    dist = depth[i] + depth[j] - 2*depth[l] + 1
    di = depth[i] - depth[l]
    if k <= di:
        return up(i,k)
    else:
        k2 = dist - k - 1
        return up(j,k2)

dsu = DSU(N)

# Объединяем вершины по условиям палиндрома для пар (i,j) с A[i][j]=1
for i in range(N):
    for j in range(i,N):
        if A[i][j] == 1:
            l = lca(i,j)
            length = depth[i] + depth[j] - 2*depth[l] + 1
            for k in range(length//2):
                u = get_kth_vertex(i,j,k)
                v = get_kth_vertex(i,j,length - k -1)
                dsu.union(u,v)

label = [dsu.find(v) for v in range(N)]

# Проверяем, что для пар (i,j) с A[i][j]=1 путь палиндромен
for i in range(N):
    for j in range(i,N):
        if A[i][j] == 1:
            l = lca(i,j)
            length = depth[i] + depth[j] - 2*depth[l] + 1
            ok = True
            for k in range(length//2):
                u = get_kth_vertex(i,j,k)
                v = get_kth_vertex(i,j,length - k -1)
                if label[u] != label[v]:
                    print(10**100)
                    sys.exit(0)

# Подсчёт палиндромных пар (i,j)
res = 0
for i in range(N):
    for j in range(N):
        l = lca(i,j)
        length = depth[i] + depth[j] - 2*depth[l] + 1
        ok = True
        for k in range(length//2):
            u = get_kth_vertex(i,j,k)
            v = get_kth_vertex(i,j,length - k -1)
            if label[u] != label[v]:
                ok = False
                break
        if ok:
            res += 1

print(res)