import sys
import bisect

input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    A.sort()
    B.sort()

    # Для каждого B[i] нужно найти A[j], чтобы (A[j] + B[i]) % M минимизирует максимум.
    # Идея: бинарный поиск по ответу x - минимальное максимальное значение.
    # Проверка: можно ли переставить A так, чтобы для всех i (A[i] + B[i]) % M <= x?

    def can(x):
        # Для каждого B[i], нужно найти A[j] >= (M - B[i] + x + 1) % M, чтобы (A[j] + B[i]) % M <= x
        # Переформулируем:
        # (A[j] + B[i]) % M <= x
        # => A[j] <= x - B[i] mod M
        # Но так как A[j], B[i] < M, и мы хотим переставить A,
        # проще проверить, что для каждого B[i], существует A[j] >= (M - B[i]) % M, чтобы сумма не превышала x.
        # Но это сложно, проще сделать так:
        # Для каждого B[i], нужно найти A[j] >= (M - B[i]) % M, чтобы (A[j] + B[i]) % M <= x
        # Если A[j] < (M - B[i]) % M, то (A[j] + B[i]) % M < M, но может быть больше x.
        # Поэтому для каждого B[i], ищем минимальный A[j] >= (M - B[i]) % M, если такой есть и (A[j] + B[i]) % M <= x, берем его.
        # Иначе берем минимальный A[j], и проверяем (A[j] + B[i]) % M <= x.
        # Если ни один не подходит, return False.

        used = [False]*N
        # Чтобы эффективно проверять, используем отсортированный A и двоичный поиск.
        # Для каждого B[i], ищем позицию в A, где A[j] >= (M - B[i]) % M
        # Если такой элемент есть и (A[j] + B[i]) % M <= x, берем его.
        # Иначе берем минимальный A[j], проверяем (A[j] + B[i]) % M <= x.
        # Чтобы не усложнять, используем multiset (в Python - список + bisect + удаление)
        # Но удаление из списка O(N), слишком дорого.
        # Вместо этого используем двоичный поиск и помечаем использованные элементы.
        # Но это сложно.
        # Оптимальнее: для каждого B[i], ищем A[j] >= (M - B[i]) % M, если нет, берем минимальный A[j].
        # Чтобы быстро удалять элементы, используем двоичный поиск и массив флагов.
        # Но это сложно.
        # Вместо этого используем двоичный поиск и структуру данных - например, balanced tree.
        # Но в Python нет.
        # Решение: для каждого B[i], ищем позицию в A, где A[j] >= (M - B[i]) % M, если такой есть, берем его.
        # Иначе берем минимальный A[j].
        # Чтобы не удалять элементы, используем массив A и массив used, и для каждого B[i] ищем подходящий элемент.
        # Но это O(N^2).
        # Нужно оптимизировать.

        # Оптимальное решение:
        # Для каждого B[i], вычислим target = (M - B[i]) % M
        # Отсортируем B.
        # Отсортируем A.
        # Для каждого B[i], будем искать в A элемент >= target.
        # Чтобы быстро удалять использованные элементы, используем двоичный поиск и структуру данных.
        # В Python можно использовать bisect и список, но удаление дорого.
        # Вместо этого используем двоичный поиск и массив A, и для каждого B[i] будем искать подходящий элемент,
        # но будем использовать указатель на начало массива A, чтобы не использовать уже взятые элементы.
        # Но это не всегда работает.

        # Лучшее решение: для каждого B[i], вычислим needed = (M - B[i]) % M
        # Отсортируем A.
        # Для каждого B[i], будем искать в A элемент >= needed.
        # Если такой есть, возьмем его и удалим из A.
        # Иначе возьмем минимальный элемент из A.
        # Чтобы эффективно удалять элементы, используем двоичный поиск и структуру данных.
        # В Python можно использовать bisect.insort и bisect.bisect_left, но удаление из середины списка дорого.
        # Используем модуль bisect и массив A, и для удаления используем массив индексов.
        # Но это сложно.

        # Решение: используем модуль bisect и массив A, и для удаления используем массив boolean used.
        # Для каждого B[i], ищем позицию pos = bisect_left(A, needed)
        # Если pos == len(A), берем A[0]
        # Если A[pos] не использован, берем его
        # Иначе ищем следующий неиспользованный элемент после pos
        # Если нет, берем минимальный неиспользованный элемент
        # Но это O(N^2) в худшем случае.

        # Чтобы избежать этого, используем структуру данных multiset.
        # В Python можно использовать collections.Counter + heap, но это сложно.

        # Итог: для данной задачи оптимальное решение - использовать двоичный поиск по ответу и жадное сопоставление с помощью двоичного поиска и списка.

        # Реализация:
        # Для каждого B[i], вычислим needed = (M - B[i]) % M
        # Отсортируем A.
        # Для каждого B[i], ищем в A элемент >= needed с помощью bisect_left.
        # Если такой элемент есть и (A[j] + B[i]) % M <= x, берем его.
        # Иначе берем минимальный элемент A[0], если (A[0] + B[i]) % M <= x.
        # Если ни один не подходит, return False.

        # Чтобы не удалять элементы из списка, используем массив A и массив used.
        # Для каждого B[i], ищем подходящий элемент, если он не использован, берем его.
        # Если использован, ищем следующий подходящий.
        # Но это O(N^2).

        # Чтобы избежать O(N^2), используем двоичный поиск по ответу и жадное сопоставление с помощью структуры данных.
        # В Python можно использовать bisect и список, и для удаления использовать bisect.insort и pop.

        # Реализация с использованием списка и bisect:
        from bisect import bisect_left

    # Реализация с двоичным поиском по ответу и жадным сопоставлением с использованием multiset (sorted list)
    # Для каждого теста:

    # Двоичный поиск по ответу
    left, right = 0, M - 1
    res = M - 1

    from bisect import bisect_left

    while left <= right:
        mid = (left + right) // 2
        # Проверяем, можно ли переставить A так, чтобы max((A[i] + B[i]) % M) <= mid
        # Создаем копию A для поиска
        A_list = A[:]
        # Используем двоичный поиск и удаление из списка
        # Для удаления используем list и bisect, удаление O(N), но суммарно O(N log N) по всем тестам
        # так как сумма N <= 3*10^5, это приемлемо

        possible = True
        for b in B:
            needed = (M - b) % M
            pos = bisect_left(A_list, needed)
            if pos == len(A_list):
                pos = 0
            a_val = A_list[pos]
            if (a_val + b) % M > mid:
                possible = False
                break
            A_list.pop(pos)
        if possible:
            res = mid
            right = mid - 1
        else:
            left = mid + 1

    print(res)