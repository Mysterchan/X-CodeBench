def main():
    import sys
    sys.setrecursionlimit(10**7)
    input = sys.stdin.readline

    N, K = map(int, input().split())
    P = list(map(int, input().split()))

    # Pは1-basedの値が入っているが、indexは0-based
    # 目標はPを昇順にすること (1,2,...,N*K)
    # Aliceは最小操作回数でソートし、その中で|i-j|がNの倍数の交換を最大化する

    # 重要な観察:
    # インデックスを0-basedで考えると、|i-j|がNの倍数ということは、
    # i mod N == j mod N であることと同値。
    # つまり、同じ「列」に属する位置同士の交換はポイントがもらえる。

    # 配列をN列K行の行列とみなすと、
    # 各列は P[i], i mod N == c (0 <= c < N) の要素の集合。
    # それぞれの列内での交換はポイントがもらえる。

    # ソート後の配列は (1,2,...,N*K)
    # これをN列K行に分けると、列cには値 c+1, c+1+N, c+1+2N, ..., c+1+(K-1)*N が入る。

    # つまり、列cの正しい値集合は { c+1 + N*m | m=0..K-1 }

    # したがって、列cの要素は列cの正しい値集合に入るべきである。

    # もしPの列cに列cの正しい値集合以外の値が混じっていたら、
    # それは他の列の値であり、列間の交換が必要になる。

    # 交換は最小回数で行うため、まずは列ごとに正しい値を持つ要素を
    # できるだけその列内で並べ替え、残りは列間で交換する。

    # 具体的には、
    # 各列cについて、
    # - 現在の列cの要素を取り出す
    # - 目標の列cの要素集合を作る
    # - 現在の列cの要素と目標の列cの要素の間で置換を考える

    # 置換の最小交換回数は、要素数 - サイクル数

    # ここで、列内での交換はポイントがもらえる。
    # 列間での交換はポイントがもらえない。

    # したがって、
    # - 列内での置換に必要な交換回数はポイントがもらえる
    # - 列間での交換はポイントがもらえない

    # まず、PをN列K行の行列に分割し、各列の要素を取得
    # 目標の列の要素も取得

    # それぞれの列での置換の最小交換回数を計算し、
    # それがポイントになる。

    # しかし、列間の交換も必要な場合がある。
    # それは、列cに列cの要素以外が混じっている場合。

    # その場合、列間の交換が必要で、ポイントはもらえない。

    # だが問題文は「最小操作回数でソートし、その上でポイント最大化」なので、
    # 最小操作回数は全体の置換の最小交換回数。

    # 全体の置換の最小交換回数は
    # (N*K) - (全体の置換のサイクル数)

    # ここで、ポイントは列内の交換で得られる回数の合計。

    # つまり、全体の置換を分解して、
    # それぞれのサイクルがどの列に属しているかを考える。

    # しかし、サイクルが複数の列にまたがる場合は、
    # そのサイクルの交換は列間の交換を含むためポイントは得られない。

    # したがって、ポイントは「列内のサイクルの交換回数の合計」となる。

    # つまり、PをN列に分けて、それぞれの列の要素の置換を考え、
    # その列内の置換の最小交換回数をポイントとして合計する。

    # これが最大のポイントとなる。

    # 実装手順:
    # 1. Pの位置i(0-based)の値P[i]の正しい位置は P[i]-1
    # 2. iとP[i]-1の列番号は i%N と (P[i]-1)%N
    # 3. 列番号が違う場合は列間の交換が必要
    # 4. 列番号が同じ場合は列内の交換でポイントが得られる

    # したがって、列ごとに部分置換を作り、
    # その置換のサイクル数を数える

    # 置換の最小交換回数 = 要素数 - サイクル数
    # これがその列でのポイントになる

    # 全体の最小交換回数は (N*K) - (全体のサイクル数)
    # だがポイントは列内の交換回数の合計

    # なので、列ごとにサイクル数を数え、ポイントを計算

    # まず、列ごとに要素の位置と値を抽出し、
    # それらの値の正しい位置を列内でのインデックスに変換して置換を作る

    # 例:
    # 列cの要素は P[i] (i%N == c)
    # それらの値は c+1 + N*m (m=0..K-1)
    # それぞれの値の正しい列内インデックスは (P[i]-1)//N

    # 置換は、列内の現在の順序 -> 目標の順序

    # これで列内の置換を表現できる

    # サイクル数を数えてポイントを計算

    # 最後にポイントの合計を出力

    # 実装開始

    points = 0
    for c in range(N):
        # 列cの要素のインデックス
        indices = [i for i in range(c, N*K, N)]
        # 現在の列cの要素
        current = [P[i] for i in indices]
        # 目標の列cの要素は c+1 + N*m (m=0..K-1)
        # 目標の列内インデックスは 0..K-1
        # 現在の要素の目標位置は (value-1)//N
        # 現在の列内の順序は indicesの順序なので0..K-1

        # 置換を作る: 現在の列内の位置 -> 目標の列内の位置
        # つまり、pos -> (value-1)//N
        perm = [(val - 1) // N for val in current]

        visited = [False] * K
        cycle_count = 0
        for i in range(K):
            if not visited[i]:
                cycle_count += 1
                j = i
                while not visited[j]:
                    visited[j] = True
                    j = perm[j]
        # 最小交換回数 = K - cycle_count
        points += K - cycle_count

    print(points)


if __name__ == "__main__":
    main()