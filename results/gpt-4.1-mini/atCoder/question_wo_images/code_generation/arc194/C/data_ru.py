import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))

# Нам нужно сделать A равным B, меняя отдельные элементы A.
# Каждая операция: инвертируем A_i, затем платим сумму C_k для всех k с A_k=1 после инверсии.
# Нужно минимизировать суммарную стоимость.

# Анализ:
# Стоимость операции зависит от текущего состояния A после инверсии.
# При инверсии A_i меняется с 0 на 1 или с 1 на 0.
# После инверсии сумма стоимости равна sum C_k для всех k с A_k=1 (после инверсии).

# Задача: выбрать порядок инверсий для всех i, где A_i != B_i, чтобы минимизировать сумму стоимостей операций.

# Рассмотрим множество индексов, где A_i != B_i — их нужно инвертировать ровно один раз.
# Пусть S = {i | A_i != B_i}.

# При инверсии i-го элемента:
# - Если A_i=0 -> 1, то сумма стоимостей увеличится на C_i.
# - Если A_i=1 -> 0, то сумма стоимостей уменьшится на C_i.

# Начальное состояние: sumC = сумма C_i для всех i с A_i=1.

# При последовательных инверсиях элементов из S:
# - Если инвертируем элемент, который был 0, то sumC += C_i
# - Если инвертируем элемент, который был 1, то sumC -= C_i

# Нужно минимизировать сумму всех sumC после каждой операции.

# Оптимальная стратегия:
# - Сначала инвертируем все элементы, которые из 1 в 0 (т.е. A_i=1, B_i=0), чтобы уменьшить sumC как можно быстрее.
# - Затем инвертируем элементы, которые из 0 в 1 (A_i=0, B_i=1), чтобы sumC постепенно увеличивался.

# Почему?
# Потому что при инверсии 1->0 sumC уменьшается, и мы хотим делать эти операции раньше, чтобы платить меньшую сумму в последующих операциях.
# При инверсии 0->1 sumC увеличивается, и лучше делать их позже, чтобы платить меньше.

# Внутри каждой группы порядок инверсий по возрастанию C_i минимизирует сумму (платим меньше на больших sumC).

# Реализация:
# 1) Вычислить начальную сумму sumC = sum C_i для i с A_i=1.
# 2) Разделить индексы S на две группы:
#    - group1: A_i=1, B_i=0 (нужно инвертировать 1->0)
#    - group2: A_i=0, B_i=1 (нужно инвертировать 0->1)
# 3) Отсортировать group1 по возрастанию C_i и инвертировать их в этом порядке.
# 4) Отсортировать group2 по возрастанию C_i и инвертировать их в этом порядке.
# 5) При каждой инверсии обновлять sumC и накапливать стоимость.

sumC = 0
for i in range(N):
    if A[i] == 1:
        sumC += C[i]

group1 = []
group2 = []

for i in range(N):
    if A[i] != B[i]:
        if A[i] == 1 and B[i] == 0:
            group1.append(i)
        else:
            group2.append(i)

group1.sort(key=lambda x: C[x])
group2.sort(key=lambda x: C[x])

res = 0
# Инвертируем group1 (1->0)
for i in group1:
    sumC -= C[i]
    res += sumC

# Инвертируем group2 (0->1)
for i in group2:
    sumC += C[i]
    res += sumC

print(res)