MOD = 998244353

import sys
sys.setrecursionlimit(10**7)

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# Sは正しい括弧列である。

# 操作は、Sの連続部分文字列のうち正しい括弧列を選び、
# その部分文字列を「反転」すること。
# 反転とは、部分文字列を逆順にし、かつ '(' <-> ')' を入れ替える操作。

# 問題は、操作終了時にあり得るSの個数を求めること。

# 考察:
# 1. Sは正しい括弧列。
# 2. 操作は正しい括弧列の部分文字列を選び、その部分を反転する。
# 3. 反転は「逆順にして括弧を反転」なので、正しい括弧列は正しい括弧列に変わる。
# 4. 反転操作は可逆であり、同じ部分列を2回反転すれば元に戻る。

# 重要な点:
# - 反転操作は、正しい括弧列の部分文字列に対してのみ可能。
# - 反転操作は、部分文字列の「入れ替え」ではなく、反転変換。

# 例:
# (())() から ()(()) に変えられる。

# これらは、Sの構造を「正しい括弧列の連結」として捉え、
# それぞれの正しい括弧列の部分を反転操作で入れ替えられる可能性がある。

# さらに、反転操作は「正しい括弧列の部分文字列」を反転するので、
# 例えば、Sを「正しい括弧列の連結」として分解したとき、
# それらの部分列を反転操作で入れ替えたり、反転したりできる。

# しかし、反転操作は部分文字列単位なので、
# Sを「最小単位の正しい括弧列の連結」に分解し、
# それらの単位を反転操作で入れ替えられるかを考える。

# ここで「最小単位の正しい括弧列」とは、
# それ以上分割できない正しい括弧列（対応する括弧のペア単位）。

# 例えば、(())() は (()) と () の2つの最小単位に分解できる。

# 反転操作で、これらの単位を入れ替えたり、
# それぞれの単位を反転したりできる。

# つまり、操作で得られる文字列は、
# - 最小単位の正しい括弧列の順列（並べ替え）
# - 各単位は反転（逆順かつ括弧反転）されるかどうか

# したがって、
# 1. Sを最小単位の正しい括弧列に分解する。
# 2. それらの単位の順列と反転の組み合わせで得られる文字列の個数を数える。

# ただし、同じ単位が複数ある場合は区別しないといけない。

# しかし、反転操作は部分文字列単位なので、
# 連結した単位の順序を入れ替えることはできない。
# 反転操作は部分文字列の反転なので、
# 連結した単位の順序を入れ替えることはできない。

# 例を考えると、
# (())() から ()(()) に変えられる。

# (())() は (()) + ()
# ()(()) は () + (())

# つまり、単位の順序が入れ替わっている。

# これは、S全体を反転操作した結果である。

# つまり、反転操作で単位の順序を入れ替えられるのは、
# 反転操作の連続で可能。

# 反転操作は部分文字列の反転なので、
# 連結した単位の順序を入れ替えることはできないが、
# 反転操作を複数回行うことで、単位の順序を入れ替えられる。

# 例えば、S全体を反転すれば単位の順序は逆になる。

# さらに、部分文字列の反転操作を使って、
# 単位の順序を任意に入れ替えられるか？

# ここで、問題の操作は「正しい括弧列の部分文字列」を反転すること。

# つまり、正しい括弧列の部分文字列を反転することで、
# その部分の単位の順序を逆にできる。

# したがって、Sを最小単位の正しい括弧列に分解し、
# それらの単位の順序を任意に入れ替えられる。

# さらに、各単位は反転操作で反転できる。

# つまり、得られる文字列は、
# - 最小単位の正しい括弧列の順列
# - 各単位は反転するかしないか

# ただし、同じ単位が複数ある場合は区別しない。

# したがって、答えは
# (単位の個数)! × 2^(単位の個数)
# ただし、同じ単位が複数ある場合は重複を除くために
# 重複単位の階乗で割る必要がある。

# しかし、単位の反転が同じ単位になる場合は、
# 反転しても同じ単位なら反転の選択肢は1つ。

# つまり、単位ごとに
# - 反転しても同じなら反転の選択肢は1
# - 反転すると異なるなら反転の選択肢は2

# これを考慮して計算する。

# まとめ:
# 1. Sを最小単位の正しい括弧列に分解
# 2. 各単位について、反転したものと比較し同じか判定
# 3. 単位の種類ごとに個数を数える（反転を考慮した同一性）
# 4. 順列の重複を考慮して、(単位数)! / (各単位の重複数の階乗の積)
# 5. 反転の選択肢は、反転して異なる単位なら2、同じなら1を掛ける
# 6. これらを掛け合わせて答えを求める

# 実装方針:
# - Sを最小単位に分解するには、括弧の対応を利用
# - 対応する括弧のペアごとに区切る
# - 例えば、Sを左からスキャンし、対応する括弧の位置を記録
# - 対応する括弧のペアが単位の境界になる
# - 具体的には、スタックで括弧の対応を求め、
#   対応する括弧のペアの範囲を単位として抽出
# - ただし、単位は「最小単位の正しい括弧列」なので、
#   対応する括弧のペアの範囲が単位になる

# しかし、(()) は (()) という単位であり、
# これをさらに () + () に分解するのは間違い。

# つまり、単位は「対応する括弧のペアで囲まれた正しい括弧列」単位。

# したがって、Sを「対応する括弧のペアで囲まれた正しい括弧列」に分解する。

# 具体的には、Sを左からスキャンし、
# 対応する括弧のペアの範囲を記録し、
# その範囲が単位になる。

# しかし、(()) は1つの単位であり、
# ()() は2つの単位。

# つまり、Sを「対応する括弧のペアで囲まれた正しい括弧列」の連結に分解する。

# これを実現するには、
# スタックで括弧の対応を求め、
# 対応する括弧のペアの範囲を記録し、
# その範囲が単位になる。

# さらに、単位の境界は、
# 対応する括弧のペアの範囲が連続している部分。

# 例えば、(())() は
# - (()) の範囲 [0,3]
# - () の範囲 [4,5]

# これらが単位。

# 実装:
# - スタックで括弧の対応を求める
# - 対応する括弧のペアの範囲を記録
# - その範囲を単位として抽出

# 反転判定:
# - 単位の文字列とその反転（逆順かつ括弧反転）を比較
# - 同じなら反転選択肢は1、異なるなら2

# 同じ単位の重複は、
# 反転を考慮した単位の正規形（単位とその反転のうち辞書順で小さい方）で管理

# これで重複をまとめる。

# 最後に、
# 答え = (単位数)! / (各単位の重複数の階乗の積) * Π(反転選択肢)

# 階乗はMODで計算。

# 実装開始。

# 反転関数
def invert_brackets(t):
    # 逆順にして括弧を反転
    return ''.join('(' if c == ')' else ')' for c in reversed(t))

# 階乗と逆元の事前計算
max_n = N
fact = [1] * (max_n + 1)
inv_fact = [1] * (max_n + 1)
for i in range(2, max_n + 1):
    fact[i] = fact[i-1] * i % MOD

def modinv(x):
    return pow(x, MOD-2, MOD)

inv_fact[max_n] = modinv(fact[max_n])
for i in reversed(range(max_n)):
    inv_fact[i] = inv_fact[i+1] * (i+1) % MOD

def comb(n, r):
    if r > n or r < 0:
        return 0
    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD

# 括弧の対応を求める
stack = []
pair = [-1] * N
for i, c in enumerate(S):
    if c == '(':
        stack.append(i)
    else:
        j = stack.pop()
        pair[i] = j
        pair[j] = i

# Sを最小単位の正しい括弧列に分解
units = []
i = 0
while i < N:
    j = pair[i]
    if i < j:
        units.append(S[i:j+1])
        i = j + 1
    else:
        # i > j の場合は閉じ括弧から始まることはないはず
        i += 1

# 反転選択肢の計算と単位の正規化
from collections import Counter

def normalize_unit(u):
    inv = invert_brackets(u)
    return min(u, inv)

unit_counter = Counter()
flip_choices = []

for u in units:
    inv = invert_brackets(u)
    if u == inv:
        # 反転しても同じ
        flip_choices.append(1)
    else:
        flip_choices.append(2)
    norm = normalize_unit(u)
    unit_counter[norm] += 1

# 順列の重複を考慮して計算
m = len(units)
ans = fact[m]
for v in unit_counter.values():
    ans = ans * inv_fact[v] % MOD

# 反転選択肢を掛ける
for f in flip_choices:
    ans = ans * f % MOD

print(ans % MOD)