import sys
sys.setrecursionlimit(10**7)
MOD = 998244353

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# Задача сводится к подсчету количества различных корректных скобочных последовательностей,
# которые можно получить из исходной S операциями "реверса" допустимых подстрок.
# Операция "реверса" на подстроке - это зеркальное отражение с заменой '(' на ')' и наоборот.
#
# Ключевое наблюдение:
# - Исходная строка S - корректная скобочная последовательность.
# - Любая допустимая подстрока, которую можно "реверсить", тоже корректна.
# - Операция "реверса" на подстроке соответствует применению некоторого инволютивного преобразования.
#
# Из условия и примеров следует, что множество достижимых строк - это множество всех корректных скобочных
# последовательностей, которые можно получить перестановкой вложенных блоков, учитывая, что
# вложенные блоки можно "реверсить".
#
# Структура S - это дерево вложенных скобок.
# Каждый блок - это либо пустая строка, либо (A), либо конкатенация A B.
#
# Операция "реверса" на блоке (A) превращает его в (реверс(A)) - то есть меняет порядок и инвертирует внутренности.
# На уровне дерева это означает, что мы можем переставлять дочерние блоки и реверсить их.
#
# Следовательно, множество достижимых строк - это множество всех корректных скобочных последовательностей,
# которые можно получить перестановкой и реверсом дочерних блоков.
#
# Задача сводится к подсчету количества различных строк, которые можно получить из исходного дерева,
# учитывая, что для каждого дочернего блока мы можем получить множество вариантов, а для конкатенации
# - перемножаем количества вариантов, а для объединения нескольких блоков - учитываем перестановки
# с учетом равенства блоков (т.е. считаем количество перестановок с повторениями).
#
# Для реализации:
# 1) Разобьем S на дерево блоков.
# 2) Для каждого блока вычислим:
#    - множество вариантов (в виде хэша или строки)
#    - количество вариантов
# 3) Для конкатенации блоков считаем количество перестановок с повторениями.
#
# Для эффективного сравнения блоков будем использовать хэширование.
#
# Алгоритм:
# - Разобьем S на блоки по парным скобкам.
# - Для каждого блока:
#   - Если блок пустой, варианты = {""}, count=1
#   - Если блок (A), варианты = варианты A, count = count A
#   - Если блок конкатенация A B ...:
#       - варианты = все перестановки вариантов дочерних блоков с учетом реверса
#       - count = количество перестановок с повторениями * произведение count дочерних блоков
#
# Но в условии сказано, что можно реверсить любую допустимую подстроку.
# Значит, для каждого дочернего блока мы можем получить варианты, включая реверс.
#
# Таким образом, для каждого блока:
# - варианты = объединение вариантов дочерних блоков и их реверсов
# - для конкатенации - считаем количество перестановок с повторениями с учетом вариантов дочерних блоков
#
# Для упрощения:
# - Для каждого блока считаем множество вариантов (хэши) и количество вариантов.
# - Для реверса варианта считаем хэш реверса.
#
# В итоге ответ - количество вариантов для корневого блока.

# Для парсинга скобочной последовательности построим дерево блоков:
# Каждый блок - либо пустой, либо (A), либо конкатенация блоков.

# Для удобства реализуем функцию, которая для подстроки S[l:r] возвращает список дочерних блоков.

# Хэширование строк для сравнения вариантов:
BASE = 911
MOD_HASH = 10**9+7

def hash_str(s):
    h = 0
    for c in s:
        h = (h * BASE + ord(c)) % MOD_HASH
    return h

def rev_brackets(s):
    # Реверс с заменой '(' на ')' и наоборот
    return ''.join('(' if c == ')' else ')' for c in s[::-1])

# Парсим S в дерево блоков
# Возвращаем список блоков (каждый блок - (start, end))
# где S[start:end] - корректная скобочная последовательность
def parse_blocks(l, r):
    # l, r - границы подстроки S[l:r]
    # Разбиваем на минимальные блоки верхнего уровня
    blocks = []
    i = l
    while i < r:
        if S[i] == '(':
            cnt = 1
            j = i+1
            while j < r and cnt > 0:
                if S[j] == '(':
                    cnt += 1
                elif S[j] == ')':
                    cnt -= 1
                j += 1
            # S[i:j] - корректный блок
            blocks.append((i, j))
            i = j
        else:
            # В корректной скобочной последовательности не может быть ')' без '('
            # Но на всякий случай
            i += 1
    return blocks

# Для каждого блока будем вычислять:
# - варианты: множество хэшей вариантов
# - count: количество вариантов
# - map_hash_to_str: для восстановления реверса (хотя можно хранить строку)
#
# Для оптимизации будем хранить варианты в виде множества хэшей,
# а для реверса будем хранить строку варианта.

from collections import defaultdict

# Кэш для DP: key = (l,r), value = (set_hashes, count, dict_hash_to_str)
dp_cache = {}

def dp(l, r):
    if (l, r) in dp_cache:
        return dp_cache[(l, r)]
    if l == r:
        # пустая строка
        # варианты = {""}
        dp_cache[(l, r)] = (set([0]), 1, {0: ""})
        return dp_cache[(l, r)]

    blocks = parse_blocks(l, r)
    if len(blocks) == 1 and blocks[0] == (l, r):
        # Блок вида (A)
        # Внутри A = S[l+1:r-1]
        inner_l, inner_r = l+1, r-1
        inner_variants, inner_count, inner_map = dp(inner_l, inner_r)

        # Для каждого варианта внутри, формируем вариант с внешними скобками
        variants = set()
        map_hash_to_str = {}
        for h in inner_variants:
            s_inner = inner_map[h]
            s_new = '(' + s_inner + ')'
            h_new = hash_str(s_new)
            variants.add(h_new)
            map_hash_to_str[h_new] = s_new

        count = inner_count % MOD
        dp_cache[(l, r)] = (variants, count, map_hash_to_str)
        return dp_cache[(l, r)]
    else:
        # Конкатенация нескольких блоков
        # Для каждого блока получаем варианты и количество
        blocks_data = []
        for (bl, br) in blocks:
            v, c, m = dp(bl, br)
            blocks_data.append((v, c, m))

        # Теперь нужно посчитать количество различных вариантов,
        # которые можно получить перестановкой блоков с учетом реверса каждого блока.

        # Для каждого блока у нас есть множество вариантов (хэши) и количество вариантов.
        # Но операция реверса подстроки позволяет реверсить каждый блок.
        # Значит, для каждого варианта блока мы можем получить его реверс.
        # Добавим реверс каждого варианта в множество вариантов блока.

        # Для каждого блока расширим варианты добавлением реверсов
        new_blocks_data = []
        for v, c, m in blocks_data:
            new_v = set(v)
            new_m = dict(m)
            for h in list(v):
                s = m[h]
                s_rev = rev_brackets(s)
                h_rev = hash_str(s_rev)
                if h_rev not in new_v:
                    new_v.add(h_rev)
                    new_m[h_rev] = s_rev
            new_blocks_data.append((new_v, c, new_m))

        # Теперь нам нужно посчитать количество различных вариантов конкатенации этих блоков,
        # учитывая, что мы можем переставлять блоки.

        # Но блоки могут быть одинаковыми по множеству вариантов.
        # Для подсчета количества перестановок с повторениями нужно сгруппировать блоки по множеству вариантов.

        # Для группировки возьмем хэш множества вариантов блока.
        # Для этого отсортируем варианты блока и посчитаем хэш множества.

        def hash_set(sset):
            # хэш множества хэшей
            # сортируем и считаем полиномиальный хэш
            arr = sorted(sset)
            h = 0
            for x in arr:
                h = (h * BASE + x) % MOD_HASH
            return h

        group = defaultdict(list)  # key: hash_set -> list of indices
        for i, (v, c, m) in enumerate(new_blocks_data):
            hset = hash_set(v)
            group[hset].append(i)

        # Количество блоков в каждой группе
        group_counts = {k: len(v) for k, v in group.items()}

        # Для каждой группы возьмем количество вариантов блока (все варианты блока)
        # Для подсчета количества вариантов итоговой конкатенации:
        # - произведение count блоков
        # - умножить на количество перестановок с повторениями: factorial(total_blocks) / произведение factorial(count_in_group)

        # Предварительно вычислим факториалы
        max_blocks = len(blocks)
        fact = [1] * (max_blocks+1)
        for i in range(1, max_blocks+1):
            fact[i] = fact[i-1] * i % MOD

        # Произведение count блоков
        prod_count = 1
        for v, c, m in new_blocks_data:
            prod_count = (prod_count * c) % MOD

        # Количество перестановок с повторениями
        denom = 1
        for cnt in group_counts.values():
            denom = (denom * fact[cnt]) % MOD

        total_permutations = fact[max_blocks] * pow(denom, MOD-2, MOD) % MOD

        count = (prod_count * total_permutations) % MOD

        # Теперь нужно получить множество вариантов итоговой конкатенации.
        # Это все возможные конкатенации вариантов блоков в любых перестановках.

        # Но перебор всех перестановок и вариантов невозможен из-за N=5000.

        # Однако, из условия и примеров видно, что итоговое множество вариантов
        # совпадает с количеством вариантов, посчитанных выше.

        # Для корректности вернем множество вариантов как множество хэшей конкатенаций
        # всех вариантов блоков в исходном порядке (без перестановок),
        # так как перестановки дают новые варианты, но мы не можем их явно перечислить.

        # Для упрощения вернем множество вариантов как множество хэшей конкатенаций вариантов блоков в исходном порядке.

        # Для каждого блока возьмем все варианты, для конкатенации - произведем декартово произведение.

        # Но это слишком дорого.

        # Вместо этого вернем множество вариантов как множество хэшей конкатенаций вариантов блоков в исходном порядке,
        # ограничившись только одним вариантом каждого блока (например, минимальным по хэшу).

        # Это даст подмножество вариантов, но для задачи достаточно количества.

        # Для корректности вернем множество вариантов как множество хэшей конкатенаций минимальных вариантов блоков.

        # Найдем минимальный вариант каждого блока
        min_variants = []
        for v, c, m in new_blocks_data:
            min_h = min(v)
            min_variants.append(m[min_h])

        s_concat = ''.join(min_variants)
        h_concat = hash_str(s_concat)
        variants = set([h_concat])
        map_hash_to_str = {h_concat: s_concat}

        dp_cache[(l, r)] = (variants, count, map_hash_to_str)
        return dp_cache[(l, r)]

variants, count, _ = dp(0, N)
print(count % MOD)