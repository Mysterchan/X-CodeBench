MOD = 998244353

import sys
sys.setrecursionlimit(10**7)

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# The problem is about counting the number of distinct valid parenthesis sequences
# obtainable by repeatedly reversing valid substrings (with the special reversal operation).

# Key insight:
# The operation allows reversing any valid substring, where reversing means:
# - Reverse the substring order
# - Flip each parenthesis: '(' <-> ')'
#
# This operation is an involution on valid substrings.
#
# The problem reduces to counting how many distinct valid sequences can be formed
# by applying these operations any number of times.

# Let's analyze the structure of the problem:

# 1) The input S is a valid parenthesis sequence.
# 2) The operation can be applied to any valid substring.
# 3) The operation is an involution on that substring.
# 4) We want to find the number of distinct sequences reachable.

# Observations:
# - The problem is related to the structure of the valid parentheses.
# - The operation can reorder the concatenation of valid substrings by reversing them.
# - The problem states that a valid sequence is either:
#   - empty
#   - (A)
#   - AB (concatenation of two valid sequences A and B)
#
# The operation can reverse any valid substring, which can be:
# - a single primitive block (like (A))
# - a concatenation of blocks

# The reversal operation on a substring that is a concatenation of valid sequences
# reverses the order of those sequences and flips each one.

# This suggests that the reachable sequences correspond to all sequences obtained by
# rearranging the "primitive" blocks in S by reversing them.

# Let's define "primitive blocks":
# A primitive valid parentheses sequence is one that cannot be split into two non-empty valid sequences.
# For example:
# - () is primitive
# - (()) is primitive
# - ()() is not primitive (it's concatenation of two primitives)

# So, we can decompose S into primitive blocks:
# S = P1 P2 ... Pk, where each Pi is primitive.

# The operation allows reversing any substring of S that is valid.
# If we reverse a substring that covers multiple primitives, it reverses their order and flips each primitive.

# Since flipping a primitive block is also a primitive block (because flipping preserves validity),
# the operation can reorder the primitives by reversing substrings.

# The problem reduces to:
# - We have a sequence of primitive blocks P1, P2, ..., Pk.
# - We can reverse any contiguous subsequence of these primitives, flipping each primitive in that subsequence.
# - We want to count the number of distinct sequences of primitives reachable by these operations.

# Note:
# Flipping a primitive block is an involution on that block.
# So each primitive block can be flipped or not.

# The operation on a substring of primitives:
# - Reverse the order of the primitives in that substring
# - Flip each primitive in that substring

# This is a group action on the sequence of primitives.

# The problem is known in combinatorics as counting the number of distinct sequences reachable
# by applying these "flip-reverse" operations on substrings.

# Let's define dp[l][r] = number of distinct sequences obtainable from the substring of primitives from l to r.

# Base case:
# dp[i][i] = 1 (only the primitive itself)

# For dp[l][r], we can split into two parts:
# dp[l][r] = sum over m in [l, r-1] of dp[l][m] * dp[m+1][r]

# But we also have the operation of reversing the whole substring [l, r]:
# which flips and reverses the substring.

# Because flipping is an involution, and the operation can be applied any number of times,
# the reachable sequences correspond to the sequences generated by concatenation and flipping/reversing.

# The problem is equivalent to counting the number of distinct sequences of primitives modulo the equivalence
# generated by the flip-reverse operation on substrings.

# However, the problem is complex, but the editorial approach (from known similar problems) is:

# We can use a DP with memoization and hashing to count distinct sequences.

# Approach:
# 1) Decompose S into primitive blocks.
# 2) For each primitive block, compute its "canonical form" and its flipped form.
# 3) Use DP to count distinct sequences from l to r:
#    - Either concatenate two sequences (dp[l][m] * dp[m+1][r])
#    - Or reverse the whole substring (which flips and reverses the primitives)
# 4) Use memoization with hashing to avoid duplicates.

# But since N can be up to 5000, and number of primitives can be large,
# we need a more efficient approach.

# Alternative approach:
# The problem is known to be solved by DP counting the number of distinct sequences
# of primitives modulo the flip-reverse operation.

# The key is that the operation allows us to reorder the primitives in a way that
# the reachable sequences correspond to the sequences generated by the free involution
# on the primitives.

# The number of distinct sequences is equal to the number of distinct sequences of primitives
# modulo the equivalence generated by the flip-reverse operation.

# The problem reduces to counting the number of distinct sequences of primitives modulo
# the equivalence generated by the flip-reverse operation.

# The solution is to:
# - Decompose S into primitives.
# - For each primitive, compute its canonical form and flipped form.
# - Use DP to count the number of distinct sequences from l to r.

# We can implement a DP with memoization and hashing of sequences.

# Let's implement the decomposition into primitives first.

def decompose_primitives(s):
    stack = []
    primitives = []
    start = 0
    for i, c in enumerate(s):
        if c == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                primitives.append(s[start:i+1])
                start = i+1
    return primitives

primitives = decompose_primitives(S)
k = len(primitives)

# Precompute flipped primitives
def flip(p):
    return ''.join('(' if c == ')' else ')' for c in reversed(p))

flipped = [flip(p) for p in primitives]

# We want to count the number of distinct sequences obtainable from primitives[l:r+1]
# by applying the operations.

# We will use memoization with a dictionary keyed by (l, r).

# To represent sequences uniquely, we will store their canonical forms.

# The canonical form of a sequence is the lexicographically smallest sequence
# between the sequence itself and the sequence obtained by reversing and flipping all primitives.

# For a sequence of primitives P[l..r], the reversed-flipped sequence is:
# flip(reverse(P[l..r])) = flip(P[r]) + flip(P[r-1]) + ... + flip(P[l])

# We define a function to get the canonical form of a sequence of primitives.

def canonical(seq):
    # seq is a list of strings (primitives)
    rev_flip = [flip(p) for p in reversed(seq)]
    if seq < rev_flip:
        return tuple(seq)
    else:
        return tuple(rev_flip)

from functools import lru_cache

@lru_cache(None)
def dp(l, r):
    if l == r:
        # Only one primitive, only one sequence
        return {canonical((primitives[l],))}
    res = set()
    # Split into two parts
    for m in range(l, r):
        left_seqs = dp(l, m)
        right_seqs = dp(m+1, r)
        for ls in left_seqs:
            for rs in right_seqs:
                combined = canonical(ls + rs)
                res.add(combined)
    # Also consider reversing the whole substring [l, r]
    # which flips and reverses the primitives
    # But since canonical form considers both seq and reversed-flipped seq,
    # this is already accounted for.
    return res

result = dp(0, k-1)
print(len(result) % MOD)