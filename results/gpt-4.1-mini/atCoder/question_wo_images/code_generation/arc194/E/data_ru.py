import sys
input = sys.stdin.readline

N, X, Y = map(int, input().split())
S = input().strip()
T = input().strip()

# Если S == T, ответ Да
if S == T:
    print("Yes")
    sys.exit()

# Если X == Y, операции A и B просто меняют местами блоки длины X и Y,
# но при X == Y это сводится к перестановке одинаковых по длине блоков.
# В этом случае можно менять только определённые паттерны.
# Но проще рассмотреть общий случай.

# Рассмотрим, что операции A и B меняют местами блоки 0^X 1^Y и 1^Y 0^X
# на позициях i..i+X+Y-1.

# Важно: операции меняют только строго определённые паттерны.
# Значит, мы можем рассматривать строку как последовательность блоков 0 и 1.

# Разобьём S и T на блоки (символ, длина)
def run_length_encoding(s):
    res = []
    prev = s[0]
    cnt = 1
    for c in s[1:]:
        if c == prev:
            cnt += 1
        else:
            res.append((prev, cnt))
            prev = c
            cnt = 1
    res.append((prev, cnt))
    return res

S_blocks = run_length_encoding(S)
T_blocks = run_length_encoding(T)

# Если количество блоков не совпадает, ответ Нет
if len(S_blocks) != len(T_blocks):
    print("No")
    sys.exit()

# Проверим, что символы блоков совпадают по порядку
for (sc, _), (tc, _) in zip(S_blocks, T_blocks):
    if sc != tc:
        print("No")
        sys.exit()

# Теперь у нас есть последовательность блоков с одинаковыми символами,
# нужно понять, можно ли преобразовать длины блоков S в длины блоков T
# с помощью операций A и B.

# Операции A и B меняют местами соседние блоки 0^X 1^Y <-> 1^Y 0^X
# в пределах одной подстроки длины X+Y.

# Значит, мы можем менять длины соседних блоков, если они соответствуют
# паттерну (0-block length X, 1-block length Y) или (1-block length Y, 0-block length X),
# меняя их местами.

# Но в общем случае, операции позволяют менять длины блоков, но с ограничениями.

# Рассмотрим пары блоков подряд: (S_blocks[i], S_blocks[i+1]) и (T_blocks[i], T_blocks[i+1])
# Если символы блоков чередуются (0,1), то операция A или B может менять длины блоков,
# но только если длины соответствуют X и Y.

# Однако, операции меняют только строго X и Y длины блоков, а блоки могут быть длиннее.

# Значит, если длины блоков в S и T не совпадают, но можно получить T из S,
# то длины блоков должны быть связаны с операциями.

# Но операции меняют только блоки длины X и Y, меняя их местами.

# Следовательно, длины блоков, которые не равны X или Y, не могут быть изменены.

# Проверим для каждого блока:
# Если длина блока в S != длина блока в T, то:
# - Если длина блока равна X или Y, возможно, она поменялась местами с соседним блоком.
# - Иначе, преобразование невозможно.

# Но это слишком сложный путь.

# Попробуем другой подход.

# Рассмотрим, что операции A и B меняют подстроку длины X+Y,
# меняя местами блоки 0^X 1^Y и 1^Y 0^X.

# Значит, операции позволяют менять местами блоки длины X и Y,
# но только если они идут подряд и соответствуют паттерну.

# Таким образом, операции позволяют переставлять блоки длины X и Y,
# но не изменять длины блоков.

# Значит, длины блоков в S и T должны совпадать по множеству,
# но порядок блоков может отличаться.

# Проверим, что длины блоков в S и T совпадают по множеству,
# и что блоки можно получить перестановкой блоков длины X и Y.

# Но блоки могут быть разной длины, не обязательно X или Y.

# В условии операции применимы только к подстрокам с блоками длины X и Y.

# Значит, блоки длины не равной X или Y не могут быть изменены.

# Следовательно, если в S и T есть блоки длины не равной X или Y,
# и длины этих блоков не совпадают, ответ Нет.

# Проверим для каждого блока:
for (sc, slen), (tc, tlen) in zip(S_blocks, T_blocks):
    if slen != tlen:
        # Если длина блока не равна X или Y, преобразование невозможно
        if slen != X and slen != Y:
            print("No")
            sys.exit()
        if tlen != X and tlen != Y:
            print("No")
            sys.exit()

# Теперь проверим, что количество блоков с длиной X и Y совпадает в S и T
from collections import Counter

def count_blocks(blocks):
    cX = 0
    cY = 0
    cOther = 0
    for ch, length in blocks:
        if length == X:
            cX += 1
        elif length == Y:
            cY += 1
        else:
            cOther += 1
    return cX, cY, cOther

cX_S, cY_S, cOther_S = count_blocks(S_blocks)
cX_T, cY_T, cOther_T = count_blocks(T_blocks)

if cOther_S != cOther_T:
    print("No")
    sys.exit()
if cX_S != cX_T or cY_S != cY_T:
    print("No")
    sys.exit()

# Теперь проверим, что можно получить T из S перестановкой блоков длины X и Y,
# используя операции A и B.

# Операции A и B позволяют менять местами соседние блоки длины X и Y,
# если они идут в паттерне 0^X 1^Y или 1^Y 0^X.

# Значит, мы можем рассматривать последовательность блоков как последовательность символов,
# где каждый блок длины X или Y обозначен как 'X' или 'Y' с символом 0 или 1.

# Но операции меняют местами только пары блоков (0^X,1^Y) <-> (1^Y,0^X).

# Значит, мы можем менять местами соседние блоки длины X и Y,
# если они идут в паттерне (0,X)-(1,Y) или (1,Y)-(0,X).

# Таким образом, операции позволяют переставлять блоки длины X и Y,
# но только меняя местами соседние блоки с разными символами.

# Значит, мы можем рассматривать последовательность блоков длины X и Y
# как последовательность символов '0' и '1', и операции позволяют менять местами
# соседние блоки с разными символами.

# Это эквивалентно сортировке последовательности символов с помощью обмена соседних элементов,
# если они различны.

# Таким образом, можно получить T из S, если последовательность символов блоков длины X и Y
# можно преобразовать в последовательность символов блоков длины X и Y в T,
# используя операции обмена соседних элементов с разными символами.

# Проверим, что последовательности символов блоков длины X и Y в S и T совпадают по мультимножеству.

# Соберём последовательности символов блоков длины X или Y в S и T:
seq_S = []
seq_T = []
for (ch, length) in S_blocks:
    if length == X or length == Y:
        seq_S.append(ch)
for (ch, length) in T_blocks:
    if length == X or length == Y:
        seq_T.append(ch)

if Counter(seq_S) != Counter(seq_T):
    print("No")
    sys.exit()

# Теперь проверим, можно ли переставить seq_S в seq_T, используя операции обмена соседних элементов,
# если они различны.

# Это возможно, если и только если seq_S и seq_T имеют одинаковое количество символов,
# и для каждого символа количество в seq_S и seq_T совпадает (что мы проверили),
# и при этом нет ограничений на перестановку.

# Но операции позволяют менять местами только соседние элементы с разными символами,
# что эквивалентно возможности переставлять символы с помощью транспозиций соседних элементов,
# если они различны.

# Это означает, что перестановка seq_S в seq_T возможна, если и только если
# seq_S и seq_T имеют одинаковое количество символов каждого типа.

# Таким образом, ответ Да.

print("Yes")