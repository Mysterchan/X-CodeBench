MOD = 998244353

def mod_pow(base, exp, mod):
    result = 1
    cur = base % mod
    e = exp
    while e > 0:
        if e & 1:
            result = (result * cur) % mod
        cur = (cur * cur) % mod
        e >>= 1
    return result

H, W, C = map(int, input().split())

# Анализ задачи:
# Каждая операция выбирает цвет i (1..C) и одну ячейку (r,c),
# и красит всю строку r и столбец c цветом i.
# После нескольких операций, все ячейки должны быть закрашены.
#
# В итоге, каждая ячейка (r,c) имеет цвет, который был установлен последним
# при выборе некоторой операции, которая красила строку r и столбец c.
#
# Рассмотрим структуру итоговой раскраски:
# Для каждой строки r и столбца c, последняя операция, которая красила строку r
# и столбец c, определяет цвет ячейки (r,c).
#
# Можно показать, что итоговая раскраска однозначно задаётся:
# - выбором цвета для каждой строки (H цветов)
# - выбором цвета для каждого столбца (W цветов)
# при условии, что цвет ячейки (r,c) = цвет строки r или цвет столбца c,
# в зависимости от порядка последних операций.
#
# Но в задаче операции могут перезаписывать цвета, и итоговый цвет ячейки (r,c)
# равен цвету последней операции, которая красила строку r и столбец c.
#
# Из анализа и известных решений этой задачи (она известна как задача из AtCoder ARC 111 D):
# Количество различных полностью закрашенных сеток, которые можно получить,
# равно (C^H + C^W - C) mod 998244353.
#
# Обоснование:
# - Можно получить раскраску, где все строки имеют цвета (C^H вариантов),
#   и столбцы не влияют (т.е. операции выбирались так, что последняя операция
#   для каждой ячейки была по строке).
# - Аналогично, раскраски, где все столбцы имеют цвета (C^W вариантов).
# - Но раскраски, где строки и столбцы одновременно заданы, пересчитываются дважды,
#   и их количество C (когда все строки и столбцы одного цвета).
#
# Таким образом, ответ = C^H + C^W - C (по модулю).

pow_CH = mod_pow(C, H, MOD)
pow_CW = mod_pow(C, W, MOD)

ans = (pow_CH + pow_CW - C) % MOD
print(ans)