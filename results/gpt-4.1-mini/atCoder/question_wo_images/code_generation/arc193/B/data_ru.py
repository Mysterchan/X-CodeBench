import sys
sys.setrecursionlimit(10**7)
MOD = 998244353

def main():
    input = sys.stdin.readline
    N = int(input())
    s = input().strip()

    # Граф G:
    # Вершины: 0..N
    # Рёбра:
    # - Цикл длины N: ребра между i и (i+1)%N, всего N рёбер
    # - Рёбра между i и N, если s_i == '1', всего M = sum(s_i) таких рёбер

    # Нужно посчитать количество различных входных степеней (d_0,...,d_N),
    # которые можно получить, ориентируя каждое ребро в одну из двух сторон.

    # Анализ:
    # - Цикл из N вершин: N рёбер, каждое ребро можно направить в одну из двух сторон.
    #   Входные степени вершин 0..N-1 от цикла подчиняются условию:
    #   Для цикла длины N, входные степени вершин (d_0,...,d_{N-1}) удовлетворяют:
    #   d_i + d_{i+1} = 1 для всех i (индексы по модулю N),
    #   т.к. каждое ребро направлено либо в i, либо в i+1.
    #   Следовательно, сумма входных степеней по циклу равна N/2 * 1 = N/2, но N может быть нечетным.
    #   Но на самом деле, для цикла длины N, входные степени вершин 0..N-1 образуют последовательность из 0 и 1,
    #   где для каждого ребра ровно одна вершина получает +1 входящую степень.
    #   Входные степени по циклу - это последовательность из 0 и 1, где сумма равна N.
    #   Но это не так, т.к. каждое ребро даёт 1 входящую степень одной из двух вершин.
    #   В итоге сумма входных степеней по циклу равна N (число рёбер).
    #   Но так как каждое ребро даёт 1 входящую степень, сумма d_i по циклу равна N.
    #   Но d_i может быть 0,1 или 2, если вершина участвует в дополнительных рёбрах.

    # - Рёбра к вершине N: для каждого i с s_i=1 есть ребро {i,N}.
    #   Это ребро можно направить либо i->N (тогда d_N +=1), либо N->i (тогда d_i +=1).

    # Входные степени:
    # Для i=0..N-1:
    #   d_i = входящая степень от цикла + входящая степень от ребер к N
    # Для i=N:
    #   d_N = количество ребер, направленных в N (из ребер к N)

    # Цикл:
    # Для цикла из N вершин, входные степени d_0..d_{N-1} удовлетворяют:
    # Для каждого ребра {i,(i+1)%N} ровно одна из вершин получает +1 входящую степень.
    # Значит, для цикла входные степени - это последовательность из 0 и 1, где сумма равна N (число рёбер).
    # Но это невозможно, т.к. сумма d_i по циклу равна N, а d_i может быть 0,1 или 2 (если есть ребра к N).
    # Но от цикла каждая вершина может получить 0 или 1 входящую степень (т.к. каждое ребро даёт 1 входящую степень одной из двух вершин).
    # Значит, входные степени от цикла - это последовательность из 0 и 1, где сумма равна N (число рёбер).
    # Но сумма из 0 и 1 длины N не может быть N, максимум N.
    # Значит, входные степени от цикла - это последовательность из 0 и 1 длины N, сумма равна N (т.е. все 1).
    # Но это невозможно, т.к. для цикла сумма входных степеней равна числу рёбер = N.
    # Значит, входные степени от цикла - это последовательность из 0 и 1 длины N, сумма равна N.
    # Это возможно только если все d_i=1.
    # Но это противоречит условию, т.к. ребро не может быть направлено в обе вершины одновременно.

    # Ошибка в рассуждении: для цикла из N вершин и N рёбер,
    # сумма входных степеней равна числу рёбер = N.
    # Каждое ребро даёт 1 входящую степень одной из двух вершин.
    # Значит, сумма d_i по циклу равна N.
    # Но d_i может быть 0,1 или 2 (если есть ребра к N).
    # От цикла каждая вершина получает либо 0 либо 1 входящую степень (т.к. ребро либо направлено в неё, либо нет).
    # Значит, входные степени от цикла - это последовательность из 0 и 1 длины N, сумма равна N.
    # Значит, все d_i=1.
    # Но это невозможно, т.к. ребро не может быть направлено в обе вершины одновременно.

    # Значит, входные степени от цикла - это последовательность из 0 и 1 длины N, сумма равна N.
    # Но это невозможно, значит ошибка в рассуждении.

    # Правильное рассуждение:
    # Для цикла из N вершин и N рёбер, каждое ребро {i,(i+1)%N} направлено либо i->(i+1) либо (i+1)->i.
    # Значит, для каждой вершины i входящая степень от цикла равна количеству рёбер, направленных в i.
    # Каждая вершина i участвует ровно в двух рёбрах цикла: {i,(i+1)%N} и {(i-1)%N,i}.
    # Входящая степень от цикла для i может быть 0,1 или 2.
    # Но так как каждое ребро направлено в одну из двух вершин, сумма входных степеней по циклу равна N (число рёбер).
    # Входные степени от цикла - это последовательность (d_0,...,d_{N-1}), где d_i ∈ {0,1,2}, и сумма d_i = N.
    # Более того, для каждой вершины i:
    # d_i = (ребро {(i-1)%N,i} направлено в i ? 1 : 0) + (ребро {i,(i+1)%N} направлено в i ? 1 : 0)
    # Значит, входные степени от цикла - это сумма двух последовательностей из {0,1} длины N:
    # - для ребра {(i-1)%N,i} - 1 если ребро направлено в i, 0 иначе
    # - для ребра {i,(i+1)%N} - 1 если ребро направлено в i, 0 иначе
    # Но ребро {i,(i+1)%N} не может быть направлено в обе вершины одновременно.

    # Таким образом, входные степени от цикла - это последовательность, где для каждого ребра ровно одна из двух вершин получает +1.
    # Значит, входные степени от цикла - это последовательность из чисел 0,1,2, где сумма равна N,
    # и для каждой пары соседних вершин i и (i+1)%N сумма d_i + d_{i+1} = 1 или 2?
    # Нет, сумма d_i + d_{i+1} = 1 + 1 = 2, если ребра направлены так, что обе вершины получают по 1 входящей степени.
    # Но это невозможно, т.к. ребро одно.

    # Переформулируем:
    # Для ребра {i,(i+1)%N} ровно одна из вершин i или (i+1)%N получает +1 входящую степень.
    # Значит, для каждой пары соседних вершин сумма входных степеней от этого ребра равна 1.
    # Но каждая вершина участвует в двух рёбрах цикла, значит:
    # d_i + d_{i+1} = 1 для всех i (по модулю N).
    # Это ключевое уравнение.

    # Решение уравнения d_i + d_{i+1} = 1 (mod N):
    # Возможны только две последовательности:
    # - d_i = 0,1,0,1,... (чередование)
    # - d_i = 1,0,1,0,... (чередование)
    # Т.к. N≥3, и цикл, эти две последовательности единственные решения.

    # Значит, входные степени от цикла - это либо (0,1,0,1,...) либо (1,0,1,0,...).

    # Теперь добавим ребра к вершине N:
    # Для каждого i с s_i=1 есть ребро {i,N}, которое можно направить либо i->N (тогда d_N +=1),
    # либо N->i (тогда d_i +=1).

    # Итого:
    # d_i = d_i_cycle + x_i, где x_i ∈ {0,1} - 1 если ребро {i,N} направлено в i, 0 если в N.
    # d_N = sum over i of (1 - x_i) = M - sum x_i, где M = количество единиц в s.

    # Мы хотим посчитать количество различных последовательностей (d_0,...,d_N),
    # которые можно получить, выбирая:
    # - одну из двух последовательностей d_i_cycle (две варианты)
    # - для каждого ребра к N - направление (x_i = 0 или 1)

    # Значит, количество вариантов:
    # 2 (выбор d_i_cycle) * 2^M (выбор направлений ребер к N)

    # Но нужно проверить, что разные выборы дают разные последовательности (d_0,...,d_N).

    # Проверка различия:
    # - Разные d_i_cycle дают разные d_i для i=0..N-1 (чередование 0,1 и 1,0)
    # - Для фиксированного d_i_cycle, разные выборы x_i дают разные d_i, т.к. d_i = d_i_cycle + x_i
    # - d_N = M - sum x_i, зависит от суммы x_i
    # Значит, разные x_i дают разные d_i, т.к. d_i для i=0..N-1 меняются, и d_N меняется.

    # Следовательно, ответ = 2 * 2^M = 2^{M+1} mod 998244353

    M = s.count('1')
    ans = pow(2, M + 1, MOD)
    print(ans)

if __name__ == "__main__":
    main()