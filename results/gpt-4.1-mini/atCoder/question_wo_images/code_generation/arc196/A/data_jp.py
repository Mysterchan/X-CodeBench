import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# Nは偶数か奇数かで処理が変わるが、問題文の操作は
# 隣接ペアを選んで削除し続けるので、最終的に数列の長さは1以下になる。
# つまり、Nが偶数なら全てペアにできる。奇数なら最後に1つ残る。

# この問題は、隣接ペアを選んで削除し、その差の絶対値の合計を最大化する問題。
# 操作の順序で隣接関係が変わるため、単純に隣接ペアの差の最大値を取るだけではない。

# 重要なポイント:
# 操作後に残った数列は、削除したペアの間の数が詰まって隣接になる。
# つまり、削除したペアの選び方は、元の数列の要素を「連続したペアのマッチング」に対応する。

# この問題は「数列の隣接ペアを選んで削除し、最大の差の合計を得る」という問題で、
# 最終的に数列の長さが1以下になるまで繰り返す。
# これは「数列の要素を隣接ペアでマッチングし、その差の絶対値の合計を最大化する問題」と同値。

# つまり、数列の要素を隣接ペアで分割し、ペアの差の絶対値の和を最大化する問題。

# ここで、数列の長さNは最大3*10^5なのでO(N)かO(N log N)の解法が必要。

# DPで解く:
# dp[i] := i番目までの要素で最大のスコア
# dp[0] = 0 (要素0個でスコア0)
# dp[1] = 0 (要素1個でペアなし)
# dp[i] = max(dp[i-1], dp[i-2] + |A[i-1] - A[i-2]|) (1-based indexで考えると)
# つまり、i番目の要素をペアにするかしないかの選択。

# ただし、問題の操作は「隣接ペアを選んで削除」なので、
# ペアは必ず隣接している必要がある。
# dp[i]はi番目までの要素で最大スコアを表す。

# これで正しいか検証:
# - dp[i-1]はi番目の要素をペアにしない（残す）場合
# - dp[i-2] + |A[i-1] - A[i-2]|はi-1番目とi番目をペアにして削除する場合

# 最終的にdp[N]が答え。

# ただし、Nが奇数の場合、最後に1つ残るのでペアにできない要素がある。
# dpの定義はそれを考慮している。

dp = [0] * (N + 1)
for i in range(2, N + 1):
    dp[i] = max(dp[i-1], dp[i-2] + abs(A[i-1] - A[i-2]))

print(dp[N])