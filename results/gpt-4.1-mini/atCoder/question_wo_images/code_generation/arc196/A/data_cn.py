import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# 观察题意：
# 每次操作移除两个相邻元素，得分为它们的差的绝对值。
# 最终序列长度至多为1，意味着要将元素两两配对，且配对的元素必须是相邻的（操作时相邻）。
# 由于每次移除后，剩余元素会重新相邻，实际上是要将序列划分成若干对，每对是原序列中相邻的元素经过若干次移除后相邻的。
# 这相当于在原序列中选择一组边（相邻元素对），使得这些边构成一个匹配（每个元素最多被匹配一次），
# 并且匹配的边必须是相邻的元素对，求匹配边权和最大。
#
# 这就是一个线性链上的最大权匹配问题。
# 经典DP：
# dp[i] 表示考虑前 i 个元素，能获得的最大分数。
# 状态转移：
# dp[0] = 0
# dp[1] = 0 (只有一个元素，不能配对)
# 对于 i >= 2:
# dp[i] = max(dp[i-1], dp[i-2] + abs(A[i-1] - A[i-2]))
#
# 其中 dp[i-1] 表示第 i 个元素不参与配对，
# dp[i-2] + abs(...) 表示第 i-1 和第 i 个元素配对。
#
# 最终答案为 dp[N]

dp = [0]*(N+1)
for i in range(2, N+1):
    dp[i] = max(dp[i-1], dp[i-2] + abs(A[i-1] - A[i-2]))

print(dp[N])