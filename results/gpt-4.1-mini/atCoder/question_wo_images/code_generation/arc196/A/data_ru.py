import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# Если N нечетно, последний элемент останется без пары, 
# так что максим пар будет N//2
# Задача: разбить последовательность на пары соседних элементов,
# удаляя их последовательно, чтобы максимизировать сумму |A_i - A_j|.

# Ключевая идея:
# При удалении пары соседних элементов, оставшиеся элементы сдвигаются,
# и соседства меняются.
# Это сложная динамическая задача.

# Рассмотрим динамическое программирование:
# dp[l][r] - максимальный результат для подотрезка A[l..r]
# при условии, что длина подотрезка четна (иначе 0)
# Мы можем удалить пару (l, l+1) и затем решить для (l+2, r)
# или удалить пару (r-1, r) и решить для (l, r-2)
# или разбить на две части (l, k) и (k+1, r), где длина каждой части четна.

# Но dp[l][r] с N=3*10^5 невозможен по памяти и времени.

# Попробуем упростить:
# Можно заметить, что порядок удаления пар не влияет на итоговый результат,
# если мы можем разбить последовательность на пары соседних элементов,
# не нарушая порядок.

# Тогда задача сводится к разбиению последовательности на пары соседних элементов,
# чтобы сумма |A_i - A_j| была максимальна.

# Это классическая задача о максимальном паросочетании на пути,
# где пары - это ребра между соседними вершинами.

# Для пути с весами ребер w_i = |A_i - A_{i+1}|,
# нужно выбрать набор ребер без общих вершин, максимизирующий сумму весов.

# Это задача о максимальном паросочетании на пути,
# решается динамикой за O(N):

# dp[i] - максимальная сумма для первых i элементов
# dp[0] = 0
# dp[1] = 0 (один элемент нельзя спарить)
# Для i >= 2:
# dp[i] = max(dp[i-1], dp[i-2] + |A[i-2] - A[i-1]|)

# Ответ dp[N]

dp = [0]*(N+1)
for i in range(2, N+1):
    dp[i] = max(dp[i-1], dp[i-2] + abs(A[i-2] - A[i-1]))

print(dp[N])