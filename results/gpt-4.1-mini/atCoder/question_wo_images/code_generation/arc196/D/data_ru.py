import sys
input = sys.stdin.readline

N, M, Q = map(int, input().split())
people = [tuple(map(int, input().split())) for _ in range(M)]
queries = [tuple(map(int, input().split())) for _ in range(Q)]

# Анализ задачи:

# Города расположены на линии: 1 - 2 - 3 - ... - N
# Дороги: j соединяет j и j+1, j=1..N-1
# Для каждой дороги j можно задать силу w_j (целое, может быть отрицательным).
# При переходе по дороге j выносливость меняется на +w_j.

# Для каждого человека i:
# - стартовая выносливость в S_i = 0
# - конечная выносливость в T_i = 0
# - на всех промежуточных городах выносливость > 0
# - путь кратчайший (линия, значит путь по соседним городам от S_i до T_i)
# - |S_i - T_i| > 1
# - пары (S_i, T_i) уникальны

# Требуется для запросов (L_k, R_k) проверить, можно ли задать w_j так,
# чтобы требования людей с номерами от L_k до R_k выполнялись одновременно.

# Ключевые наблюдения:

# Пусть человек i идет от S_i к T_i по пути:
# Если S_i < T_i, то путь: S_i -> S_i+1 -> ... -> T_i
# Если S_i > T_i, то путь: S_i -> S_i-1 -> ... -> T_i

# Обозначим d_i = T_i - S_i (не равно 0, |d_i| > 1)

# Выносливость в городах на пути:
# x_{S_i} = 0
# x_{S_i+1} = w_{edge(S_i)} + x_{S_i} = w_{edge(S_i)}
# x_{S_i+2} = w_{edge(S_i)} + w_{edge(S_i+1)}
# ...
# x_{T_i} = сумма w_j по пути = 0

# Требование: 
# - сумма w_j по пути = 0
# - все промежуточные суммы (выносливость в промежуточных городах) > 0

# Значит, для пути длины L = |d_i|, частичные суммы w_j по пути (кроме полной суммы) положительны,
# а полная сумма равна 0.

# Это условие означает, что последовательность w_j на пути i является "позитивной цепочкой" с суммой 0,
# то есть частичные суммы строго положительны, а сумма равна 0.

# Известно, что такая последовательность существует, если и только если длина пути >= 2 (у нас |d_i| > 1, условие выполнено).

# Но теперь надо проверить совместимость требований нескольких людей.

# Рассмотрим ребра (дороги) на линии: 1..N-1

# Для каждого человека i, его путь - это от S_i к T_i, то есть набор дорог:
# если S_i < T_i: дороги S_i, S_i+1, ..., T_i-1
# если S_i > T_i: дороги T_i, T_i+1, ..., S_i-1 (в обратном направлении)

# Требование для каждого человека i:
# - сумма w_j по его пути = 0
# - частичные суммы > 0

# Важное: w_j - переменные, одна на каждую дорогу.

# Условие суммы w_j по пути i = 0 - линейное уравнение.

# Условие частичных сумм > 0 - неравенства.

# Задача: для набора людей проверить, существует ли набор w_j, удовлетворяющий всем уравнениям и неравенствам.

# Ключевое упрощение:

# Рассмотрим только уравнения суммы w_j по пути i = 0.

# Если для набора людей уравнения несовместимы, ответ "No".

# Если уравнения совместимы, надо проверить, можно ли подобрать w_j так, чтобы частичные суммы > 0.

# Из анализа задачи и примеров, конфликт возникает, если пути "перекрываются" и накладывают противоречивые условия.

# В частности, если два пути пересекаются и накладывают противоречивые требования на w_j.

# Но в условии гарантируется, что пары (S_i, T_i) уникальны.

# Важное наблюдение из решения задачи на соревнованиях:

# Для каждого человека i можно определить интервал [l_i, r_i] - упорядоченный так, что l_i < r_i.

# Пусть l_i = min(S_i, T_i), r_i = max(S_i, T_i)

# Тогда путь i - это дороги с номерами от l_i до r_i - 1.

# Требование: сумма w_j по дорогам [l_i..r_i-1] = 0, частичные суммы > 0.

# Теперь рассмотрим запросы (L_k, R_k) - набор людей с номерами от L_k до R_k.

# Для этого набора людей надо проверить, можно ли одновременно удовлетворить их требования.

# Из анализа и примеров задачи известно, что конфликт возникает, если среди выбранных людей есть два пути, которые "перекрываются" и "пересекаются" в определенном смысле.

# Формально, если для двух людей i < j из выбранного набора интервалы [l_i, r_i] и [l_j, r_j] пересекаются, но не вложены друг в друга, то ответ "No".

# Иначе "Yes".

# То есть, для выбранного набора людей интервалов [l_i, r_i] надо проверить, что они образуют цепочку вложенных интервалов.

# Если в выбранном наборе интервалов есть два пересекающихся, но не вложенных друг в друга интервала, ответ "No".

# Задача сводится к проверке для каждого запроса, что интервалы [l_i, r_i] для i в [L_k, R_k] не содержат "перекрывающихся" неполностью вложенных пар.

# Как эффективно отвечать на Q запросов?

# Подход:

# 1) Для каждого человека i вычислим l_i = min(S_i, T_i), r_i = max(S_i, T_i)

# 2) Отсортируем людей по i (уже по порядку)

# 3) Для каждого i определим "конфликт" с предыдущими интервалами.

# 4) Построим структуру, которая для префикса [1..i] хранит максимальный индекс j < i, такой что интервал i конфликтует с j.

# 5) Тогда для запроса [L,R] ответ "Yes" если max_conflict_in_[L,R] < L, иначе "No".

# Реализация:

# - Для каждого i найдем максимальный j < i, с которым i конфликтует.

# - Конфликт возникает, если интервалы [l_i, r_i] и [l_j, r_j] пересекаются, но не вложены.

# Проверка конфликта двух интервалов [l_i, r_i], [l_j, r_j]:

# Пересекаются, если max(l_i, l_j) <= min(r_i, r_j)

# Не вложены, если не ( [l_i, r_i] ⊆ [l_j, r_j] или [l_j, r_j] ⊆ [l_i, r_i] )

# То есть, конфликт если:

# max(l_i, l_j) <= min(r_i, r_j) и не ( (l_i >= l_j and r_i <= r_j) or (l_j >= l_i and r_j <= r_i) )

# Для упрощения, так как i < j, можно обрабатывать интервалы в порядке i и поддерживать структуру для поиска конфликтов.

# Оптимизация:

# Отсортируем людей по l_i (началу интервала).

# При обработке i-го интервала будем искать среди предыдущих интервалов те, которые пересекаются, но не вложены.

# Можно использовать стек для проверки вложенности интервалов.

# Алгоритм:

# - Отсортируем людей по l_i, сохраняя индекс i.

# - Идем по отсортированным интервалам, поддерживаем стек с интервалами, вложенными друг в друга.

# - Для текущего интервала проверяем конфликт с верхом стека.

# - Если конфликт, запоминаем индекс конфликта.

# - Если нет, обновляем стек.

# После этого для каждого i будет известен max_conflict[i] - максимальный индекс j < i, с которым есть конфликт.

# Далее построим префиксный максимум max_conflict_prefix[i] = max(max_conflict_prefix[i-1], max_conflict[i])

# Для запроса [L,R]:

# Если max_conflict_prefix[R] < L => "Yes", иначе "No"

# Осталось сопоставить индексы после сортировки с исходными.

# Реализация:

# 1) Считаем l_i, r_i для каждого i.

# 2) Создаем массив people_intervals = [(l_i, r_i, i)] и сортируем по l_i.

# 3) Для каждого i в отсортированном порядке:

#    - Пока стек не пуст и r_i >= r_top, pop (поддерживаем вложенность)

#    - Если стек не пуст, проверяем конфликт с верхом стека.

#      Если конфликт, max_conflict[i] = max_conflict[top] или top

#    - Добавляем текущий интервал в стек

# 4) max_conflict[i] для i в отсортированном порядке

# 5) Переносим max_conflict в исходный порядок по i

# 6) Строим префиксный максимум max_conflict_prefix

# 7) Отвечаем на запросы.

# Внимание: индексы i в max_conflict - это индексы в отсортированном массиве, надо сопоставить с исходными.

# Для удобства создадим mapping: orig_i -> pos_in_sorted и обратно.

# Реализация кода ниже.


people_intervals = []
for i, (S, T) in enumerate(people, 1):
    l = min(S, T)
    r = max(S, T)
    people_intervals.append((l, r, i))

# Сортируем по l
people_intervals.sort(key=lambda x: (x[0], x[1]))

pos_in_sorted = [0]*(M+1)  # pos_in_sorted[orig_i] = position in sorted array (1-based)
orig_index = [0]*(M+1)     # orig_index[pos] = orig_i

for pos, (_, _, orig_i) in enumerate(people_intervals, 1):
    pos_in_sorted[orig_i] = pos
    orig_index[pos] = orig_i

max_conflict = [0]*(M+1)  # max_conflict[pos] = max conflicting index < pos, 0 if none

stack = []  # стек хранит (r, pos)

def conflict(a_l, a_r, b_l, b_r):
    # Проверка конфликта интервалов [a_l,a_r], [b_l,b_r]
    # Конфликт если пересекаются, но не вложены
    if max(a_l, b_l) <= min(a_r, b_r):
        # Проверяем вложенность
        if (a_l >= b_l and a_r <= b_r) or (b_l >= a_l and b_r <= a_r):
            return False
        return True
    return False

for pos in range(1, M+1):
    l_i, r_i, orig_i = people_intervals[pos-1]
    # Удаляем из стека интервалы с r <= r_i, чтобы поддерживать вложенность
    while stack and stack[-1][0] <= r_i:
        stack.pop()
    # Проверяем конфликт с верхом стека
    if stack:
        r_top, pos_top = stack[-1]
        l_top, r_top_orig, orig_top = people_intervals[pos_top-1]
        # Проверяем конфликт между текущим и верхом стека
        if conflict(l_i, r_i, l_top, r_top_orig):
            max_conflict[pos] = max(max_conflict[pos], pos_top)
    # Добавляем текущий интервал в стек
    stack.append((r_i, pos))

# max_conflict[pos] - индекс в отсортированном массиве

# Построим префиксный максимум max_conflict_prefix
max_conflict_prefix = [0]*(M+1)
for i in range(1, M+1):
    max_conflict_prefix[i] = max(max_conflict_prefix[i-1], max_conflict[i])

# Теперь для запроса [L,R] (в исходных индексах) надо проверить:
# max_conflict_prefix[pos_in_sorted[R]] < pos_in_sorted[L]

# Но L и R - исходные индексы, надо перевести в позиции в отсортированном массиве

# Важно: L и R могут быть в любом порядке, но в условии L <= R

# Для корректной проверки надо найти миним и максим позиции в отсортированном массиве для индексов [L..R]

# Но индексы i идут по возрастанию, и запросы по i тоже возрастают.

# Однако pos_in_sorted не гарантирует упорядоченность по i.

# Поэтому для каждого запроса:

# - Найдем минимую позицию posL = min(pos_in_sorted[L..R])

# - Найдем максимую позицию posR = max(pos_in_sorted[L..R])

# Проверим max_conflict_prefix[posR] < posL

# Если да, "Yes", иначе "No"

# Для быстрого ответа на Q запросов:

# Построим массив pos_in_sorted по i=1..M

# Построим Fenwick или Sparse Table для поиска min и max pos_in_sorted в диапазоне [L,R]

# Но Q и M до 2*10^5, можно построить Sparse Table для min и max.

# Построим два Sparse Table: для min и max pos_in_sorted по i

import math

LOG = (M+1).bit_length()
st_min = [[0]*(M+1) for _ in range(LOG)]
st_max = [[0]*(M+1) for _ in range(LOG)]

for i in range(1, M+1):
    st_min[0][i] = pos_in_sorted[i]
    st_max[0][i] = pos_in_sorted[i]

for k in range(1, LOG):
    length = 1 << k
    half = length >> 1
    for i in range(1, M - length + 2):
        st_min[k][i] = min(st_min[k-1][i], st_min[k-1][i+half])
        st_max[k][i] = max(st_max[k-1][i], st_max[k-1][i+half])

def query_min(l, r):
    length = r - l + 1
    k = length.bit_length() - 1
    return min(st_min[k][l], st_min[k][r - (1 << k) + 1])

def query_max(l, r):
    length = r - l + 1
    k = length.bit_length() - 1
    return max(st_max[k][l], st_max[k][r - (1 << k) + 1])

output = []
for L, R in queries:
    posL = query_min(L, R)
    posR = query_max(L, R)
    if max_conflict_prefix[posR] < posL:
        output.append("Yes")
    else:
        output.append("No")

print("\n".join(output))