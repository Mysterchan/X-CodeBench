import sys
input = sys.stdin.readline

N, M, Q = map(int, input().split())
ST = [tuple(map(int, input().split())) for _ in range(M)]
LR = [tuple(map(int, input().split())) for _ in range(Q)]

# 各人 i の区間 [l_i, r_i] は道の区間を表す
# 道 j は町 j と j+1 を結ぶ
# 人 i は町 S_i から T_i へ最短経路で行く
# 最短経路は町の直線上の区間 [min(S_i,T_i), max(S_i,T_i)]
# 道の区間は [min(S_i,T_i), max(S_i,T_i)-1]

intervals = []
for i, (s, t) in enumerate(ST):
    l = min(s, t)
    r = max(s, t) - 1
    intervals.append((l, r, i+1))  # i+1は人番号（1-based）

# 問題の条件を整理すると：
# 体力の変化は道の強さの和で決まる
# 人 i の体力は出発地で0、到着地で0
# 途中の町では体力は正の整数
# これは道の強さ w_j の和が区間 [l_i, r_i] で
# 途中の部分和がすべて正で、区間全体の和は0であることを意味する
#
# つまり、区間 [l_i, r_i] の部分和列は
# 0で始まり0で終わり、途中は正である
#
# これは「区間の和が0で、部分和が正」という条件
#
# これを満たす区間同士の関係を考えると、
# ある区間が他の区間と重なっている場合、
# それらの条件を同時に満たすことができるかどうかを判定する必要がある
#
# 重要な性質：
# 2つの区間が交差（重なり合い）している場合、
# それらの条件を同時に満たすことはできない
#
# つまり、区間同士が交差しているとNo
# 交差していなければYes
#
# 交差の定義：
# 2つの区間 [l1,r1], [l2,r2] が交差するとは
# l1 < l2 <= r1 < r2 または l2 < l1 <= r2 < r1 のこと
#
# これを利用して、区間の交差を判定し、
# クエリで与えられた区間の集合が交差を含むかどうかを判定する

# まず、区間を人番号順に並べているので、
# 人 i の区間は intervals[i-1]

# 交差を判定するために、
# 区間を左端でソートし、右端の最大値を管理しながら
# 交差があるかどうかを判定する

# しかしクエリは区間の連続区間 [L_k, R_k] に対して判定する
# つまり、区間の交差が区間 [L_k, R_k] 内に存在するかどうかを判定したい

# 交差がある区間のペアを見つけて、
# それらの交差がどの区間にまたがっているかを記録し、
# クエリで区間内に交差が含まれているかを高速に判定する

# 具体的には、
# 交差がある区間のペア (i,j) があれば、
# その区間の最小と最大の人番号を記録し、
# 交差区間の範囲をマークする

# 交差区間の範囲をマークし、
# それを累積和で管理して、
# クエリ区間に交差区間が含まれているかを判定する

# 交差判定のために区間を左端でソートし、
# 右端の最大値を管理しながら交差を検出

intervals_with_index = [(l, r, i) for i, (l, r, _) in enumerate(intervals, 1)]
# iは人番号（1-based）

# 左端でソート
intervals_with_index.sort(key=lambda x: (x[0], x[1]))

# 交差区間の範囲を記録する配列
# 交差がある区間の人番号の範囲を記録し、
# それを区間としてマークする
cross_ranges = []

# 右端の最大値を管理しながら交差を検出
import bisect

# 右端の値を管理するために、
# 現在までの区間の右端を保持し、
# 新しい区間の左端が既存区間の右端より小さい場合交差がある

# しかし単純に最大右端だけでは交差判定は不十分
# 交差判定は以下の条件
# 2つの区間 [l1,r1], [l2,r2] が交差するとは
# l1 < l2 <= r1 < r2 または l2 < l1 <= r2 < r1

# これを判定するために、
# すでに処理した区間の右端を管理し、
# 新しい区間と交差するか判定する

# 交差判定のために区間を左端順に処理し、
# 右端の値を管理するデータ構造を用いる

# ここでは区間を左端順に処理し、
# 右端の値を昇順に管理するリストを用意し、
# 新しい区間の左端が既存区間の右端より小さいかどうかで交差判定

# しかし交差判定は単純な重なり判定ではないため、
# 交差判定を全ての区間ペアで行うのは計算量的に厳しい

# そこで区間の交差は「区間の順序と右端の大小関係」で判定できる
# 具体的には、区間を左端でソートしたとき、
# 右端の値が単調増加していれば交差はない
# 右端の値が減少する箇所があれば交差がある

# つまり、区間を左端でソートしたとき、
# 右端の最大値を更新しながら、
# 右端が最大値より小さい区間があれば交差がある

# 交差がある区間の人番号の範囲を記録し、
# それを区間としてマークする

max_r = -1
cross_intervals = []  # (start, end) 人番号の区間

# intervals_with_index は (l, r, i) で左端昇順ソート済み
# iは人番号（1-based）

# 人番号は intervals_with_index の順番とは異なるので注意
# ここで i は人番号なので、交差区間の範囲は i の範囲で記録する

# 交差があったら、その2区間の人番号のmin,maxを記録

# 交差判定のために、右端の最大値を管理し、
# 右端が最大値より小さい区間があれば交差

# 交差があった区間の人番号の範囲を記録するために、
# 交差した2区間の人番号を記録

# 右端の最大値とその区間の人番号を記録
max_r = -1
max_r_i = -1

# 交差区間の人番号の範囲を記録するリスト
cross_pairs = []

for l, r, i in intervals_with_index:
    if r < max_r:
        # 交差あり
        # 交差区間の人番号の範囲は [min(i, max_r_i), max(i, max_r_i)]
        start = min(i, max_r_i)
        end = max(i, max_r_i)
        cross_pairs.append((start, end))
    else:
        max_r = r
        max_r_i = i

# 交差区間の範囲をマージして管理する
# 交差区間が複数ある場合、それらを区間としてマークし、
# クエリ区間に交差区間が含まれているかを判定する

# cross_pairs は交差区間の人番号の区間のリスト
# これらをマージして重複をなくす

cross_pairs.sort()
merged = []
for s, e in cross_pairs:
    if not merged or merged[-1][1] < s:
        merged.append([s, e])
    else:
        merged[-1][1] = max(merged[-1][1], e)

# merged は交差区間の人番号の区間のリスト（非重複、昇順）

# クエリは [L_k, R_k] の区間で、
# この区間が merged のいずれかの交差区間と重なっていれば No
# 重なっていなければ Yes

# 重なり判定は二分探索で高速に行う

import bisect

# merged の区間の開始点だけのリスト
starts = [x[0] for x in merged]

for L, R in LR:
    # merged の区間のうち、開始点が R 以上の最小の区間を探す
    idx = bisect.bisect_right(starts, R)
    # idx-1 の区間が [s,e] であれば、
    # その区間が L <= e なら重なりあり
    # そうでなければ重なりなし

    ans = "Yes"
    if idx > 0:
        s, e = merged[idx-1]
        if e >= L:
            ans = "No"
    print(ans)