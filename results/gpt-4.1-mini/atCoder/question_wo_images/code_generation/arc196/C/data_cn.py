import sys
sys.setrecursionlimit(10**7)
MOD = 998244353

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# 題意中有 2N 個頂點，S 長度為 2N
# 頂點 1..2N，邊 i->i+1 (共 2N-1 條)
# 將頂點分成 N 對，每對由一個 W 和一個 B 組成，並加邊 W->B
# 求使最終圖強連通的配對數 mod 998244353

# 強連通的條件分析：
# 原本的邊是線性鏈 1->2->3->...->2N
# 加上每對 (W,B) 的邊 W->B
# 要強連通，必須能從任意點到任意點
# 因為原本只有單向鏈，必須靠新增的 W->B 邊形成反向路徑
# 這意味著新增的 W->B 邊必須形成一個環，使得整個圖強連通

# 觀察：
# 1. 頂點序列中 W 和 B 各 N 個
# 2. 配對是將 W 頂點和 B 頂點一一配對
# 3. 新增邊是從 W 指向 B
# 4. 原本邊是 i->i+1
# 5. 要強連通，新增的 W->B 邊必須形成一個環，且與原本鏈結合成強連通圖

# 重要結論（來自題解與經典類似問題）：
# 將頂點按序列排列，將 W 視為 '('，B 視為 ')'
# 配對 W 和 B 使得新增邊形成的圖強連通，等價於在序列中找到一個合法的括號序列配對方式
# 且新增邊形成的匹配必須是「非交叉」的括號匹配（Catalan 結構）
# 因為只有非交叉匹配才能保證強連通

# 因此問題轉化為：
# 對序列 S，將 W 視為 '('，B 視為 ')'
# 計算有多少種合法的括號匹配方式，使得每個 '(' 對應一個 ')'，且匹配方式符合序列中 W 和 B 的位置
# 這是典型的「帶限制的括號匹配計數」問題

# 解法：
# 使用單調棧或DP計算合法括號匹配數量
# 但此處 W 和 B 位置固定，且 W 和 B 數量相等
# 我們用DP計算從左到右的合法匹配數量

# 定義 dp[i] 表示前 i 個字元的合法匹配數量
# 但因為括號匹配需要考慮子區間，我們用堆疊模擬匹配過程
# 這裡用一個類似Catalan數的DP，利用單調棧計算

# 實作：
# 使用一個棧，棧中存放未匹配的 W 頂點的索引
# 遍歷 S：
#   如果是 W，入棧
#   如果是 B，嘗試從棧頂彈出一個 W，並計算該匹配區間的配對數量
#   利用乘法累積結果

# 具體做法：
# 使用一個陣列 ways，ways[i] 表示以 i 為結尾的子區間的配對數量
# 但為了效率，我們用一個棧，每當遇到 B，彈出 W，計算該區間的配對數量
# 並將結果合併到上一層

# 參考類似題目解法：
# https://atcoder.jp/contests/arc111/tasks/arc111_c
# https://codeforces.com/blog/entry/68953

stack = []
res = 1

for i, c in enumerate(S):
    if c == 'W':
        # W 入棧，初始配對數為1
        stack.append(1)
    else:
        # B 出現，必須和棧頂的 W 配對
        if not stack:
            # 無法匹配，配對數為0
            res = 0
            break
        x = stack.pop()
        # 配對後，該區間配對數量乘以 x
        # 並且加上1表示該配對本身
        # 但實際上是 x * ways_of_inner + ways_of_inner
        # 這裡因為每個配對是獨立的，乘法即可
        # 但要注意多層結構，將結果與上一層合併
        val = (x * 2) % MOD
        if stack:
            # 與上一層合併
            top = stack.pop()
            top = (top * val) % MOD
            stack.append(top)
        else:
            # 最外層，乘入結果
            res = (res * val) % MOD

# 若棧不空，表示有未匹配的 W，配對數為0
if stack:
    res = 0

print(res % MOD)