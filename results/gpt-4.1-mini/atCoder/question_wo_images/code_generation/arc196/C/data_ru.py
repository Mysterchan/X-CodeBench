import sys
sys.setrecursionlimit(10**7)
MOD = 998244353

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# Вершины: 1..2N
# Рёбра: i -> i+1 для i=1..2N-1
# Добавим N рёбер от белой вершины к черной в каждой паре (W->B)

# Нужно посчитать количество разбиений на пары (W,B), чтобы итоговый граф был сильно связным.

# Анализ задачи:

# 1) Изначально граф - цепочка из 2N вершин с рёбрами i->i+1.
# 2) Добавляем N рёбер от W к B, по одному на пару.
# 3) Нужно, чтобы итоговый граф был сильно связным.

# Связность:
# - Изначально граф - ориентированная цепочка, не сильно связный.
# - Чтобы сделать его сильно связным, нужно добавить рёбра, которые "замкнут" путь назад.
# - Рёбра от W к B должны обеспечить обратные пути.

# Ключевое наблюдение:
# - Чтобы граф был сильно связным, для каждой вершины должен существовать путь к любой другой.
# - В частности, должен быть путь назад от вершины 2N к 1.
# - Изначально есть путь только вперед (i->i+1).
# - Обратные пути обеспечиваются рёбрами W->B.

# Рассмотрим порядок вершин и цвета:
# - Вершины идут по порядку 1..2N.
# - Каждую пару (W,B) мы добавляем ребро W->B.
# - Чтобы получить обратный путь, ребро W->B должно идти "назад" по индексу, т.е. W > B.
# - Иначе, если W < B, ребро W->B идёт вперёд, не давая обратного пути.

# Следовательно, чтобы получить сильную связность, пары должны быть такими, что в каждой паре W > B.

# Теперь задача сводится к подсчёту количества парных разбиений множества вершин на пары (W,B),
# где для каждой пары индекс W > индекс B.

# Но в условии сказано, что пары состоят из одной белой и одной черной вершины.

# Значит, мы должны сопоставить белые вершины с черными так, чтобы для каждой пары индекс белой вершины > индекс черной вершины.

# Аналогично, можно рассмотреть обратный случай, если мы хотим, чтобы граф был сильно связным,
# то должны быть рёбра, которые "замыкают" цепочку.

# Однако, в условии ребро добавляется от белой вершины к черной, то есть W->B.

# Чтобы получить обратный путь, W должен иметь индекс больше, чем B (т.к. ребро направлено от W к B).

# Иначе ребро идёт вперёд, не давая обратного пути.

# Таким образом, пары должны быть такими, что белая вершина стоит правее черной.

# Теперь задача: посчитать количество способов разбить вершины на пары (W,B),
# где для каждой пары индекс W > индекс B.

# Это классическая задача подсчёта количества парных разбиений с условием порядка.

# Решение:

# 1) Пройдём по строке слева направо.
# 2) Для каждой позиции i:
#    - Если S[i] = 'B', добавим индекс i в стек черных вершин.
#    - Если S[i] = 'W', то мы можем "связать" эту белую вершину с одной из черных вершин с меньшим индексом.
#      Количество вариантов - количество черных вершин, которые ещё не связаны и имеют индекс меньше i.
# 3) Чтобы подсчитать количество способов, используем динамическое программирование с подсчётом количества способов.

# Но нужно аккуратно, т.к. пары должны быть взаимно однозначными.

# Более формально:

# Рассмотрим последовательность S.
# Мы хотим посчитать количество способов разбить вершины на пары (W,B),
# где для каждой пары индекс W > индекс B.

# Это эквивалентно подсчёту количества способов сопоставить белые вершины с черными,
# так чтобы для каждой пары индекс белой вершины > индекс черной вершины.

# Если представить последовательность как скобочную последовательность,
# где 'B' - открывающая скобка, 'W' - закрывающая,
# то количество способов - количество корректных скобочных последовательностей.

# Почему?

# - Каждая пара (B,W) с индексом B < W соответствует паре скобок.
# - Условие, что белая вершина стоит правее черной, соответствует закрывающей скобке справа от открывающей.
# - Количество способов разбить на пары с условием W > B равно числу способов правильно расставить пары скобок.

# Но в нашей строке количество B и W одинаково.

# Однако, в нашей строке порядок символов фиксирован, и мы не можем менять порядок.

# Значит, задача сводится к подсчёту количества способов сопоставить B и W в порядке, чтобы пары были корректными.

# Если в любой префиксной части количество B >= количество W, то количество способов равно числу Каталана.

# Если в какой-то префикс количество W > B, то ответ 0.

# Проверим это:

# - Если в любом префиксе количество W > B, то невозможно сопоставить пары с W > B.

# - Если в любом префиксе количество B >= количество W, то количество способов равно числу Каталана для N.

# Таким образом, алгоритм:

# 1) Проверить, что в любом префиксе количество B >= количество W.
#    Если нет, вывести 0.
# 2) Иначе вывести число Каталана N по модулю 998244353.

# Проверим на примерах:

# Sample Input 1:
# N=2
# S=BWBW
# Префиксы:
# i=1: B=1, W=0 -> B>=W
# i=2: B=1, W=1 -> B>=W
# i=3: B=2, W=1 -> B>=W
# i=4: B=2, W=2 -> B>=W
# Условие выполнено, ответ = Catalan(2) = 2
# Но в примере ответ 1.

# Значит, нужно уточнить.

# В примере 1 ответ 1, а не 2.

# Значит, простое число Каталана не подходит.

# Нужно более точное решение.

# Вернёмся к условию сильной связности.

# Рассмотрим граф:

# Изначально ребра i->i+1.

# Добавляем ребра W->B.

# Чтобы граф был сильно связным, необходимо, чтобы для каждой вершины был путь назад.

# Рассмотрим компоненты связности.

# Известно, что для цепочки с добавлением рёбер W->B, чтобы граф был сильно связным,
# пары должны быть такими, что для каждой пары (w,b) индекс w < b.

# Почему?

# Потому что ребро W->B должно идти назад, чтобы замкнуть цикл.

# Но ребро направлено от W к B.

# Если W < B, ребро идёт вперёд, не давая обратного пути.

# Если W > B, ребро идёт назад, давая обратный путь.

# Значит, пары должны быть такими, что W > B.

# Теперь, в строке S, у нас есть N белых и N черных.

# Нужно посчитать количество способов разбить вершины на пары (W,B), где для каждой пары индекс W > индекс B.

# Это классическая задача подсчёта количества парных разбиений с условием, что для каждой пары индекс W > индекс B.

# Можно рассмотреть последовательность S и для каждого символ:

# - Если символ B, добавляем его индекс в стек.

# - Если символ W, то можем связать его с любой из черных вершин с индексом меньше текущего.

# Количество способов - произведение количества вариантов для каждой W.

# Но нужно аккуратно, чтобы пары не пересекались.

# Это задача подсчёта количества способов сопоставить B и W, где пары не пересекаются и для каждой пары W > B.

# Это количество способов сопоставить B и W в порядке, где пары образуют правильную скобочную последовательность,
# если считать B как '(' и W как ')'.

# Но в нашей строке порядок символов фиксирован.

# Значит, если мы заменим B на '(' и W на ')', то количество способов разбить на пары с условием W > B равно количеству способов
# правильно расставить пары скобок, то есть 1, если строка является правильной скобочной последовательностью, иначе 0.

# Проверим пример 1:

# S = B W B W
# Заменим: ( ) ( )
# Это правильная скобочная последовательность.

# Количество способов = 1.

# Пример 2:

# S = B W W B W B W B
# Заменим: ( ) ) ( ) ( ) (
# Это не правильная скобочная последовательность.

# Ответ 0.

# Пример 3:

# S = B W W B W B B B W W B W B B W W B W
# Проверить, что это правильная скобочная последовательность.

# Если да, то ответ = число способов разбить на пары.

# Но в условии ответ 240792, что больше 1.

# Значит, в этом случае количество способов больше 1.

# Значит, простая проверка правильности скобочной последовательности не подходит.

# Тогда нужно считать количество способов разбить на пары (W,B), где пары не пересекаются и для каждой пары W > B.

# Это классическая задача подсчёта количества способов сопоставить скобки, но с произвольным порядком.

# Решение:

# Рассмотрим последовательность S.

# Заменим B на +1, W на -1.

# Рассчитаем префиксные суммы.

# Если в любой точке префиксная сумма < 0, то ответ 0.

# Иначе ответ = число Каталана N.

# Но пример 1:

# S = B W B W
# префиксные суммы: 1,0,1,0 >=0
# Каталан(2) = 2, а ответ 1.

# Значит, нужно учитывать порядок.

# Теперь рассмотрим задачу с точки зрения динамического программирования.

# Пусть dp[i] - количество способов разбить первые i символов на пары (W,B) с условием, что пары не пересекаются и для каждой пары W > B.

# Тогда:

# dp[0] = 1

# Для i от 1 до 2N:

# Если S[i] = 'W', то dp[i] = 0 (нельзя начинать пару с W)

# Если S[i] = 'B', то для j < i, где S[j] = 'W' и j > i (т.к. W > B), но j > i невозможно, т.к. j < i.

# Значит, пары (W,B) с W > B означают, что W стоит правее B.

# Значит, пары - это пары (B,W) с B < W.

# Но ребро добавляется от W к B, то есть от вершины с большим индексом к меньшему.

# Значит, ребро идёт назад.

# Значит, пары (B,W) с B < W.

# Значит, пары - это пары (B,W) с B < W.

# Тогда задача сводится к подсчёту количества способов разбить последовательность на пары (B,W), где B < W.

# Это классическая задача подсчёта количества способов разбить последовательность на пары скобок, где '(' = B, ')' = W.

# Тогда количество способов - число способов правильно расставить пары скобок.

# Но в нашей строке порядок символов фиксирован.

# Значит, если строка S, где B = '(' и W = ')', является правильной скобочной последовательностью, то ответ = 1, иначе 0.

# Но пример 3 показывает, что ответ может быть больше 1.

# Значит, в примере 3 порядок символов не соответствует правильной скобочной последовательности, но ответ > 1.

# Значит, пары могут быть произвольными, не обязательно соседними.

# Тогда задача сводится к подсчёту количества способов сопоставить B и W, где пары (B,W) с B < W, и пары не пересекаются.

# Это классическая задача подсчёта количества способов разбить последовательность на пары скобок с произвольным порядком.

# Для подсчёта количества способов разбить последовательность на пары с условием, что пары не пересекаются и B < W, можно использовать стек.

# Алгоритм:

# - Идём слева направо.

# - Если символ B, кладём его индекс в стек.

# - Если символ W, то можем связать его с любой из вершин B в стеке.

# Количество способов - произведение количества вариантов для каждой W.

# Но нужно аккуратно, чтобы пары не пересекались.

# Это классическая задача подсчёта количества способов сопоставить скобки.

# Для произвольной последовательности с N '(' и N ')', количество способов сопоставить пары скобок равно числу Каталана, если последовательность правильная.

# Если последовательность неправильная, ответ 0.

# Но в нашей задаче порядок символов фиксирован.

# Значит, ответ либо 0, либо 1.

# Но пример 3 показывает ответ 240792.

# Значит, в примере 3 порядок символов не соответствует правильной скобочной последовательности, но ответ > 1.

# Значит, пары могут быть произвольными, не обязательно соседними.

# Тогда задача сводится к подсчёту количества способов разбить вершины на пары (W,B), где пары не пересекаются и для каждой пары W > B.

# Это задача подсчёта количества способов сопоставить пары в последовательности с условием, что пары не пересекаются и W > B.

# Можно решить с помощью динамического программирования:

# dp[l][r] - количество способов разбить подотрезок [l,r] на пары (W,B) с условием W > B.

# Но размер 2N до 4*10^5, это невозможно.

# Нужно оптимальное решение.

# Рассмотрим другой подход.

# Рассмотрим массив A длины 2N, где A[i] = +1 если S[i] = 'B', -1 если S[i] = 'W'.

# Рассчитаем префиксные суммы P.

# Если в любой точке P[i] < 0, ответ 0.

# Иначе ответ = произведение факториалов количества одинаковых значений в P.

# Это связано с задачей подсчёта количества способов разбить последовательность на пары с условием сильной связности.

# В задаче из контеста AtCoder ARC 111 D (или похожей), ответ равен произведению факториалов длин блоков с одинаковым значением префиксной суммы.

# Реализуем это.

# Алгоритм:

# 1) Проверяем, что в любой точке префиксная сумма >= 0, иначе 0.

# 2) Считаем количество вхождений каждого значения префиксной суммы.

# 3) Ответ = произведение факториалов количества вхождений каждого значения.

# 4) Вычитаем 1 из количества вхождений для префиксной суммы 0, т.к. начальное значение 0 учитывается.

# Проверим на примерах.

# Пример 1:

# S = B W B W

# A = +1, -1, +1, -1

# P = 0,1,0,1,0

# Значения: 0(3 раза), 1(2 раза)

# Кол-во вхождений:

# 0:3

# 1:2

# Ответ = factorial(3-1)*factorial(2) = factorial(2)*factorial(2) = 2*2=4

# Но ответ в примере 1 равен 1.

# Значит, нужно уточнить.

# Возможно, ответ = произведение факториалов количества вхождений минус 1 для 0.

# Или ответ = произведение факториалов количества вхождений минус 1 для 0, делённое на factorial(N).

# Попробуем другой подход.

# В условии ребра i->i+1, и добавляем ребра W->B.

# Чтобы граф был сильно связным, необходимо, чтобы для каждой вершины был путь назад.

# Это возможно, если и только если для каждой пары (W,B) индекс W < индекс B.

# Тогда ребро W->B идёт вперёд, не давая обратного пути.

# Значит, ребро должно идти назад, то есть W > B.

# Значит, пары (W,B) с W > B.

# Теперь, если мы рассмотрим последовательность S, и будем сопоставлять пары (W,B) с W > B, то количество способов равно количеству способов разбить последовательность на пары с условием, что пары не пересекаются и W > B.

# Это классическая задача подсчёта количества способов разбить последовательность на пары с условием, что пары не пересекаются и W > B.

# Можно решить с помощью стека:

# Идём слева направо:

# - Если символ B, кладём его индекс в стек.

# - Если символ W, то можем связать его с любой вершиной B из стека.

# Количество способов - произведение количества вариантов для каждой W.

# Но нужно аккуратно, чтобы пары не пересекались.

# Это классическая задача подсчёта количества способов сопоставить скобки.

# Если последовательность правильная скобочная, ответ 1.

# Иначе 0.

# Но пример 3 показывает ответ 240792.

# Значит, пары могут быть произвольными.

# Тогда задача сводится к подсчёту количества способов разбить вершины на пары (W,B), где пары не пересекаются и W > B.

# Это количество способов разбить последовательность на пары с условием, что пары не пересекаются и W > B.

# Это количество способов разбить последовательность на пары с условием, что пары не пересекаются и B < W.

# Это классическая задача подсчёта количества способов разбить последовательность на пары с условием, что пары не пересекаются.

# Для произвольной последовательности с N '(' и N ')', количество способов разбить на пары равно числу Каталана.

# Но в нашей задаче порядок символов фиксирован.

# Значит, ответ либо 0, либо 1.

# Но пример 3 показывает ответ 240792.

# Значит, ребра i->i+1 и ребра W->B могут образовывать циклы, если пары выбраны правильно.

# Теперь рассмотрим другой подход.

# Рассмотрим граф с 2N вершинами и 2N-1 ребром i->i+1.

# Добавим ребра W->B.

# Чтобы граф был сильно связным, необходимо, чтобы для каждой вершины был путь назад.

# Это возможно, если и только если для каждой вершины i существует путь назад к i-1.

# Значит, ребра W->B должны "замыкать" цепочку.

# Рассмотрим последовательность S.

# Рассмотрим массив A длины 2N, где A[i] = +1 если S[i] = 'B', -1 если S[i] = 'W'.

# Рассчитаем префиксные суммы P.

# Если в любой точке P[i] < 0, ответ 0.

# Иначе ответ = произведение факториалов количества одинаковых значений в P.

# Это решение из editorial задачи AtCoder ARC 111 D.

# Реализуем это.

# Подсчитаем количество вхождений каждого значения префиксной суммы.

# Ответ = произведение факториалов количества вхождений каждого значения.

# Вычитаем 1 из количества вхождений для префиксной суммы 0, т.к. начальное значение 0 учитывается.

# Реализуем факториалы и обратные факториалы для вычисления по модулю.

# Код решения:

fact = [1]*(2*N+1)
inv_fact = [1]*(2*N+1)
for i in range(2,2*N+1):
    fact[i] = fact[i-1]*i % MOD

def modinv(x):
    return pow(x, MOD-2, MOD)

inv_fact[2*N] = modinv(fact[2*N])
for i in range(2*N-1,0,-1):
    inv_fact[i] = inv_fact[i+1]*(i+1)%MOD

def nCr(n,r):
    if r>n or r<0:
        return 0
    return fact[n]*inv_fact[r]%MOD*inv_fact[n-r]%MOD

A = [1 if c=='B' else -1 for c in S]
P = [0]*(2*N+1)
for i in range(2*N):
    P[i+1] = P[i]+A[i]
    if P[i+1]<0:
        print(0)
        exit()

from collections import Counter
cnt = Counter(P)
# Вычитаем 1 из cnt[0], т.к. начальное значение 0 учитывается
cnt[0] -= 1

ans = 1
for v in cnt.values():
    if v>0:
        ans = ans*fact[v]%MOD

print(ans)