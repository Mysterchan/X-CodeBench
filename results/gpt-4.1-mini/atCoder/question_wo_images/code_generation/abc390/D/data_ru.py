def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split()))

    # Суть задачи:
    # Можно переносить все камни из одного мешка в другой, обнуляя первый и увеличивая второй.
    # В итоге сумма камней не меняется, но распределение меняется.
    #
    # Нужно найти количество различных значений XOR всех мешков после любых таких операций.
    #
    # Анализ:
    # - Операция: выбрать мешки A и B, переместить все камни из A в B.
    #   Тогда B_i меняется: B_B += B_A, B_A = 0.
    #
    # - Итоговое распределение камней — разбиение исходных камней на несколько мешков,
    #   где каждый мешок содержит сумму камней из некоторого непересекающегося подмножества исходных мешков.
    #
    # - Можно представить итоговое состояние как разбиение множества {1..N} на непересекающиеся подмножества,
    #   и каждому подмножеству соответствует сумма камней в нем.
    #
    # - XOR итоговых мешков — XOR сумм по этим подмножествам.
    #
    # - Задача сводится к: для всех разбиений множества {1..N} на непересекающиеся подмножества
    #   вычислить XOR сумм этих подмножеств и посчитать количество различных значений.
    #
    # Но перебор всех разбиений — слишком большой (число Белла для N=12 ~4.7 млн).
    #
    # Однако, можно заметить, что:
    # - Каждое итоговое состояние — это разбиение на k подмножеств (1 ≤ k ≤ N),
    #   где каждый подмножество — объединение исходных мешков.
    #
    # - XOR итоговых мешков — XOR сумм по этим подмножествам.
    #
    # - Можно рассмотреть все непустые подмножества исходных мешков и их суммы.
    #
    # - Задача сводится к: найти множество всех XOR, которые можно получить, разбивая множество {1..N}
    #   на непересекающиеся подмножества и XOR сумм этих подмножеств.
    #
    # Решение:
    # - Используем динамическое программирование по маскам.
    # - dp[mask] — множество всех возможных XOR значений, которые можно получить,
    #   разбивая подмножество мешков, заданное битовой маской mask.
    #
    # - Инициализация:
    #   dp[0] = {0} (пустое множество)
    #
    # - Переход:
    #   Для каждого mask > 0:
    #     dp[mask] = объединение по всем подмножествам submask ⊆ mask, submask != 0:
    #       dp[mask ^ submask] XOR sum(submask)
    #
    # - Ответ: размер dp[(1<<N)-1]
    #
    # Оптимизация:
    # - Для каждого mask перебираем подмножества submask.
    # - Для каждого submask вычисляем sum(submask) заранее.
    #
    # Сложность:
    # - 2^N масок, для каждой маски перебор подмножеств — 2^N, итого O(3^N).
    # - N=12 — приемлемо.
    #
    # Реализация с использованием множества для dp[mask].
    # Для экономии памяти можно использовать словарь с ключом mask и множеством значений.
    #
    # Предварительно вычислим сумму для всех подмножеств.

    from collections import defaultdict

    total_masks = 1 << N
    sum_subsets = [0] * total_masks
    for mask in range(1, total_masks):
        # mask & (-mask) — младший установленный бит
        lb = mask & (-mask)
        idx = (lb.bit_length() - 1)
        sum_subsets[mask] = sum_subsets[mask ^ lb] + A[idx]

    dp = [set() for _ in range(total_masks)]
    dp[0].add(0)

    for mask in range(1, total_masks):
        submask = mask
        while submask:
            rest = mask ^ submask
            val = sum_subsets[submask]
            for x in dp[rest]:
                dp[mask].add(x ^ val)
            submask = (submask - 1) & mask

    print(len(dp[total_masks - 1]))


if __name__ == "__main__":
    main()