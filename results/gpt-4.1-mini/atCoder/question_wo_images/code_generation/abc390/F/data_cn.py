import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# f(L,R) 的定義是擦除區間 [L,R] 上所有數字所需的最小操作次數。
# 操作是選擇一個區間 [l,r]，擦除該區間內所有出現的數字。
# 擦除的條件是該區間內的每個數字至少在黑板上出現一次。

# 觀察：
# 擦除操作本質上是將區間 [L,R] 分割成若干段，每段內的數字集合不重疊。
# 因為每次擦除的區間必須包含該區間內所有出現的數字的全部出現位置，
# 否則該數字不會被完全擦除。

# 因此，對於每個數字，我們可以找到它在 A 中的最左和最右出現位置。
# 擦除操作的區間必須包含該數字的整個出現區間。

# 這樣，f(L,R) 就是將 [L,R] 內的數字的出現區間合併成最少的區間數量。

# 具體來說：
# 對於區間 [L,R]，考慮該區間內所有數字的出現區間 [left_x, right_x]。
# 將這些區間合併，合併後的區間數即為 f(L,R)。

# 問題轉化為：
# 對所有子區間 [L,R]，計算該子區間內數字的出現區間合併後的區間數，
# 並將其加總。

# 由於 N 可達 3*10^5，暴力計算所有子區間不可能。

# 解法：
# 1. 預處理每個數字的最左和最右出現位置。
# 2. 對於每個位置 i，定義一個區間 [left[A[i]], right[A[i]]]。
# 3. 對所有 i，這些區間是固定的。
# 4. f(L,R) 是 [L,R] 內所有這些區間的合併區間數。

# 觀察：
# f(L,R) 是 [L,R] 內所有區間的合併區間數。
# 合併區間數 = 區間數 - 合併次數
# 但合併次數不好直接計算。

# 另一種思路：
# 對每個區間 [L,R]，f(L,R) 是最少擦除次數。
# 擦除次數等於將 [L,R] 內的數字的出現區間合併成的區間數。

# 由於每個數字的出現區間是固定的，我們可以將所有區間視為一組區間。

# 問題轉化為：
# 對所有子區間 [L,R]，計算該子區間內的區間合併數。

# 這個問題可以用「區間合併」的結構來處理。

# 具體做法：
# 對所有數字 x，記錄其區間 [left_x, right_x]。
# 對所有 i，將區間 [left_x, right_x] 加入一個結構。

# 對於每個 L，考慮 R 從 L 到 N：
# - 對於 R，將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這樣仍是 O(N^2)。

# 需要更優解。

# 進一步觀察：
# f(L,R) 是擦除區間 [L,R] 的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，我可以找到所有數字的出現區間。
# 這些區間形成一組區間集合。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有數字的出現區間合併後的區間數。

# 這等價於：
# 對所有區間 [left_x, right_x]，
# 計算有多少個區間與 [L,R] 有交集，
# 且這些區間合併後的區間數。

# 但合併後的區間數 = 交集區間數 - 合併次數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 重要觀察：
# f(L,R) = 最少擦除次數 = 將 [L,R] 內的數字的出現區間合併成的區間數。
# 這等價於：
# 對 [L,R] 內的區間集合，合併重疊區間後的區間數。

# 另一種表示：
# f(L,R) = 區間數 - 重疊合併次數

# 但計算合併次數較難。

# 另一種思路：
# 對整個序列，將每個數字的出現區間視為一個區間。
# 對所有區間，排序後合併。

# 對於每個位置 i，定義一個「區間合併」的結構。

# 由於題目要求 sum_{L,R} f(L,R)，
# 我們嘗試用「差分」或「前綴和」技巧。

# 具體解法參考：
# https://codeforces.com/blog/entry/105726
# 類似題目「區間合併計數」的技巧。

# 解法：
# 對每個數字 x，記錄其區間 [l_x, r_x]。
# 對所有區間，將 l_x 加入 start_list，r_x 加入 end_list。

# 對每個位置 i，計算：
# - start_count[i] = 有多少區間以 i 為起點
# - end_count[i] = 有多少區間以 i 為終點

# 定義一個變數 active，表示當前活躍的區間數。
# 從左到右掃描 i=1..N：
# - active += start_count[i]
# - 對於每個 i，active 表示有多少區間覆蓋 i。
# - active -= end_count[i]

# 但這只是覆蓋數，非合併區間數。

# 另一種思路：
# f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。
# 合併區間數 = 區間數 - 合併次數
# 合併次數 = 區間數 - 合併區間數

# 但計算合併次數較難。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「線段樹」或「二分」來查詢。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間 [L,R]，f(L,R) 是該子區間內所有區間的合併區間數。

# 由於區間是固定的，我們可以用「區間合併」的技巧。

# 具體做法：
# 對所有區間，排序。
# 對每個位置 i，記錄該位置是哪些區間的起點或終點。

# 對每個 L，從 L 開始往右擴展 R：
# - 將 A[R] 對應的區間加入考慮。
# - 合併區間後，合併區間數即為 f(L,R)。

# 但這仍是 O(N^2)。

# 需要更巧妙的解法。

# 觀察：
# f(L,R) 是擦除 [L,R] 所需的最小操作數。
# 擦除操作是選擇一個區間，擦除該區間內所有數字。
# 擦除區間必須包含該區間內所有數字的完整出現區間。

# 因此，f(L,R) 是將 [L,R] 內的數字的出現區間合併成的區間數。

# 另一種思路：
# 對整個序列，將每個數字的區間視為一個區間。
# 對所有區間，排序後合併，得到一組不重疊區間。

# 對於每個子區間