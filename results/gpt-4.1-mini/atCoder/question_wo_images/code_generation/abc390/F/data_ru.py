import sys
import threading

def main():
    import sys
    sys.setrecursionlimit(1 << 25)
    N = int(sys.stdin.readline())
    A = list(map(int, sys.stdin.readline().split()))

    # Идея решения:
    # f(L,R) - минимальное количество операций для удаления всех чисел на доске A_L..A_R.
    #
    # Операция: выбираем интервал [l,r], такой что все числа от l до r встречаются хотя бы один раз на доске,
    # и удаляем все их вхождения.
    #
    # Минимальное число операций - это минимальное разбиение множества чисел на доске на интервалы [l,r],
    # покрывающие все числа, где каждый интервал соответствует одной операции.
    #
    # Для подотрезка A_L..A_R:
    # - Рассмотрим множество уникальных чисел на этом подотрезке.
    # - Для каждого числа x возьмём его минимальный и максимальный индекс в [L,R].
    # - Тогда для каждого числа x на подотрезке [L,R] у нас есть интервал [minPos_x, maxPos_x].
    #
    # Чтобы операция была корректной, интервал [l,r] должен покрывать все числа, т.е. объединение интервалов чисел,
    # которые входят в этот интервал, должно быть непрерывным.
    #
    # Таким образом, f(L,R) - минимальное количество разбиений интервала [L,R] на интервалы, каждый из которых
    # является объединением интервалов чисел, не пересекающихся с другими.
    #
    # Это классическая задача о разбиении интервала на минимальное число "связных" блоков по интервалам.
    #
    # Для решения задачи суммирования по всем подотрезкам:
    #
    # Рассмотрим для каждого числа x его минимальный и максимальный индекс в массиве A: left_x, right_x.
    #
    # Построим массив right_most, где right_most[i] = максимальный right_x среди всех чисел, встречающихся в A[i].
    #
    # Теперь пройдём по массиву и будем искать "блоки" - минимальные интервалы, которые покрывают все числа внутри.
    #
    # Для каждого i:
    #   max_right = max(max_right, right_most[i])
    #   Если i == max_right, значит мы нашли блок [start, i]
    #
    # Для каждого блока f(start,i) = 1, т.к. можно удалить все числа за одну операцию.
    #
    # Но нам нужно f(L,R) для всех подотрезков.
    #
    # Ключевой момент:
    # f(L,R) = минимальное число блоков, на которые можно разбить [L,R].
    #
    # Если мы заранее знаем для каждого i минимальный индекс start_i, с которого начинается блок, заканчивающийся в i,
    # то f(L,R) = количество блоков, покрывающих [L,R].
    #
    # Для подсчёта суммы по всем L,R:
    #
    # Используем следующий подход:
    #
    # 1) Для каждого i найдём left_bound[i] - минимальный индекс начала блока, в котором i входит.
    # 2) Тогда f(L,R) = количество блоков, которые полностью покрывают [L,R].
    #
    # Но это сложно напрямую.
    #
    # Альтернативный подход:
    #
    # Рассмотрим массив B длины N, где B[i] = 1, если i - конец блока, иначе 0.
    #
    # Тогда f(L,R) = количество блоков, которые заканчиваются в [L,R].
    #
    # Для фиксированного L, f(L,R) монотонно не убывает по R.
    #
    # Можно посчитать сумму f(L,R) по всем L,R, используя префиксные суммы.
    #
    # Реализация:
    #
    # - Найдём для каждого числа x его left_x и right_x.
    # - Создадим массив max_right, где max_right[i] = right_x для числа A[i].
    # - Пройдём по массиву, поддерживая max_r = максимальный right_x среди чисел в текущем блоке.
    # - Когда i == max_r, блок заканчивается.
    # - Запишем для каждого блока его start и end.
    #
    # Теперь у нас есть разбиение массива на блоки.
    #
    # Для каждого блока [start,end]:
    #   f(L,R) = 1, если [L,R] полностью внутри блока
    #   иначе f(L,R) = сумма f по подблокам
    #
    # Но в условии f(L,R) - минимальное число операций, а блоки - минимальное разбиение.
    #
    # Значит, для подотрезка, который пересекает несколько блоков, f(L,R) = количество блоков, пересекающих [L,R].
    #
    # Таким образом, f(L,R) = количество блоков, которые пересекают [L,R].
    #
    # Теперь задача сводится к подсчёту суммы по всем L,R количества блоков, пересекающих [L,R].
    #
    # Пусть блоки заданы интервалами [b_start_i, b_end_i], i=1..M.
    #
    # Для каждого подотрезка [L,R], количество блоков, пересекающих [L,R] = количество блоков i, для которых
    # b_end_i >= L и b_start_i <= R.
    #
    # Переформулируем:
    #
    # sum_{L=1}^N sum_{R=L}^N f(L,R) = sum_{L=1}^N sum_{R=L}^N (кол-во блоков i с b_end_i >= L и b_start_i <= R)
    #
    # Меняем порядок суммирования:
    #
    # = sum_{i=1}^M sum_{L=1}^{b_end_i} sum_{R=max(L,b_start_i)}^N 1
    #
    # Для фиксированного блока i:
    #   L от 1 до b_end_i
    #   R от max(L,b_start_i) до N
    #
    # Подсчитаем количество пар (L,R):
    #
    # Если L < b_start_i, то R >= b_start_i
    # Если L >= b_start_i, то R >= L
    #
    # Количество пар:
    # sum_{L=1}^{b_start_i-1} (N - b_start_i + 1) + sum_{L=b_start_i}^{b_end_i} (N - L + 1)
    #
    # = (b_start_i -1)*(N - b_start_i +1) + sum_{L=b_start_i}^{b_end_i} (N - L +1)
    #
    # sum_{L=b_start_i}^{b_end_i} (N - L +1) = sum_{k=0}^{b_end_i - b_start_i} (N - (b_start_i + k) +1)
    # = sum_{k=0}^{d} (N - b_start_i +1 - k), где d = b_end_i - b_start_i
    # = (d+1)*(N - b_start_i +1) - (d*(d+1))/2
    #
    # Итого для блока i:
    # S_i = (b_start_i -1)*(N - b_start_i +1) + (d+1)*(N - b_start_i +1) - (d*(d+1))//2
    # где d = b_end_i - b_start_i
    #
    # = (b_start_i -1 + d +1)*(N - b_start_i +1) - (d*(d+1))//2
    # = (b_end_i)*(N - b_start_i +1) - (d*(d+1))//2
    #
    # Суммируем S_i по всем блокам i.
    #
    # Это и будет ответом.
    #
    # Проверим на примерах.
    #
    # Реализуем.

    left_pos = [N+1]*(N+1)
    right_pos = [0]*(N+1)
    for i, x in enumerate(A,1):
        if i < left_pos[x]:
            left_pos[x] = i
        if i > right_pos[x]:
            right_pos[x] = i

    max_right = [0]*(N+1)
    for i in range(1,N+1):
        max_right[i] = right_pos[A[i-1]]

    blocks = []
    start = 1
    max_r = 0
    for i in range(1,N+1):
        if max_right[i] > max_r:
            max_r = max_right[i]
        if i == max_r:
            blocks.append((start, i))
            start = i+1

    ans = 0
    for (b_start, b_end) in blocks:
        d = b_end - b_start
        val = b_end*(N - b_start +1) - (d*(d+1))//2
        ans += val

    print(ans)

threading.Thread(target=main).start()