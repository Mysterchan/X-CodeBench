import sys
input = sys.stdin.readline

N, Q = map(int, input().split())
A = list(map(int, input().split()))

# dp[i] := 最大操作回数のための累積値のようなものを i まで計算したもの
# 問題の操作は、距離が1か2のペア (i,j) で両方とも1以上の値から1ずつ引くことができる。
# つまり、隣接(i,i+1)または(i,i+2)のペアで操作可能。
# 操作回数の最大値は、区間内のこれらのペアの操作回数の最大和。

# 1. 各隣接ペア(i,i+1)の操作可能回数は min(A[i], A[i+1])
# 2. 各距離2ペア(i,i+2)の操作可能回数は min(A[i], A[i+2])

# しかし、同じ要素は複数ペアに含まれるため、単純に和をとると過剰計算になる。
# そこで、問題の操作は「1以上の値を持つ2つの要素のペア(i,j)で、j-i=1または2」で1ずつ引く操作を繰り返す。
# 最大操作回数は、区間内の辺(ペア)の最大マッチング数に相当する。

# ここで、距離1のペアは隣接辺、距離2のペアは1つ飛ばしの辺。
# このグラフは区間内の頂点を持つ線形グラフに距離1と距離2の辺を加えたもの。

# 重要な観察:
# 操作はペアの辺を使って1ずつ引くことができる。
# 各辺の操作回数は min(A[i], A[j]) まで可能。
# しかし、同じ頂点の値は複数の辺で使い回せない（1回の操作で1ずつ引くため、頂点の値の合計が操作回数の上限）。

# つまり、最大操作回数は区間内の頂点の値の合計のうち、辺でペアを作って引ける回数の最大値。

# さらに、距離1のペアと距離2のペアは重複しない辺の集合で最大のマッチングを作る問題に帰着。

# しかし、距離1の辺と距離2の辺は重複しないマッチングを作ることができる。
# なぜなら、距離1の辺は (i,i+1)、距離2の辺は (i,i+2) であり、
# 距離1の辺は隣接ペア、距離2の辺は1つ飛ばしペアで、これらは交差しない。

# したがって、最大操作回数は区間内の距離1の辺の min(A[i], A[i+1]) の和と距離2の辺の min(A[i], A[i+2]) の和の最大値の組み合わせ。

# しかし、同じ頂点の値を複数回使えないため、単純に和をとることはできない。

# ここで、距離1の辺は隣接ペア、距離2の辺は1つ飛ばしペアであり、
# これらの辺は互いに重ならないマッチングを作ることができる。

# つまり、距離1の辺と距離2の辺は同時に使える。

# さらに、距離1の辺は区間内の i= L..R-1 で min(A[i], A[i+1])、
# 距離2の辺は i= L..R-2 で min(A[i], A[i+2])。

# したがって、区間内の最大操作回数は
# sum_{i=L}^{R-1} min(A[i], A[i+1]) + sum_{i=L}^{R-2} min(A[i], A[i+2])

# ただし、これが本当に最大かを確認する必要がある。

# サンプル1で確認:
# A = [1,1,4,0,3,2]
# 区間1-6
# 距離1の辺の和:
# min(1,1)=1 + min(1,4)=1 + min(4,0)=0 + min(0,3)=0 + min(3,2)=2 => 1+1+0+0+2=4
# 距離2の辺の和:
# min(1,4)=1 + min(1,0)=0 + min(4,3)=3 + min(0,2)=0 => 1+0+3+0=4
# 合計8となるが、答えは5。

# つまり単純に和をとるのは過剰計算。

# ここで、距離1の辺と距離2の辺は重複して頂点を使う可能性があるため、
# 頂点の値の制約を考慮しなければならない。

# 重要なことは、操作は頂点の値を消費する。
# 各操作は2つの頂点の値を1ずつ減らす。
# したがって、最大操作回数は区間内の頂点の値の合計の半分以下。

# つまり、最大操作回数 ≤ sum(A[L..R]) // 2

# また、操作は距離1か距離2の辺でしかできないため、
# 区間内の頂点の値の合計の半分が上限。

# さらに、距離1の辺の和と距離2の辺の和の最大値は操作回数の上限を示す。

# したがって、最大操作回数は
# min( sum(A[L..R])//2, sum_{i=L}^{R-1} min(A[i], A[i+1]) + sum_{i=L}^{R-2} min(A[i], A[i+2]) )

# これでサンプル1を計算すると
# sum(A) = 1+1+4+0+3+2=11
# sum(A)//2=5
# 距離1の辺の和=4
# 距離2の辺の和=4
# 合計8
# min(5,8)=5 → 答えと一致

# サンプル2も同様に確認可能。

# したがって、クエリごとに
# 1. 区間の和 sumA = prefix_sum[R] - prefix_sum[L-1]
# 2. 区間の距離1辺の和 sumD1 = prefix_d1[R-1] - prefix_d1[L-1] (ただしR-1 >= L)
# 3. 区間の距離2辺の和 sumD2 = prefix_d2[R-2] - prefix_d2[L-1] (ただしR-2 >= L)

# 最大操作回数 = min(sumA//2, sumD1 + sumD2)

# これを高速に処理するために、prefix sumsを用意する。

prefix_sum = [0]*(N+1)
for i in range(N):
    prefix_sum[i+1] = prefix_sum[i] + A[i]

d1 = [0]*(N)  # min(A[i], A[i+1]) for i in [0..N-2], d1[N-1]=0
for i in range(N-1):
    d1[i] = min(A[i], A[i+1])
prefix_d1 = [0]*(N+1)
for i in range(N):
    prefix_d1[i+1] = prefix_d1[i] + d1[i]

d2 = [0]*(N)  # min(A[i], A[i+2]) for i in [0..N-3], d2[N-2]=d2[N-1]=0
for i in range(N-2):
    d2[i] = min(A[i], A[i+2])
prefix_d2 = [0]*(N+1)
for i in range(N):
    prefix_d2[i+1] = prefix_d2[i] + d2[i]

for _ in range(Q):
    L, R = map(int, input().split())
    sumA = prefix_sum[R] - prefix_sum[L-1]
    sumD1 = 0
    if R-1 >= L:
        sumD1 = prefix_d1[R-1] - prefix_d1[L-1]
    sumD2 = 0
    if R-2 >= L:
        sumD2 = prefix_d2[R-2] - prefix_d2[L-1]
    ans = min(sumA//2, sumD1 + sumD2)
    print(ans)