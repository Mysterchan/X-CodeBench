import sys
input = sys.stdin.readline

N, Q = map(int, input().split())
A = list(map(int, input().split()))

# 根據題意，操作是從子序列 B 中選擇兩個位置 i, j，且 |j - i| ≤ 2，
# 並且 B_i, B_j ≥ 1，從兩者各減 1。
# 問最多能執行多少次操作。

# 觀察：
# 每次操作消耗兩個元素各 1。
# 操作限制 j - i ≤ 2，表示只能在距離 1 或 2 內的元素配對。
# 也就是說，配對只能是相鄰或相隔一個元素的元素。

# 我們要找最大匹配數，使得每次匹配的兩個元素距離 ≤ 2。

# 這個問題等價於在序列中建立一個圖，節點是元素位置，
# 邊連接距離 ≤ 2 的節點，且邊的權重是兩端元素的可用次數。
# 我們要找最大匹配數。

# 但因為每個元素的數量很大(可達10^9)，且N很大(2*10^5)，
# 不能直接模擬。

# 另一種思考：
# 每次操作消耗兩個元素各1，且兩元素距離 ≤ 2。
# 也就是說，操作只能在距離1或2的元素間進行。

# 我們可以將序列分成三個組：
# group0: i mod 3 == 0
# group1: i mod 3 == 1
# group2: i mod 3 == 2

# 距離 ≤ 2 的邊只會連接不同組：
# - 距離1的邊連接 (i, i+1)，即 (group k, group (k+1)%3)
# - 距離2的邊連接 (i, i+2)，即 (group k, group (k+2)%3)

# 因此，整個序列的元素被分成三組，操作只能在不同組間進行。

# 令：
# S0 = sum of A[i] for i mod 3 == 0
# S1 = sum of A[i] for i mod 3 == 1
# S2 = sum of A[i] for i mod 3 == 2

# 操作消耗兩個元素各1，且兩元素距離 ≤ 2，
# 等價於從三組中選擇兩組配對。

# 因為操作只能在距離1或2的元素間進行，
# 也就是只能在 (0,1), (1,2), (0,2) 三對組合中進行。

# 但因為距離 ≤ 2 的限制，所有組間的配對都允許。

# 因此，最大操作次數 = 最大匹配數 = 最大的兩兩配對和。

# 但每次操作消耗兩個元素各1，總消耗元素數 = 2 * 操作次數。

# 元素總和 = S0 + S1 + S2

# 最大操作次數 ≤ floor(元素總和 / 2)

# 且操作只能在組間配對，不能在同組內配對。

# 因此，最大操作次數 ≤ min( (S0 + S1 + S2)//2, S0 + S1, S1 + S2, S0 + S2 )

# 因為操作只能在組間配對，最大操作次數不能超過任意兩組元素和。

# 綜合以上，最大操作次數 = min( (S0 + S1 + S2)//2, S0 + S1, S1 + S2, S0 + S2 )

# 針對子序列 B = A[L:R]，我們計算該區間內三組的和，套用上述公式。

# 為了快速查詢，我們建立三個前綴和陣列，分別記錄 mod3 = 0,1,2 的元素和。

prefix = [[0]*(N+1) for _ in range(3)]
for i in range(N):
    for r in range(3):
        prefix[r][i+1] = prefix[r][i]
    prefix[i%3][i+1] += A[i]

for _ in range(Q):
    L, R = map(int, input().split())
    # 計算三組和
    S0 = prefix[0][R] - prefix[0][L-1]
    S1 = prefix[1][R] - prefix[1][L-1]
    S2 = prefix[2][R] - prefix[2][L-1]
    total = S0 + S1 + S2
    ans = min(total//2, S0+S1, S1+S2, S0+S2)
    print(ans)