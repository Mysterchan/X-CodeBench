import sys

def main():
    input = sys.stdin.readline
    N = int(input())
    S = input().strip()

    ones_pos = [i for i, ch in enumerate(S) if ch == '1']
    k = len(ones_pos)

    # Если все 1 уже смежны, ответ 0
    # Но мы проверим минимальное количество операций

    # Идея:
    # Чтобы минимизировать количество операций, нужно собрать все 1 подряд.
    # Оптимально расположить их так, чтобы минимизировать сумму расстояний перемещений.
    #
    # Пусть positions of ones: p_0 < p_1 < ... < p_{k-1}
    # Мы хотим расположить их подряд, например, на позициях x, x+1, ..., x+k-1
    # Тогда суммарное количество операций (перестановок соседних символов) равно
    # sum_{j=0}^{k-1} |p_j - (x + j)|
    #
    # Чтобы минимизировать сумму, нужно выбрать x так, чтобы сумма минимальна.
    # Перепишем:
    # sum |p_j - (x + j)| = sum |(p_j - j) - x|
    #
    # Теперь задача сводится к выбору x, минимизирующего sum |a_j - x|, где a_j = p_j - j
    # Минимум достигается при x = медиане массива a_j.
    #
    # Тогда ответ = sum |a_j - median(a)|

    a = [pos - i for i, pos in enumerate(ones_pos)]
    a.sort()
    median = a[k // 2]
    ans = sum(abs(x - median) for x in a)
    print(ans)

if __name__ == "__main__":
    main()