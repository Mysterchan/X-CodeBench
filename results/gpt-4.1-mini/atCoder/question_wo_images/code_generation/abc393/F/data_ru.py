import sys
import bisect

input = sys.stdin.readline

N, Q = map(int, input().split())
A = list(map(int, input().split()))

queries = []
for i in range(Q):
    R, X = map(int, input().split())
    queries.append((R, X, i))

# Сортируем запросы по R по возрастанию
queries.sort(key=lambda x: x[0])

# Для обработки LIS будем использовать классический алгоритм с O(N log N)
# Но нам нужно учитывать ограничение по X_i: элементы не должны превышать X_i.
# Мы будем обрабатывать массив A по возрастанию индекса, поддерживая структуру для LIS.
# Для каждого запроса с R_i мы уже обработаем A[:R_i].
# Чтобы ответить на запрос с ограничением X_i, нам нужно быстро найти длину LIS,
# состоящей из элементов <= X_i.

# Идея:
# При обработке массива A по индексам от 1 до N мы будем строить массив tails,
# где tails[len] = минимальный последний элемент строго возрастающей подпоследовательности длины len.
# tails строго возрастающий.

# Для ответа на запрос (R_i, X_i):
# - Мы уже обработали A[:R_i], получили tails для этой части.
# - Нужно найти максимальную длину l, такую что tails[l] <= X_i.
# - Это можно сделать бинарным поиском по tails.

# Но tails меняется при добавлении каждого элемента.
# Нам нужно уметь быстро получить tails для любого R_i.
# Решение: будем сохранять состояние tails после каждого i.
# Но tails может быть длиной до N, и Q до 2e5, хранить все tails для каждого i - слишком много.

# Оптимизация:
# tails меняется только при добавлении элемента, и каждый элемент либо расширяет tails, либо обновляет один из элементов.
# Мы можем сохранить для каждого i длину LIS на префиксе A[:i] и значение tails.
# Но для ответа на запрос с ограничением X_i нам нужно знать tails.

# Решение:
# Для каждого i сохраним длину LIS на префиксе A[:i] и значение tails.
# Но tails меняется, и нам нужно быстро ответить на запрос:
# "Какова максимальная длина l, что tails[l] <= X_i?"

# tails - массив минимальных концов LIS длины l.
# tails строго возрастающий.

# Мы можем сохранить для каждого i длину LIS и значение tails.
# Но tails меняется при каждом i, и хранить все tails для каждого i - O(N^2).

# Альтернативный подход:
# Обработаем запросы по возрастанию R_i.
# При обработке i-го элемента обновим tails.
# Для каждого i сохраним длину LIS на префиксе A[:i].
# Также сохраним копию tails после i-го элемента.

# Но копировать tails для каждого i - дорого.

# Оптимизация:
# tails меняется только в одном месте при добавлении элемента:
# либо добавляется новый элемент в конец tails (увеличивается длина LIS),
# либо обновляется один из элементов tails.

# Значит, для каждого i мы можем сохранить:
# - длину LIS на префиксе A[:i]
# - индекс в tails, который был обновлен (позиция pos)
# - значение tails[pos] после обновления

# Тогда для каждого i мы можем восстановить tails, если нужно.

# Но для ответа на запрос с ограничением X_i нам нужно быстро найти максимальную длину l,
# такую что tails[l] <= X_i.

# Мы можем для каждого i сохранить длину LIS и значение tails (последний элемент для каждой длины).
# Но это сложно.

# Другой подход:

# Для каждого i сохраним длину LIS на префиксе A[:i].
# Для каждого i сохраним значение A[i].

# Теперь для каждого запроса (R_i, X_i) нам нужно найти длину LIS на префиксе A[:R_i],
# состоящей из элементов <= X_i.

# Можно рассмотреть элементы A[:R_i], отфильтровать по <= X_i и найти LIS.

# Но это O(N log N) на каждый запрос - слишком дорого.

# Еще идея:

# Используем offline обработку запросов.

# Отсортируем запросы по R_i по возрастанию.

# Будем обрабатывать массив A по возрастанию i от 1 до N,
# поддерживая структуру для LIS.

# Для поддержки LIS с ограничением по X_i нам нужно уметь быстро получить
# длину LIS среди элементов <= X_i.

# Можно использовать Fenwick tree (BIT) или сегментное дерево по значениям A[i].

# Для этого сделаем компрессию значений A[i].

# Алгоритм:

# 1. Компрессируем значения A[i] и X_i из запросов.
# 2. Обрабатываем массив A по i от 1 до N.
# 3. Для каждого i обновляем Fenwick tree:
#    - Для A[i], находим максимальную длину LIS среди элементов с индексом < A[i] (в сжатом виде).
#    - Длина LIS для A[i] = max_prev + 1.
#    - Обновляем Fenwick tree в позиции A[i] длиной LIS.
# 4. Для каждого запроса (R_i, X_i):
#    - После обработки i = R_i,
#    - Нужно найти максимальную длину LIS среди элементов <= X_i.
#    - Fenwick tree позволяет получить max длину LIS для всех элементов <= X_i.

# Таким образом, мы можем ответить на запросы в порядке возрастания R_i.

# Реализация:

# - Компрессируем все значения A[i] и X_i.
# - Создаем Fenwick tree для max.
# - Обрабатываем A по i.
# - Для каждого i:
#   - Получаем max_len = fenw.query(A[i]-1)
#   - cur_len = max_len + 1
#   - fenw.update(A[i], cur_len)
# - Для каждого запроса с R_i == i:
#   - Ответ = fenw.query(X_i)

# Важно: X_i тоже сжимаем.

# Реализация Fenwick tree для max:

class Fenw:
    def __init__(self, n):
        self.n = n
        self.fw = [0]*(n+1)
    def update(self, i, v):
        while i <= self.n:
            if self.fw[i] < v:
                self.fw[i] = v
            i += i & (-i)
    def query(self, i):
        res = 0
        while i > 0:
            if self.fw[i] > res:
                res = self.fw[i]
            i -= i & (-i)
        return res

vals = set(A)
for _, X, _ in queries:
    vals.add(X)
vals = sorted(vals)
def get_idx(x):
    # 1-based index for Fenw
    return bisect.bisect_left(vals, x) + 1

A_comp = [get_idx(x) for x in A]
queries_by_R = [[] for _ in range(N+1)]
for R, X, idx in queries:
    queries_by_R[R].append((X, idx))

fenw = Fenw(len(vals))
res = [0]*Q

for i in range(1, N+1):
    a = A_comp[i-1]
    max_len = fenw.query(a-1)
    cur_len = max_len + 1
    fenw.update(a, cur_len)
    for X, idx in queries_by_R[i]:
        x_comp = get_idx(X)
        ans = fenw.query(x_comp)
        res[idx] = ans

print('\n'.join(map(str, res)))