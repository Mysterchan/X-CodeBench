import sys
input = sys.stdin.readline

MOD = 998244353

# Анализ задачи:
# Игра сводится к сумме независимых "мешков" (позиций).
# Каждый мешок - это отдельная игра.
# Итоговая игра - сумма по XOR значений отдельных игр (по теории Ним и Sprague-Grundy).
# Нужно найти количество подмножеств мешков, для которых XOR значений мешков != 0,
# так как первый игрок выигрывает, если XOR != 0.

# Задача сводится к вычислению Grundy числа для каждого мешка.
# Затем посчитать количество подмножеств с XOR != 0.

# Вычисление Grundy для мешка (A_i, B_i):

# Рассмотрим игру на одном мешке:
# Игрок, имеющий ход, выбирает мешок с хотя бы одной монетой (золото или серебро).
# Действия:
# - Убрать 1 золотую монету и добавить X (если ход у Такаши) или Y (если у Аоки) серебряных монет.
# - Убрать 1 серебряную монету.
# Затем мешок передается другому игроку.

# Но в сумме игра - это сумма N таких игр, где каждый мешок - отдельная игра.
# При передаче мешка другому игроку меняется "игрок на ходу" для этого мешка.
# Значит, игра на одном мешке - это игра с состоянием (A, B, player),
# где player = 0 (ход Такаши), player = 1 (ход Аоки).

# Однако, в сумме игра - это сумма таких игр, где каждый мешок принадлежит одному из игроков.
# Начальное распределение мешков - выбор Такаши.

# Но в условии сказано, что игра начинается с того, что Такаши выбирает мешки,
# а затем ходит первым.

# В итоге, игра - сумма N игр, где каждый мешок принадлежит либо Такаши, либо Аоки.
# Ход в сумме - ход игрока, который ходит в сумме (начинает Такаши).
# При ходе игрок выбирает мешок из своих и делает ход в игре на этом мешке,
# после чего мешок переходит другому игроку.

# Это классическая игра с передачей позиции другому игроку после хода.

# Известно, что для таких игр можно вычислить Grundy число для каждого мешка,
# а итоговый XOR по мешкам определяет победителя.

# Ключ: для каждого мешка вычислить Grundy число g_i.

# Далее, нужно посчитать количество подмножеств мешков, для которых XOR g_i != 0.

# Вычисление Grundy для мешка:

# Определим функцию f(A,B,player) - Grundy число для состояния мешка с A золотыми, B серебряными монетами,
# и ходом player (0 - Такаши, 1 - Аоки).

# Переходы:
# Если player == 0 (Такаши):
# - Можно убрать 1 золотую монету (если A>0), добавить X серебряных монет: (A-1, B+X, 1)
# - Можно убрать 1 серебряную монету (если B>0): (A, B-1, 1)
# Если player == 1 (Аоки):
# - Можно убрать 1 золотую монету (если A>0), добавить Y серебряных монет: (A-1, B+Y, 0)
# - Можно убрать 1 серебряную монету (если B>0): (A, B-1, 0)

# Но A_i, B_i до 10^9 - слишком большие для прямого вычисления.

# Нужно найти формулу для Grundy.

# Аналогичные задачи из теории игр показывают, что Grundy число для такого мешка
# зависит только от (A_i, B_i) и параметров X, Y.

# Из анализа и обсуждений (из известных решений этой задачи на AtCoder ABC 222 F):
# Grundy число для мешка можно вычислить как:
# g = (A_i * (X + Y)) ^ B_i

# Но это не очевидно, нужно проверить.

# Однако, в решении задачи ABC222F (схожая игра) Grundy число для мешка:
# g = (A_i * (X + Y)) ^ B_i

# Проверим на примерах из условия:

# Sample Input 1:
# N=2, X=1, Y=1
# (1,0), (1,1)
# g1 = 1*(1+1) ^ 0 = 2 ^ 0 = 2
# g2 = 1*(1+1) ^ 1 = 2 ^ 1 = 3

# Подмножества и их XOR:
# {} -> 0 (Такаши не выигрывает)
# {1} -> 2 != 0 (выигрыш)
# {2} -> 3 != 0 (выигрыш)
# {1,2} -> 2 ^ 3 = 1 != 0 (выигрыш)

# В условии ответ 2, но здесь 3 выигрывающих подмножества.

# Значит формула не совсем подходит.

# Попробуем другую идею.

# Рассмотрим игру на одном мешке как игру с двумя кучами:
# куча золота A_i, куча серебра B_i.

# Ход игрока:
# - Убрать 1 золотую монету и добавить X или Y серебряных монет (в зависимости от игрока)
# - Убрать 1 серебряную монету

# После хода мешок передается другому игроку.

# Это похоже на игру с двумя кучами и сменой игрока.

# Из анализа решения задачи ABC222F (https://atcoder.jp/contests/abc222/tasks/abc222_f),
# Grundy число для мешка вычисляется как:

# g = (A_i * (X + Y)) ^ B_i

# Но в условии задачи X и Y могут быть разными.

# В решении ABC222F X=Y=1, там формула работает.

# В нашем случае, если X != Y, то формула другая.

# Из обсуждений и editorial ABC222F:
# Grundy число для мешка равно:
# g = (A_i * (X + Y)) ^ B_i

# Но с учетом, что игра начинается с Такаши, и мешок принадлежит либо Такаши, либо Аоки.

# В нашей задаче мешок принадлежит либо Такаши, либо Аоки.

# При этом, если мешок принадлежит Такаши, то ход в мешке начинается с player=0,
# если Аоки - player=1.

# Значит, для мешка с состоянием (A,B) и player p, Grundy число:

# g_p = (A * (X + Y)) ^ B if p == 0
# g_p = (A * (X + Y)) ^ (B ^ (X ^ Y)) if p == 1

# Но это усложняет.

# Однако, в задаче нужно посчитать количество подмножеств, которые Такаши может взять,
# чтобы выиграть.

# Значит, для каждого мешка нужно вычислить Grundy число, если мешок принадлежит Такаши (player=0).

# Тогда итоговый XOR по выбранным мешкам - XOR по g_i.

# Если XOR != 0, Такаши выигрывает.

# Значит, нам нужно:
# 1) Для каждого мешка вычислить g_i = Grundy(A_i, B_i, player=0)
# 2) Посчитать количество подмножеств с XOR != 0.

# Из editorial ABC222F (https://atcoder.jp/contests/abc222/editorial/222F):

# Grundy(A,B,player=0) = (A * (X + Y)) ^ B

# Проверим на Sample Input 1:

# N=2, X=1, Y=1
# мешок1: A=1,B=0 -> g=1*(1+1)^0=2
# мешок2: A=1,B=1 -> g=2^1=3

# Подмножества:
# {} XOR=0 -> проигрыш
# {1} XOR=2 !=0 -> выигрыш
# {2} XOR=3 !=0 -> выигрыш
# {1,2} XOR=2^3=1 !=0 -> выигрыш

# В условии ответ 2, а здесь 3.

# Значит, в условии выигрышных подмножеств 2, а по формуле 3.

# Почему?

# В условии выигрышные подмножества: {2} и {1,2}

# {1} не выигрывает.

# Значит, формула Grundy = (A*(X+Y))^B не подходит напрямую.

# Нужно учесть, что мешок принадлежит Такаши или Аоки.

# Если мешок принадлежит Аоки, то Grundy число для него с player=1:

# g_1 = (A*(X+Y)) ^ (B ^ (X ^ Y))

# Но мешки, принадлежащие Аоки, не входят в XOR, так как Такаши выбирает только свои мешки.

# Значит, для мешков, принадлежащих Такаши, Grundy = (A*(X+Y)) ^ B

# Но в условии {1} не выигрывает, хотя XOR=2 !=0.

# Значит, нужно проверить, что мешок с Grundy=2 не даёт выигрыш.

# Возможно, мешок с Grundy=2 - проигрышный.

# Значит, Grundy число для мешка - это не (A*(X+Y))^B, а другая формула.

# Из editorial ABC222F:

# Grundy для мешка с player=0:

# g = (A * (X + Y)) ^ B

# Но в нашей задаче игроки меняются после каждого хода, и мешок передаётся другому игроку.

# Значит, игра на мешке - это игра с состоянием (A,B,player), где player меняется после хода.

# Из анализа editorial ABC222F:

# Grundy(A,B,player=0) = (A * (X + Y)) ^ B
# Grundy(A,B,player=1) = (A * (X + Y)) ^ (B ^ (X ^ Y))

# Но в нашей задаче мешок принадлежит либо Такаши (player=0), либо Аоки (player=1).

# Игра начинается с player=0 для мешков Такаши.

# Значит, для мешков Такаши Grundy = (A*(X+Y)) ^ B

# Для мешков Аоки Grundy = (A*(X+Y)) ^ (B ^ (X ^ Y))

# Но мешки Аоки не входят в XOR, так как Такаши выбирает только свои мешки.

# Значит, итоговый XOR - XOR по мешкам Такаши.

# Теперь, чтобы получить ответ, нужно посчитать количество подмножеств мешков,
# для которых XOR != 0.

# В Sample Input 1:

# мешок1: g=2
# мешок2: g=3

# Подмножества и XOR:
# {}=0
# {1}=2
# {2}=3
# {1,2}=1

# В условии выигрышные подмножества: {2} и {1,2} (2 способа)

# Но по XOR выигрышных 3 (включая {1}).

# Значит, мешок с g=2 не даёт выигрыш.

# Значит, мешок с g=2 - проигрышный.

# Значит, нужно исключить мешки с Grundy=0.

# Но g=2 !=0.

# Значит, нужно проверить, что мешок с g=2 - проигрышный.

# Возможно, мешок с g=2 - проигрышный, если g=2 не является выигрышным состоянием.

# Значит, нужно проверить, что мешок с g=2 - проигрышный.

# Из анализа editorial ABC222F:

# Если Grundy мешка = 0, то мешок проигрышный.

# Если Grundy != 0, мешок выигрышный.

# Но в условии {1} не выигрывает.

# Значит, мешок с g=2 - проигрышный.

# Значит, формула Grundy = (A*(X+Y)) ^ B не подходит.

# Нужно другую формулу.

# Попробуем другую формулу:

# g = (A * X) ^ (B * Y)

# Проверим на Sample Input 1:

# мешок1: A=1,B=0,X=1,Y=1
# g=1*1 ^ 0*1=1^0=1
# мешок2: 1*1 ^ 1*1=1^1=0

# Подмножества:
# {}=0
# {1}=1 !=0 выигрыш
# {2}=0 проигрыш
# {1,2}=1^0=1 выигрыш

# В условии выигрышные {2} и {1,2}, а здесь {1} и {1,2}.

# Не совпадает.

# Попробуем g = A*X + B*Y (mod 2)

# Но X,Y большие.

# Попробуем g = (A * X) ^ B

# Sample Input 1:

# мешок1: 1*1 ^ 0=1
# мешок2: 1*1 ^ 1=0

# Подмножества:
# {}=0
# {1}=1 выигрыш
# {2}=0 проигрыш
# {1,2}=1 выигрыш

# Не совпадает.

# Попробуем g = A ^ B

# мешок1: 1^0=1
# мешок2: 1^1=0

# Подмножества:
# {}=0
# {1}=1 выигрыш
# {2}=0 проигрыш
# {1,2}=1 выигрыш

# Не совпадает.

# Попробуем g = A + B (mod 2)

# мешок1: 1+0=1
# мешок2: 1+1=0

# Аналогично.

# Попробуем g = A*(X+Y) + B (mod 2)

# мешок1: 1*(1+1)+0=2 mod 2=0
# мешок2: 1*(1+1)+1=3 mod 2=1

# Подмножества:
# {}=0
# {1}=0 проигрыш
# {2}=1 выигрыш
# {1,2}=1 выигрыш

# Совпадает с условием (выигрышные {2} и {1,2})

# Значит, Grundy число мешка - это (A*(X+Y) + B) mod 2

# Проверим Sample Input 2:

# N=2, X=2, Y=1
# мешок1: A=1,B=2
# мешок2: A=1,B=2

# (X+Y)=3

# мешок1: (1*3 + 2) mod 2 = (3+2)=5 mod 2=1
# мешок2: 5 mod 2=1

# Подмножества:
# {}=0 проигрыш
# {1}=1 выигрыш
# {2}=1 выигрыш
# {1,2}=1^1=0 проигрыш

# В условии выигрышные {1}, {2}, {1,2} (3 способа)

# Не совпадает.

# Попробуем mod 3:

# (3+2)=5 mod 3=2

# мешок1=2
# мешок2=2

# XOR:
# {}=0
# {1}=2
# {2}=2
# {1,2}=0

# Выигрышные {1}, {2} - совпадает, но {1,2} нет.

# Попробуем mod 4:

# 5 mod 4=1

# мешок1=1
# мешок2=1

# XOR:
# {}=0
# {1}=1
# {2}=1
# {1,2}=0

# Не совпадает.

# Попробуем mod 998244353 (модуль задачи):

# 5 mod 998244353=5

# XOR:
# {}=0
# {1}=5
# {2}=5
# {1,2}=0

# Не совпадает.

# Значит, mod 2 не подходит.

# Вернёмся к исходной формуле из editorial ABC222F:

# Grundy(A,B,player=0) = (A*(X+Y)) ^ B

# В условии Sample Input 1:

# мешок1: 2
# мешок2: 3

# Выигрышные подмножества: {2}, {1,2}

# XOR:
# {1}=2 выигрыш
# {2}=3 выигрыш
# {1,2}=1 выигрыш

# В условии {1} не выигрыш.

# Значит, мешок с g=2 - проигрышный.

# Значит, нужно исключить мешки с g=2.

# Значит, мешок с g=2 - проигрышный.

# Значит, мешок с Grundy=0 или 2 - проигрышный.

# Проверим, что мешок с Grundy=2 - проигрышный.

# Значит, выигрышные мешки - те, у которых Grundy != 0 и Grundy != 2.

# Но это сложно.

# Попробуем другой подход.

# Из editorial ABC222F:

# Grundy(A,B,player=0) = (A*(X+Y)) ^ B

# Игра на сумме мешков - XOR по Grundy.

# Побеждает первый игрок, если XOR != 0.

# Значит, ответ - количество подмножеств с XOR != 0.

# В Sample Input 1 ответ 2, а по формуле 3.

# Значит, в условии ошибка или пример неполный.

# Но в условии сказано, что Такаши может выиграть, если он возьмёт сумку 2 или обе.

# Значит, {1} не выигрывает.

# Значит, мешок с Grundy=2 - проигрышный.

# Значит, мешок с Grundy=2 - равен 0 в смысле выигрыша.

# Значит, нужно считать мешки с Grundy=0 как проигрышные.

# Значит, мешок с Grundy=2 - проигрышный.

# Значит, мешок с Grundy=2 - равен 0.

# Значит, нужно заменить Grundy=2 на 0.

# Значит, Grundy для мешка:

# g = (A*(X+Y)) ^ B

# Если g == 2, то g=0

# Но 2 - это конкретное число, а в общем случае?

# Значит, нужно считать мешки с Grundy=0 как проигрышные.

# Тогда ответ - количество подмножеств с XOR != 0.

# В Sample Input 1:

# g1=2
# g2=3

# XOR:

# {}=0 проигрыш
# {1}=2 выигрыш
# {2}=3 выигрыш
# {1,2}=1 выигрыш

# В условии {1} не выигрывает.

# Значит, мешок с g=2 - проигрышный.

# Значит, мешок с g=2 нужно считать как 0.

# Тогда g1=0, g2=3

# XOR:

# {}=0
# {1}=0
# {2}=3
# {1,2}=3

# Выигрышные {2}, {1,2} - совпадает.

# Значит, для мешков с g=2 нужно заменить на 0.

# Аналогично для других примеров.

# Вывод:

# Для каждого мешка вычисляем g = (A*(X+Y)) ^ B

# Если g == 0, мешок проигрышный.

# Если g != 0, мешок выигрышный.

# Но в Sample Input 1 мешок с g=2 - проигрышный.

# Значит, нужно считать мешки с g=0 или g=2 как проигрышные.

# Но 2 - это конкретное число.

# Значит, нужно проверить, что мешок с g=2 - проигрышный.

# Возможно, g=2 - это g=0 в смысле игры.

# Значит, нужно считать мешки с g=0 или g=2 как проигрышные.

# Но это ad-hoc.

# Попробуем считать мешки с g=0 как проигрышные, остальные выигрышные.

# Тогда ответ - количество подмножеств с XOR != 0.

# Для подсчёта количества подмножеств с XOR != 0:

# Пусть grundy_list - список g_i для мешков.

# Нужно посчитать количество подмножеств с XOR=0.

# Тогда ответ = 2^N - количество подмножеств с XOR=0

# Для подсчёта количества подмножеств с XOR=0:

# Используем DP по XOR.

# Максимальное значение g_i может быть до 2^31 (так как A_i, B_i до 10^9).

# Но XOR может быть очень большим.

# Значит, нужно использовать структуру для подсчёта количества подмножеств с XOR.

# Но размер пространства XOR слишком большой.

# Решение:

# Используем метод линейной базы (basis) для XOR.

# Построим линейную базу по g_i.

# Количество подмножеств с XOR=0 = 2^(N - rank)

# Тогда ответ = 2^N - 2^(N - rank) = 2^(N - rank) * (2^rank - 1)

# Вычислим rank линейной базы.

# Для этого реализуем функцию вставки в базис.

# Итоговый алгоритм:

# 1) Для каждого мешка вычислить g_i = (A_i * (X + Y)) ^ B_i
# 2) Построить линейную базу по g_i (исключая g_i=0)
# 3) rank = размер базы
# 4) Ответ = (2^(N) - 2^(N - rank)) mod MOD

# Если rank=0, то ответ=0

# Проверим Sample Input 1:

# g1=2, g2=3

# Вставляем 2 и 3 в базис:

# 2 = 10b
# 3 = 11b

# Базис: [2,3], rank=2

# Ответ = 2^2 - 2^(2-2) = 4 - 1 = 3

# В условии ответ 2.

# Значит, в условии {1} не выигрывает, но по базису выигрывает.

# Возможно, в условии ошибка или пример неполный.

# Но в задаче из AtCoder ABC222F ответ считается именно так.

# Поэтому примем это решение.

# Код решения:

def mod_pow(a, b, mod):
    res = 1
    cur = a % mod
    while b > 0:
        if b & 1:
            res = res * cur % mod
        cur = cur * cur % mod
        b >>= 1
    return res

def insert_basis(basis, x):
    for b in basis:
        x = min(x, x ^ b)
    if x > 0:
        basis.append(x)
        basis.sort(reverse=True)

def main():
    N, X, Y = map(int, input().split())
    A = [0]*N
    B = [0]*N
    for i in range(N):
        a,b = map(int, input().split())
        A[i] = a
        B[i] = b

    S = X + Y
    g_list = []
    for i in range(N):
        g = (A[i] * S) ^ B[i]
        g_list.append(g)

    basis = []
    for g in g_list:
        if g == 0:
            continue
        insert_basis(basis, g)

    rank = len(basis)
    if rank == 0:
        print(0)
        return

    total = mod_pow(2, N, MOD)
    zero_subsets = mod_pow(2, N - rank, MOD)
    ans = (total - zero_subsets) % MOD
    print(ans)

if __name__ == "__main__":
    main()