MOD = 998244353

def mod_pow(base, exp, mod):
    result = 1
    cur = base % mod
    e = exp
    while e > 0:
        if e & 1:
            result = (result * cur) % mod
        cur = (cur * cur) % mod
        e >>= 1
    return result

def main():
    W, H, L, R, D, U = map(int, input().split())

    # 全区画数 = (W+1)*(H+1)
    total = (W + 1) * (H + 1)

    # 除外される区画は長方形 [L,R] x [D,U]
    # その区画数 = (R - L + 1) * (U - D + 1)
    excluded = (R - L + 1) * (U - D + 1)

    # 有効区画数
    valid = total - excluded

    # すぬけくんの通った経路は、
    # 有効区画の任意の点からスタートし、
    # x軸正方向またはy軸正方向に移動しながら、
    # 有効区画内の点のみを通る経路の数の合計。

    # 重要なポイント:
    # - 移動は x+1 または y+1 のみ
    # - 経路は通った区画の列挙で表される
    # - 経路は0回以上の移動を含む（つまり、1点だけの経路も含む）
    # - 経路の個数は、すべての有効区画を始点として考えたものの合計

    # この問題は、区画が2つの長方形領域に分かれている形状で、
    # それぞれの領域内での経路数を計算し、合計する形で求められる。

    # 区画は以下の2つの領域に分かれる:
    # 1) x < L または x > R の範囲
    # 2) y < D または y > U の範囲
    # ただし、x,yの範囲は0<=x<=W, 0<=y<=H

    # これらの条件は、除外領域 [L,R] x [D,U] を除いた領域である。

    # これを分割して考えると、区画は4つの領域に分かれる:
    # A: x in [0,L-1], y in [0,H]
    # B: x in [R+1,W], y in [0,H]
    # C: x in [L,R], y in [0,D-1]
    # D: x in [L,R], y in [U+1,H]

    # これら4つの領域は互いに接していないため、
    # 経路はそれぞれの領域内で完結する。

    # したがって、経路の総数は4つの領域内の経路数の和。

    # それぞれの領域内の経路数は、
    # 領域内の点数をNとすると、
    # 経路数 = sum_{start in 領域} 2^{(end_x - start_x) + (end_y - start_y)} で
    # すべての終点(end_x,end_y) >= start_x,start_y の点を考慮する。

    # しかし、移動はx,y正方向のみなので、
    # 領域内の点を左下から右上に並べると、
    # 領域内の点数をNとすると、
    # 領域内の経路数 = N * 2^{(幅 - 1) + (高さ - 1)} = N * 2^{幅 +高さ -2}

    # ただし、幅 = x_max - x_min + 1, 高さ = y_max - y_min + 1

    # しかし、これは領域内のすべての経路の数ではなく、
    # 領域内のすべての始点からすべての終点への経路数の合計である。

    # 実際には、領域内の経路数は以下のように計算できる。

    # 領域の幅 = W_i, 高さ = H_i
    # 領域内の点数 = W_i * H_i

    # 領域内の経路数 = sum_{x1=0}^{W_i-1} sum_{y1=0}^{H_i-1} sum_{x2=x1}^{W_i-1} sum_{y2=y1}^{H_i-1} C((x2 - x1) + (y2 - y1), (x2 - x1))
    # ここで、C(n,k)は二項係数で、経路数は右方向に(x2-x1)回、上方向に(y2-y1)回移動する経路数。

    # しかし、これは計算量が大きい。

    # 代わりに、問題の解説や類題から、
    # この問題は以下の式で解けることが知られている。

    # 経路数 = (W+1)*(H+1) * 2^{W+H} - (R-L+1)*(U-D+1)*2^{(R-L)+(U-D)}

    # ただし、これは除外領域を含む経路数を引く形。

    # しかし、問題の条件は「区画が存在する点のみを通る」経路なので、
    # 除外領域の中を通る経路は存在しない。

    # よって、経路数は以下のように計算できる。

    # 経路数 = (全区画数) * 2^{W+H} - (除外区画数) * 2^{(R-L)+(U-D)}

    # ただし、除外区画数 = (R-L+1)*(U-D+1)
    # 2^{W+H} は全区画の最大移動数の経路数
    # 2^{(R-L)+(U-D)} は除外区画の最大移動数の経路数

    # しかし、これは誤り。なぜなら、経路は除外区画を通らず、
    # かつ移動はx,y正方向のみであるため、
    # 除外区画を迂回する経路も存在する。

    # したがって、問題の解法は以下の通り。

    # 区画は2つの領域に分かれる:
    # 左側領域: x in [0,L-1], y in [0,H]
    # 右側領域: x in [R+1,W], y in [0,H]
    # 下側領域: x in [L,R], y in [0,D-1]
    # 上側領域: x in [L,R], y in [U+1,H]

    # これら4つの領域は互いに接していないため、
    # 経路はそれぞれの領域内で完結する。

    # 各領域の幅と高さを計算し、
    # 領域内の経路数を計算して合計する。

    # 領域内の経路数は以下の式で計算可能。

    # 領域の幅 = w, 高さ = h
    # 領域内の点数 = w * h
    # 領域内の経路数 = w * h * 2^{w + h - 2}

    # これは、領域内のすべての点を始点とし、
    # そこから右上方向に移動可能なすべての経路の数の合計。

    # ただし、w=0またはh=0の場合は領域が存在しないので0。

    def region_paths(x1, x2, y1, y2):
        if x2 < x1 or y2 < y1:
            return 0
        w = x2 - x1 + 1
        h = y2 - y1 + 1
        # w*h*2^{w+h-2} mod
        # 2^{w+h-2} は w+h-2 >=0 の場合のみ
        if w == 0 or h == 0:
            return 0
        exp = w + h - 2
        return (w * h * mod_pow(2, exp, MOD)) % MOD

    ans = 0
    # 左側領域
    ans += region_paths(0, L - 1, 0, H)
    # 右側領域
    ans += region_paths(R + 1, W, 0, H)
    # 下側領域
    ans += region_paths(L, R, 0, D - 1)
    # 上側領域
    ans += region_paths(L, R, U + 1, H)

    ans %= MOD
    print(ans)

if __name__ == "__main__":
    main()