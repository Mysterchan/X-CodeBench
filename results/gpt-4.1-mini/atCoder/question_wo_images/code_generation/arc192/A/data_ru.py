import sys
sys.setrecursionlimit(10**7)

def main():
    input = sys.stdin.readline
    N = int(input())
    A = list(map(int, input().split()))

    # Если нет нулей, ответ сразу Yes
    if all(x == 1 for x in A):
        print("Yes")
        return

    # Рассмотрим граф, где вершины - позиции 0..N-1
    # Ребро между i и (i+1)%N, если можно "закрыть" пару (i, i+1)
    # То есть, если A[i] == 0 или A[i+1] == 0, то чтобы их "закрыть",
    # нужна операция на позиции i или i+1 (по условию операции)
    # Но операции возможны только если в строке S есть подстрока ARC или CRA
    # где буквы A,R,C расположены так, что можно "закрыть" пару (i,i+1).
    #
    # В итоге, чтобы закрыть пару (i,i+1), нужно, чтобы в S на позициях i,i+1,i+2
    # была подстрока ARC или CRA (с учетом цикличности).
    #
    # Задача сводится к тому, можно ли раскрасить ребра (i,i+1) в "закрытые"
    # используя операции, которые покрывают пары (i,i+1).
    #
    # Но в условии нет ограничений на S, кроме что она состоит из заглавных букв.
    # Значит, мы можем выбрать S так, чтобы покрыть все пары с A[i]==0.
    #
    # Ключевой момент: операция покрывает пару (i,i+1) если на позициях i,i+1,i+2
    # в S есть ARC или CRA (с цикличностью).
    #
    # Значит, чтобы покрыть пару (i,i+1), нужно, чтобы i,i+1,i+2 образовали такую триаду.
    #
    # Если мы хотим покрыть все пары с A[i]==0, то для каждого i с A[i]==0
    # нужно, чтобы либо триада (i-2,i-1,i) или (i,i+1,i+2) была ARC или CRA.
    #
    # Рассмотрим граф, где ребра - пары (i,i+1) с A[i]==0.
    # Чтобы покрыть ребро (i,i+1), нужно, чтобы i,i+1,i+2 или i-1,i,i+1 образовали триаду ARC или CRA.
    #
    # Это значит, что ребра можно покрыть тройками вершин, каждая тройка - три последовательных позиции,
    # которые покрывают два ребра: (i,i+1) и (i+1,i+2).
    #
    # Таким образом, задача сводится к покрытию всех ребер (i,i+1) с A[i]==0
    # тройками последовательных вершин (i,i+1,i+2) или (i-1,i,i+1).
    #
    # Это классическая задача покрытия ребер циклом тройками.
    #
    # Если в графе есть ребро (i,i+1) с A[i]==0, то оно должно быть покрыто одной из двух тройек:
    # (i-1,i,i+1) или (i,i+1,i+2).
    #
    # Рассмотрим множество ребер с A[i]==0.
    # Если существует ребро, которое нельзя покрыть ни одной тройкой, ответ No.
    #
    # Но так как граф - цикл, и тройки - последовательные тройки вершин,
    # задача сводится к проверке, можно ли покрыть все ребра с A[i]==0 тройками,
    # где каждая тройка покрывает два соседних ребра.
    #
    # Это возможно, если и только если количество ребер с A[i]==0 не превышает N,
    # и они не образуют "непарное" количество подряд идущих ребер без возможности покрыть их тройками.
    #
    # Формально, если мы разбиваем ребра с A[i]==0 на непрерывные цепочки,
    # то каждая цепочка длины L должна покрываться тройками длины 2 ребра,
    # то есть L должно быть кратно 2.
    #
    # Иначе, ответ No.
    #
    # Реализация:
    # - Найти все позиции i, где A[i]==0
    # - Разбить их на непрерывные цепочки по модулю N
    # - Для каждой цепочки проверить, что длина четна
    # - Если все цепочки имеют четную длину, ответ Yes, иначе No

    zero_positions = [i for i, val in enumerate(A) if val == 0]
    if not zero_positions:
        print("Yes")
        return

    # Разбиваем zero_positions на непрерывные цепочки по модулю N
    chains = []
    chain = [zero_positions[0]]
    for i in range(1, len(zero_positions)):
        prev = zero_positions[i-1]
        curr = zero_positions[i]
        if (curr == prev + 1) or (prev == N-1 and curr == 0):
            chain.append(curr)
        else:
            chains.append(chain)
            chain = [curr]
    chains.append(chain)

    # Если первая и последняя цепочки связаны циклично, объединяем их
    if len(chains) > 1:
        first_chain = chains[0]
        last_chain = chains[-1]
        if (first_chain[0] == 0 and last_chain[-1] == N-1):
            # объединяем
            chains[0] = last_chain + first_chain
            chains.pop()

    # Проверяем длину каждой цепочки
    for c in chains:
        if len(c) % 2 != 0:
            print("No")
            return

    print("Yes")

if __name__ == "__main__":
    main()