import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# ゲームの勝者判定は、問題の本質は「Sが{1,...,N}になるまでにどちらが最後に操作するか」。
# 操作は、A_i > 0 の i を選び、A_i を1減らし、iがSに無ければ追加する。
# Sが全ての要素を含むとき終了。

# 重要な点は、Sにiが追加されるのは最初にiを選んだときだけ。
# つまり、各iは最初に選ばれた時点でSに入る。
# その後は何度でもA_iを減らせるが、Sには影響しない。

# ゲーム終了はSが全てのiを含むとき。
# つまり、各iは少なくとも1回は選ばれなければならない。

# 先手フェネック、後手すぬけくんが交互に選ぶ。
# どちらも勝つために最適に行動する。

# ここで、Sにiが追加されるのはiを初めて選んだときだけ。
# つまり、ゲームは「N個の要素を交互に取り合う」ようなもの。
# ただし、A_iの値が大きいほど、そのiを何度も選べる。

# しかし、Sにiが追加されるのは最初の1回だけなので、
# ゲームの勝敗は「どちらが先にN個のiを選び終えるか」に依存する。

# つまり、N個の要素を交互に1回ずつ選ぶゲームと考えられる。

# しかし、どのiを最初に選ぶかは自由。
# つまり、N個の要素を「どちらが先に取るか」の取り合い。

# ここで、A_iの値は「iを何回選べるか」だが、
# 最初の1回目の選択でSにiが追加される。

# つまり、ゲームは「N個の要素を交互に1回ずつ取る」ゲームであり、
# どちらが先にN個の要素を取るかが勝敗を決める。

# 先手が1回目、3回目、5回目...に選ぶので、
# 先手がN個の要素のうちどれだけ多く取れるかが勝敗の鍵。

# しかし、どのiを先に取るかは自由なので、
# 先手はA_iが大きい順にiを取ることができる。

# つまり、A_iを降順に並べて、
# 先手は奇数番目の要素を取り、
# 後手は偶数番目の要素を取る。

# 先手の取り分の合計と後手の取り分の合計を比較し、
# 先手の合計が大きければ先手勝ち、そうでなければ後手勝ち。

# これがこの問題の解法。

A.sort(reverse=True)
fennec_sum = sum(A[::2])
snuke_sum = sum(A[1::2])

if fennec_sum > snuke_sum:
    print("Fennec")
else:
    print("Snuke")