n = int(input())
A = list(map(int, input().split()))

# Идея решения:
# Игроки по очереди выбирают индексы, уменьшая A[i] на 1.
# При первом выборе индекса i он добавляется в множество S.
# Игра заканчивается, когда S = {1, 2, ..., N}.
# Побеждает игрок, сделавший последний ход.

# Ключевой момент:
# Чтобы добавить индекс i в S, нужно выбрать i хотя бы один раз.
# Первый, кто выберет i, добавит его в S.
# После того, как i добавлен, можно выбирать i сколько угодно раз, но это не влияет на S.

# Следовательно, чтобы выиграть, нужно первым добавить последний отсутствующий индекс в S.

# Оптимальная стратегия:
# Игроки будут стараться как можно быстрее добавить индексы с меньшими A[i],
# так как для добавления индекса i нужно сделать хотя бы один ход по i.
# Но ходить можно по любому индексу, у которого A[i] > 0.

# Рассмотрим порядок индексов по возрастанию A[i].
# Игроки по очереди "захватывают" индексы с наименьшим A[i].
# Кто захватит индекс с меньшим A[i], тот быстрее добавит его в S.

# На самом деле, игра сводится к сравнению сумм ходов:
# - Фенек начинает.
# - Если сумма минимальных A[i] для индексов, которые Фенек может "захватить" раньше, меньше суммы для Снука,
#   то Фенек выиграет, иначе Снук.

# Но проще:
# Отсортируем индексы по A[i].
# Игроки по очереди выбирают индексы в отсортированном порядке.
# Первый выбирает индексы с четными позициями в отсортированном списке,
# второй — с нечетными.

# Суммируем A[i] для индексов, которые выбирает Фенек (четные позиции),
# и для индексов, которые выбирает Снук (нечетные позиции).
# Побеждает тот, у кого сумма меньше, т.к. он быстрее "захватит" все свои индексы.

# Однако в условии сказано, что ходить можно по любому индексу с A[i] > 0,
# и что всегда можно сделать ход.
# Но для добавления индекса в S нужно выбрать его хотя бы один раз.
# Значит, игроки будут стараться как можно быстрее добавить индексы с меньшими A[i].

# Итог: отсортируем индексы по A[i], и сравним сумму A[i] на позициях 0,2,4,... и 1,3,5,...
# Если сумма Фенека меньше или равна, выигрывает Фенек, иначе Снук.

# Но в примерах из условия это не всегда работает напрямую.
# Рассмотрим другой подход.

# Рассмотрим минимальный элемент A_min = min(A).
# Если сумма всех A[i] равна S, то игра длится ровно S ходов.
# Последний ход делает игрок, который ходит на S-м ходу.
# Ходы нумеруются с 1, Фенек ходит на нечетных ходах, Снук — на четных.

# Но игра заканчивается, когда S = {1,...,N}, то есть когда каждый индекс был выбран хотя бы один раз.
# Значит, минимальное количество ходов — N (по одному для каждого индекса).
# Но индексы можно выбирать в любом порядке.

# Если сумма A[i] > N, то после того, как все индексы добавлены в S,
# игра заканчивается, и победитель — тот, кто сделал последний ход.

# Значит, игра заканчивается ровно на N-м добавленном индексе.
# Кто сделает N-й ход?

# Фенек ходит 1-й, 3-й, 5-й, ...
# Снук ходит 2-й, 4-й, 6-й, ...

# Если N нечетно — последний ход делает Фенек.
# Если N четно — последний ход делает Снук.

# Но в условии сказано, что можно доказать, что всегда можно сделать ход,
# и игра заканчивается, когда все индексы добавлены в S.

# Однако, если у индекса A[i] = 0, его нельзя выбрать.
# Но по условию A[i] ≥ 1.

# Значит, игра длится ровно N ходов, чтобы добавить все индексы в S,
# и победитель определяется по четности N.

# Проверим на примерах:

# Пример 1:
# N=3 (нечетно) -> Фенек выигрывает (совпадает с примером)

# Пример 2:
# N=2 (четно) -> Снук выигрывает (совпадает с примером)

# Пример 3:
# N=6 (четно) -> Снук выигрывает (совпадает с примером)

# Вывод: победитель определяется по четности N.

if n % 2 == 1:
    print("Fennec")
else:
    print("Snuke")