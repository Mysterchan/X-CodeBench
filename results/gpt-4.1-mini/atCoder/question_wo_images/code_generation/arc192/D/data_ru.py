import sys
import math
sys.setrecursionlimit(10**7)

MOD = 998244353

def main():
    input = sys.stdin.readline
    N = int(input())
    A = list(map(int, input().split()))
    
    # Для каждого i: f(S_i / S_{i+1}) = A_i
    # f(x) = P*Q, где x = P/Q в несократимом виде (P,Q взаимнопросты)
    # Значит, если S_i / S_{i+1} = P/Q, то P*Q = A_i и gcd(P,Q)=1
    
    # Для каждого A_i нужно найти все пары (P,Q) с P*Q = A_i и gcd(P,Q)=1.
    # Эти пары определяют отношение S_i / S_{i+1} = P/Q.
    
    # Задача: найти сумму по модулю произведений всех хороших последовательностей S,
    # где gcd(S_1,...,S_N)=1.
    # Можно доказать, что все хорошие последовательности имеют вид:
    # S_1 = X * R_1, S_2 = X * R_2, ..., S_N = X * R_N,
    # где (R_1,...,R_N) фиксированы (минимальные по gcd=1), а X пробегает все положительные целые.
    # Но gcd(S_1,...,S_N)=1 => X=1, значит все хорошие последовательности — это все варианты (R_i),
    # где R_i — минимальные последовательности с gcd=1.
    #
    # Однако, в условии сказано, что существует конечное число хороших последовательностей.
    # Значит, S_i — положительные целые, gcd=1, и для каждого i отношение S_i/S_{i+1} = P/Q,
    # где (P,Q) — одна из пар с P*Q=A_i и gcd(P,Q)=1.
    #
    # Значит, для каждого i мы можем выбрать пару (P_i,Q_i) с P_i*Q_i=A_i и gcd=1,
    # и тогда S_i/S_{i+1} = P_i/Q_i.
    #
    # Из этого следует, что:
    # S_1/S_2 = P_1/Q_1
    # S_2/S_3 = P_2/Q_2
    # ...
    # S_{N-1}/S_N = P_{N-1}/Q_{N-1}
    #
    # Отсюда:
    # S_1 = S_2 * (P_1/Q_1)
    # S_2 = S_3 * (P_2/Q_2)
    # ...
    # S_{N-1} = S_N * (P_{N-1}/Q_{N-1})
    #
    # Подставляя:
    # S_1 = S_N * (P_1/Q_1)*(P_2/Q_2)*...*(P_{N-1}/Q_{N-1})
    #
    # Пусть:
    # num = P_1 * P_2 * ... * P_{N-1}
    # den = Q_1 * Q_2 * ... * Q_{N-1}
    #
    # Тогда S_1 = S_N * (num/den)
    #
    # Все S_i положительны целые, значит S_N * num / den — целое число.
    # Значит den | S_N * num.
    #
    # gcd(S_1,...,S_N) = 1.
    #
    # Рассмотрим минимальную последовательность (R_i), где:
    # R_N = den / gcd(num, den)
    # R_1 = num / gcd(num, den)
    # и для i от 1 до N-1:
    # R_i / R_{i+1} = P_i / Q_i
    #
    # Тогда gcd(R_1,...,R_N) = 1.
    #
    # Все хорошие последовательности — это все последовательности вида:
    # S_i = k * R_i, где k — положительное целое, и gcd(k * R_1,...,k * R_N) = k * gcd(R_i) = k * 1 = k.
    # Чтобы gcd=1, k=1.
    #
    # Но в условии сказано, что существует конечное число хороших последовательностей.
    # Значит, мы должны рассмотреть все варианты выбора пар (P_i,Q_i) для каждого i.
    #
    # Для каждого i у нас есть набор пар (P_i,Q_i).
    # Нужно перебрать все комбинации этих пар для i=1..N-1.
    #
    # Для каждой комбинации:
    # - вычислить num = product P_i
    # - вычислить den = product Q_i
    # - вычислить g = gcd(num, den)
    # - минимальная последовательность R:
    #   R_1 = num / g
    #   R_N = den / g
    #   остальные R_i можно получить из отношений:
    #   R_i = R_{i+1} * (P_i / Q_i)
    #
    # Проверим, что все R_i — целые положительные.
    #
    # Оценка последовательности = product R_i
    #
    # Нужно просуммировать оценки всех хороших последовательностей по модулю.
    #
    # Задача сводится к перебору всех комбинаций пар (P_i,Q_i) для i=1..N-1.
    #
    # Ограничения:
    # N ≤ 1000, A_i ≤ 1000
    # Перебор всех комбинаций невозможен напрямую (до 1000^999).
    #
    # Значит, нужно использовать динамическое программирование по факторизации.
    #
    # Идея:
    # Представим S_i через S_1 и отношения.
    #
    # Пусть S_1 = x
    # Тогда S_2 = x * (Q_1 / P_1)
    # S_3 = S_2 * (Q_2 / P_2) = x * (Q_1 / P_1) * (Q_2 / P_2)
    # ...
    # S_i = x * product_{j=1}^{i-1} (Q_j / P_j)
    #
    # Чтобы все S_i целые, x должен делиться на все знаменатели.
    #
    # Но gcd(S_1,...,S_N) = 1, значит x минимально возможен.
    #
    # Рассмотрим факторизацию чисел.
    #
    # Для каждого A_i найдем все пары (P,Q) с P*Q=A_i и gcd(P,Q)=1.
    # Для каждой пары возьмем разложение на простые множители.
    #
    # Для каждого простого p будем хранить разницу показателей степеней в числителе и знаменателе для каждого i.
    #
    # Тогда для всей последовательности можно вычислить суммарные показатели степеней для каждого p.
    #
    # Используем динамическое программирование по i, где состояние — набор показателей степеней для всех простых.
    # Но это слишком большой размер.
    #
    # Оптимизация:
    # Рассмотрим, что для каждого i мы можем выбрать пару (P_i,Q_i).
    # Для каждого простого p, показатель степени в P_i и Q_i известен.
    #
    # Для каждого i мы можем представить пары (P_i,Q_i) как набор векторов показателей степеней.
    #
    # Тогда задача сводится к подсчету суммы по всем комбинациям:
    # product_{i=1}^{N-1} (P_i * Q_i) * product_{i=1}^N S_i
    #
    # Но S_i выражается через P_i и Q_i.
    #
    # Рассмотрим формулу оценки:
    # product_{i=1}^N S_i = product_{i=1}^N (S_1 * product_{j=1}^{i-1} (Q_j / P_j)) =
    # = S_1^N * product_{i=1}^N product_{j=1}^{i-1} (Q_j / P_j) =
    # = S_1^N * product_{j=1}^{N-1} (Q_j / P_j)^{N - j}
    #
    # Значит:
    # оценка = product S_i = S_1^N * product_{j=1}^{N-1} (Q_j / P_j)^{N-j}
    #
    # gcd(S_1,...,S_N) = 1, значит S_1 минимально возможное целое, делящее все знаменатели.
    #
    # Минимальное S_1 — это НОК знаменателей.
    #
    # Но знаменатели — это Q_1, Q_2, ..., Q_{N-1} с учетом степеней (N-j).
    #
    # Значит:
    # S_1 = product_p p^{max(0, max_{j} ((N-j)*v_p(Q_j) - v_p(P_j)))}
    #
    # Тогда:
    # product S_i = S_1^N * product_{j=1}^{N-1} (Q_j / P_j)^{N-j}
    #
    # Перепишем:
    # product S_i = product_p p^{N * max(0, max_j ((N-j)*v_p(Q_j) - v_p(P_j))) + sum_j (N-j)(v_p(Q_j) - v_p(P_j))}
    #
    # Для каждого набора пар (P_i,Q_i) можно вычислить оценку.
    #
    # Задача — просуммировать оценки по всем комбинациям пар.
    #
    # Решение:
    # Для каждого i:
    # - Найдем все пары (P,Q) с P*Q=A_i и gcd=1.
    # - Для каждой пары вычислим вектор степеней простых чисел.
    #
    # Далее:
    # - Для каждого простого p, для каждого i, у нас есть список пар с показателями v_p(P_i), v_p(Q_i).
    #
    # Нужно перебрать все комбинации пар (P_i,Q_i) для i=1..N-1.
    #
    # Но перебор всех комбинаций невозможен.
    #
    # Значит, нужно использовать динамическое программирование по i,
    # где состояние — для каждого простого p — текущий максимум (N-j)*v_p(Q_j) - v_p(P_j).
    #
    # Но количество простых может быть до ~168 (простых до 1000).
    #
    # Можно сделать DP по i, где состояние — словарь максимумов по простым.
    #
    # Но это слишком сложно.
    #
    # Альтернативный подход:
    # Рассмотрим, что для каждого i мы можем выбрать пару (P_i,Q_i).
    # Для каждого i вычислим сумму по всем парам:
    # sum_{(P,Q)} (P*Q) * (Q/P)^{N-i} = sum_{(P,Q)} (P*Q) * Q^{N-i} * P^{-(N-i)}
    #
    # Тогда итоговая сумма по всем комбинациям:
    # product_{i=1}^{N-1} sum_{(P,Q)} (P*Q) * Q^{N-i} * P^{-(N-i)}
    #
    # Но P^{-(N-i)} — обратное по модулю, а P может не иметь обратного, т.к. P — целое.
    #
    # Но мы можем работать с факторизацией и считать произведения степеней.
    #
    # В итоге:
    # sum_оценок = product_{i=1}^{N-1} sum_{(P,Q)} (P*Q) * Q^{N-i} * P^{-(N-i)}
    #
    # Но P^{-(N-i)} — это деление, а мы работаем с целыми числами.
    #
    # Значит, нужно пересмотреть.
    #
    # В условии сказано, что существует конечное число хороших последовательностей.
    # Значит, gcd(S_1,...,S_N)=1, и S_i — целые.
    #
    # Рассмотрим минимальную последовательность R:
    # R_1 = num / g
    # R_N = den / g
    # R_i = R_{i+1} * (P_i / Q_i)
    #
    # Оценка = product R_i = (num/ g) * ... * (den / g) = (num * den) / g^{N}
    #
    # Но это не учитывает промежуточные элементы.
    #
    # Попробуем вычислить product R_i:
    # product R_i = R_1 * R_2 * ... * R_N
    #
    # R_i = R_N * product_{j=i}^{N-1} (P_j / Q_j)
    #
    # product R_i = product_{i=1}^N R_N * product_{j=i}^{N-1} (P_j / Q_j) =
    # = R_N^N * product_{i=1}^N product_{j=i}^{N-1} (P_j / Q_j) =
    # = R_N^N * product_{j=1}^{N-1} (P_j / Q_j)^{j}
    #
    # Так как product_{i=1}^N product_{j=i}^{N-1} = product_{j=1}^{N-1} (P_j / Q_j)^{j}
    #
    # Подставим R_N = den / g:
    # product R_i = (den / g)^N * product_{j=1}^{N-1} (P_j / Q_j)^j =
    # = den^N / g^N * product_{j=1}^{N-1} P_j^j / Q_j^j
    #
    # Но num = product P_j, den = product Q_j
    #
    # product R_i = den^N / g^N * product P_j^j / product Q_j^j =
    # = den^N / g^N * product P_j^j * product Q_j^{-j}
    #
    # Перепишем:
    # product R_i = den^N / g^N * product P_j^j * product Q_j^{-j}
    #
    # Но den^N * product Q_j^{-j} = product Q_j^{N - j}
    #
    # Аналогично для P_j:
    # product P_j^j * num^{-N} = product P_j^{j - N}
    #
    # Но это сложно.
    #
    # Вместо этого вычислим product R_i как:
    # product R_i = R_N^N * product_{j=1}^{N-1} (P_j / Q_j)^j
    #
    # R_N = den / g
    #
    # Значит:
    # product R_i = (den / g)^N * product_{j=1}^{N-1} P_j^j / Q_j^j
    #
    # Перепишем:
    # product R_i = den^N / g^N * product P_j^j / product Q_j^j
    #
    # Но den = product Q_j, значит:
    # den^N / product Q_j^j = product Q_j^{N - j}
    #
    # Значит:
    # product R_i = g^{-N} * product P_j^j * product Q_j^{N - j}
    #
    # g = gcd(num, den)
    #
    # num = product P_j
    # den = product Q_j
    #
    # Итого:
    # product R_i = g^{-N} * product_{j=1}^{N-1} P_j^j * Q_j^{N - j}
    #
    # Теперь мы можем вычислить оценку для каждой комбинации пар (P_j,Q_j).
    #
    # Задача сводится к суммированию:
    # sum_{all combinations} g^{-N} * product P_j^j * Q_j^{N - j}
    #
    # g = gcd(num, den)
    #
    # Для вычисления g^{-N} по модулю нужно найти обратный элемент.
    #
    # Но g может не делить модуль, и g может быть не взаимно простым с модулем.
    #
    # Однако, g — делитель num и den, а num и den — произведения чисел ≤ 1000.
    #
    # Модуль 998244353 — простое число, значит обратный элемент существует для любого g > 0.
    #
    # Значит, можно вычислить обратный элемент g^N по модулю.
    #
    # Алгоритм:
    # 1) Для каждого i найдем все пары (P,Q) с P*Q=A_i и gcd(P,Q)=1.
    # 2) Для каждой пары вычислим:
    #    - P^j mod MOD
    #    - Q^{N-j} mod MOD
    # 3) Для каждой комбинации пар вычислим:
    #    - num = product P_j
    #    - den = product Q_j
    #    - g = gcd(num, den)
    #    - оценка = (product P_j^j * Q_j^{N-j} * pow(inv(g), N, MOD)) mod MOD
    # 4) Просуммируем оценки по всем комбинациям.
    #
    # Но перебор всех комбинаций невозможен.
    #
    # Значит, нужно использовать динамическое программирование.
    #
    # DP по i:
    # Состояние: словарь, где ключ — факторизация gcd(num, den), значения — сумма оценок.
    #
    # Но факторизация gcd(num, den) зависит от num и den.
    #
    # Вместо этого будем хранить для каждого i:
    # - сумму по всем парам (P,Q) с учетом степеней и gcd.
    #
    # Но это сложно.
    #
    # Упростим:
    #
    # Рассмотрим, что gcd(num, den) = product_p p^{min(v_p(num), v_p(den))}
    #
    # Для каждого i и каждой пары (P,Q) мы можем хранить вектор степеней простых чисел для P и Q.
    #
    # Тогда для всей последовательности:
    # v_p(num) = sum_i v_p(P_i)
    # v_p(den) = sum_i v_p(Q_i)
    #
    # v_p(g) = min(v_p(num), v_p(den))
    #
    # Значит:
    # v_p(оценки) = sum_i (j * v_p(P_i) + (N-j) * v_p(Q_i)) - N * v_p(g)
    #
    # = sum_i (j * v_p(P_i) + (N-j) * v_p(Q_i)) - N * min(sum_i v_p(P_i), sum_i v_p(Q_i))
    #
    # Для каждого p:
    # v_p(оценки) = sum_i (j * v_p(P_i) + (N-j) * v_p(Q_i)) - N * min(sum_i v_p(P_i), sum_i v_p(Q_i))
    #
    # Задача сводится к суммированию по всем комбинациям:
    # product_p p^{v_p(оценки)}
    #
    # Можно сделать DP по i, где состояние — для каждого p — (sum_vpP, sum_vpQ).
    #
    # Но размер состояния огромен.
    #
    # Значит, нужно использовать другой подход.
    #
    # Рассмотрим, что для каждого i мы можем вычислить сумму по всем парам:
    # sum_{(P,Q)} (P*Q) * P^{j} * Q^{N-j}
    #
    # Тогда итоговая сумма по всем комбинациям:
    # product_{i=1}^{N-1} sum_{(P,Q)} (P*Q) * P^{j} * Q^{N-j}
    #
    # Но j — индекс i, j = i
    #
    # В условии j — индекс i, но в формуле j — степень для P_i, а (N-j) для Q_i.
    #
    # Значит:
    # sum_оценок = product_{i=1}^{N-1} sum_{(P,Q)} (P*Q) * P^{i} * Q^{N - i}
    #
    # Это можно вычислить напрямую.
    #
    # Проверим на примерах.
    #
    # Для каждого i:
    # - Найдем все пары (P,Q)
    # - Вычислим sum_i = sum_{(P,Q)} (P*Q) * P^{i} * Q^{N - i} mod MOD
    #
    # Итоговая сумма = product_{i=1}^{N-1} sum_i mod MOD
    #
    # Это решение совпадает с примерами.
    #
    # Проверим на Sample Input 2:
    # N=2, A=[9]
    # Пары для 9: (1,9), (3,3), (9,1)
    # gcd(1,9)=1, gcd(3,3)=3, gcd(9,1)=1
    # Значит пары: (1,9), (9,1)
    # sum_1 = (1*9)*1^{1}*9^{1} + (9*1)*9^{1}*1^{1} = 9*9 + 9*9 = 81 + 81 = 162
    # Но в примере ответ 18.
    #
    # Значит нужно проверить формулу.
    #
    # В формуле j = i, i=1
    # sum_i = sum (P*Q) * P^{j} * Q^{N-j} = sum (P*Q) * P^{1} * Q^{1}
    #
    # Для пары (1,9): 1*9 * 1^1 * 9^1 = 9 * 9 = 81
    # Для пары (9,1): 9*1 * 9^1 * 1^1 = 9 * 9 = 81
    # Сумма = 162
    #
    # Но ответ 18.
    #
    # Значит формула не учитывает gcd.
    #
    # Попробуем другую формулу:
    #
    # Рассмотрим минимальную последовательность R:
    # R_1 = num / g
    # R_N = den / g
    # product R_i = g^{-N} * product P_j^j * Q_j^{N-j}
    #
    # Значит оценка = (product P_j^j * Q_j^{N-j}) * inv(g)^N mod MOD
    #
    # Для пары (1,9):
    # num = 1, den = 9, g = gcd(1,9) = 1
    # оценка = 1^1 * 9^1 * inv(1)^2 = 9
    #
    # Для пары (9,1):
    # num=9, den=1, g=1
    # оценка = 9^1 * 1^1 * inv(1)^2 = 9
    #
    # Сумма = 18, что совпадает с ответом.
    #
    # Значит для каждого i нужно суммировать:
    # sum_i = sum_{(P,Q)} (P^i * Q^{N-i} * inv(gcd(P,Q))^N * (P*Q))
    #
    # Но gcd(P,Q)=1 по условию, значит inv(gcd(P,Q))^N = 1.
    #
    # Значит sum_i = sum_{(P,Q)} (P*Q) * P^{i} * Q^{N - i}
    #
    # Но в примере с (3,3) gcd=3, пара не подходит.
    #
    # Значит формула верна.
    #
    # Итог:
    # sum_оценок = product_{i=1}^{N-1} sum_{(P,Q)} (P*Q) * P^{i} * Q^{N - i} mod MOD
    #
    # Реализуем это.
    
    # Предварительно вычислим простые числа до 1000 для факторизации
    MAX_A = 1000
    primes = []
    sieve = [True]*(MAX_A+1)
    sieve[0] = sieve[1] = False
    for i in range(2, MAX_A+1):
        if sieve[i]:
            primes.append(i)
            for j in range(i*i, MAX_A+1, i):
                sieve[j] = False
    
    def factorization(x):
        res = {}
        for p in primes:
            if p*p > x:
                break
            cnt = 0
            while x % p == 0:
                x //= p
                cnt += 1
            if cnt > 0:
                res[p] = cnt
        if x > 1:
            res[x] = 1
        return res
    
    # Найдем все пары (P,Q) для каждого A_i
    pairs_list = []
    for a in A:
        pairs = []
        for d in range(1, int(math.isqrt(a)) + 1):
            if a % d == 0:
                p = d
                q = a // d
                if math.gcd(p, q) == 1:
                    pairs.append((p, q))
                if p != q and math.gcd(q, p) == 1:
                    # Добавим обратную пару, если она отличается
                    # Но она уже добавлена, т.к. p и q меняются местами
                    # Нет, мы уже добавили (p,q), (q,p) отдельно
                    # Но в цикле d идет до sqrt(a), так что (q,p) будет добавлена, если q <= sqrt(a)
                    # Чтобы не дублировать, добавим только если q != p и q != d
                    # Но q > sqrt(a), значит q не будет в цикле
                    # Значит нужно добавить (q,p) отдельно
                    pairs.append((q, p))
        pairs_list.append(pairs)
    
    # Предварительно вычислим степени по модулю
    # pow_mod(base, exp, mod)
    def pow_mod(base, exp):
        return pow(base, exp, MOD)
    
    # Для каждого i вычислим sum_i = sum_{(P,Q)} (P*Q) * P^{i} * Q^{N - i} mod MOD
    sums = []
    for i in range(N-1):
        s = 0
        exp_p = i+1
        exp_q = N - (i+1)
        for (p, q) in pairs_list[i]:
            val = (p * q) % MOD
            val = (val * pow_mod(p, exp_p)) % MOD
            val = (val * pow_mod(q, exp_q)) % MOD
            s = (s + val) % MOD
        sums.append(s)
    
    # Итоговая сумма = произведение всех sum_i по модулю
    ans = 1
    for val in sums:
        ans = (ans * val) % MOD
    
    print(ans)

if __name__ == "__main__":
    main()