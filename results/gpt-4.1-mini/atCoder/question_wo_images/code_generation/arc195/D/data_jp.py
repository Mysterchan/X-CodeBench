import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N = int(input())
    A = list(map(int, input().split()))

    # 連続する同じ値の塊（ブロック）に分ける
    blocks = []
    prev = None
    for v in A:
        if v != prev:
            blocks.append(1)
            prev = v
        else:
            blocks[-1] += 1

    # ブロック数
    M = len(blocks)

    # 操作の最小回数は、ブロック数 - 1 + 1 = ブロック数
    # なぜなら、隣接交換で同じ値のブロックをまとめてから削除する操作を繰り返すため
    # ただし、隣接交換はブロック数-1回で全て同じ値のブロックを連結できる
    # その後、削除操作はブロック数回必要
    # しかし、削除操作は各ブロックごとに1回ずつ行うので、合計はブロック数回
    # 交換操作はブロック数-1回
    # 合計 = (ブロック数-1) + ブロック数 = 2*ブロック数 -1
    # しかし、問題の例から、実際は交換操作はブロック数-1回、削除操作はブロック数回で合計はブロック数 + (ブロック数-1) = 2*ブロック数 -1
    # だが、サンプルの1つ目はブロック数=4(1,1),(2),(1),(2)で操作回数3なので違う
    # よって、交換操作は必要な分だけでよく、削除操作はブロック数回必要
    # 交換操作は隣接ブロックの値を揃えるために必要な最小回数
    # しかし、交換操作は隣接ブロックの値を揃えるために必要な最小回数はブロック数-1回
    # つまり、最小操作回数はブロック数-1(交換) + ブロック数(削除) = 2*ブロック数 -1
    # しかし、サンプルと合わないので別の考え方をする

    # 別の考え方：
    # 操作2は先頭の連続した同じ値の塊を削除できる
    # 操作1は隣接交換で並び替え可能
    # つまり、任意の順番で隣接交換を行い、同じ値の塊を先頭にまとめて削除を繰り返す
    # したがって、最小操作回数は「異なる値の塊の数」-1（交換回数） + 「削除回数」
    # 削除回数は塊の数
    # 合計は塊の数 + (塊の数 -1) = 2*塊の数 -1
    # しかし、サンプル1は塊の数4で3回なので違う

    # さらに考察：
    # 操作1は隣接交換で任意の並び替えが可能
    # 操作2は先頭の連続した同じ値の塊を削除
    # つまり、任意の順番で並び替え可能なので、全ての同じ値をまとめてから削除すればよい
    # その場合、削除回数は「異なる値の種類数」
    # 交換回数は「異なる値の種類数 -1」
    # 合計は「2 * 異なる値の種類数 -1」
    # しかし、サンプル2は異なる値の種類数4で4回なので違う

    # サンプル2は (4,2,1,3)
    # 異なる値の種類数4
    # 操作回数4
    # 交換操作は0回（並び替えしなくても削除できる）
    # 削除操作は4回（1つずつ削除）
    # 合計4回

    # つまり、交換操作は必須ではない
    # 交換操作は削除回数を減らすために使う
    # したがって、最小操作回数は「削除回数 + 交換回数」
    # 削除回数は「削除操作の回数」
    # 交換回数は「隣接交換の回数」

    # ここで、塊の数は「連続する同じ値の塊の数」
    # 交換操作で塊をまとめることができる
    # まとめるための交換回数は塊の数 - 1
    # 削除回数はまとめた塊の数（=異なる値の種類数）

    # しかし、サンプル1は塊の数4、異なる値の種類数2
    # 操作回数3
    # 交換回数1（3番目と4番目を入れ替え）
    # 削除回数2
    # 合計3

    # つまり、最小操作回数 = (塊の数 - 異なる値の種類数) + 異なる値の種類数 = 塊の数

    # よって、最小操作回数は「連続する同じ値の塊の数」

    print(len(blocks))