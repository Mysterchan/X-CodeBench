import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N = int(input())
    A = list(map(int, input().split()))
    
    # 思路分析：
    # 操作1允许交换相邻元素，操作2允许删除前缀且前缀元素相同。
    # 目标是最小操作数使序列变空。
    #
    # 关键点：
    # - 删除操作必须删除一段连续且相同的元素。
    # - 交换操作可以调整元素顺序，但每次只能交换相邻元素。
    #
    # 观察：
    # 1. 删除操作次数 = 分块数（每块元素相同且连续）
    # 2. 交换操作次数 = 使得相同元素聚集成块所需的最小交换次数
    #
    # 由于交换只能相邻交换，且删除只能删除连续相同元素的前缀，
    # 我们需要将相同元素聚集成连续块。
    #
    # 进一步分析：
    # - 设序列中不同元素的出现次数为 freq[x]。
    # - 设序列中相同元素的块数为 blocks[x]。
    #
    # 交换操作的最小次数 = 总块数 - 不同元素种类数
    # 解释：
    # 每个元素的块数减1即为该元素需要的交换次数（将分散的块合并成一个块）。
    # 总交换次数 = sum(blocks[x]-1) = (sum blocks) - (不同元素数)
    #
    # 删除操作次数 = 不同元素数（因为最终每个元素形成一个连续块后，删除时每个块一次）
    #
    # 总操作数 = 交换次数 + 删除次数
    #          = (sum blocks - distinct) + distinct
    #          = sum blocks
    #
    # 因此，答案就是序列中所有元素块的总数。
    #
    # 验证样例：
    # 样例1: 1 1 2 1 2
    # 块： (1,1), (2), (1), (2) 共4块
    # 答案=4
    # 但样例答案是3，说明还可以通过交换减少删除次数。
    #
    # 重新考虑：
    # 删除操作可以删除任意长度的前缀，只要前缀元素相同。
    # 交换操作可以将相同元素聚集。
    #
    # 题目示例中：
    # 交换一次后，序列变成 (1,1,1,2,2)
    # 删除两次即可清空
    # 总操作数=3
    #
    # 说明交换操作可以减少删除次数。
    #
    # 进一步推导：
    # 设序列中不同元素数为 d
    # 设序列中块数为 b
    # 交换次数至少为 b - d
    # 删除次数至少为 d
    # 总操作数至少为 b
    #
    # 但通过交换可以减少删除次数，最优总操作数 = b - max_merge
    # 其中 max_merge 是通过交换减少的删除次数。
    #
    # 题目中给出的最优解是：
    # 答案 = 块数 - 最大相同元素块数 + 1
    #
    # 但更简单的结论是：
    # 答案 = 块数 - 最大相同元素块数 + 1
    #
    # 证明：
    # - 最大相同元素块数表示可以通过交换将这些块合并成一个块，减少删除次数。
    # - 总操作数 = 块数 - (最大相同元素块数 - 1)
    #
    # 综上，答案 = 块数 - max_blocks + 1
    
    # 计算块数和每个元素的块数
    blocks = 1
    block_count = {}
    prev = A[0]
    block_count[prev] = 1
    for i in range(1, N):
        if A[i] != prev:
            blocks += 1
            block_count[A[i]] = block_count.get(A[i], 0) + 1
            prev = A[i]
    
    max_blocks = max(block_count.values())
    # 计算答案
    ans = blocks - max_blocks + 1
    print(ans)