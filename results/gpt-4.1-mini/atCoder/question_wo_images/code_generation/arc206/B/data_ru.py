import sys
input = sys.stdin.readline

N = int(input())
P = list(map(int, input().split()))
C = list(map(int, input().split()))

# Идея решения:
# Чтобы последовательность была "хорошей", нужно, чтобы можно было отсортировать слаймы по возрастанию P,
# меняя местами только соседних слаймов разных цветов.
# Это значит, что внутри каждого цвета порядок слаймов по P должен быть уже отсортирован,
# иначе мы не сможем переставить слаймы одного цвета, так как обмен разрешён только между слаймами разных цветов.
#
# Следовательно, для каждого цвета слаймы должны идти в порядке возрастания P.
# Если для какого-то цвета порядок P не возрастание, нужно изменить цвет некоторых слаймов,
# чтобы "сломать" этот порядок и сделать последовательность корректной.
#
# Задача сводится к минимизации стоимости изменения цветов, чтобы внутри каждого цвета
# последовательность P была строго возрастающей.
#
# Подход:
# - Рассмотрим слаймы в порядке возрастания P (т.е. отсортируем по P).
# - Для каждого слайма в этом порядке будем пытаться "собрать" максимальную по сумме стоимости
#   подпоследовательность с одинаковым цветом, где P строго возрастают (т.к. мы идём по возрастанию P,
#   достаточно, чтобы цвета совпадали).
# - Тогда минимальная стоимость изменения цветов = сумма всех цветов - максимальная сумма цветов
#   подпоследовательности с возрастающим P и одинаковым цветом.
#
# Но цвета могут повторяться, и нам нужно максимизировать сумму цветов в подпоследовательности,
# где цвета одинаковы и индексы P возрастают.
#
# Переформулируем:
# - Отсортируем слаймы по P.
# - Для каждого цвета c будем хранить максимальную сумму стоимости (цвета) подпоследовательности,
#   заканчивающейся на слайме с цветом c.
# - Для каждого слайма i в порядке возрастания P:
#   dp[c_i] = max(dp[c_i], dp[c_i] + c_i) ??? Нет, так не работает.
#
# Но в условии стоимость изменения цвета равна x — цвет слайма перед операцией.
# Значит, если мы не меняем цвет слайма, то стоимость 0.
# Если меняем цвет, то платим цвет, который был у слайма до изменения.
#
# Значит, чтобы минимизировать стоимость, нужно максимизировать количество слаймов,
# которые не меняют цвет и при этом последовательность внутри цвета строго возрастающая по P.
#
# Иначе говоря, нужно найти максимальную по сумме цветов подпоследовательность,
# где цвета не меняются и P возрастают.
#
# Но P уникальны, и мы идём по возрастанию P, значит порядок P уже гарантирован.
# Значит, задача сводится к поиску максимальной суммы цветов для подпоследовательности,
# где цвета одинаковы.
#
# Но цвета могут меняться, и мы можем менять цвет слайма на любой.
# Чтобы не платить за изменение, лучше оставить цвет слайма как есть.
#
# Значит, нам нужно найти максимальную сумму цветов для подпоследовательности,
# где цвета одинаковы и индексы идут по возрастанию P (т.е. просто максимальная сумма цветов
# для каждого цвета).
#
# Тогда минимальная стоимость = сумма всех цветов - максимальная сумма цветов для какого-то цвета.
#
# Но в условии стоимость изменения равна цвету слайма до изменения, а не цвету, в который меняем.
# Значит, если мы меняем цвет слайма, платим цвет, который был у слайма.
#
# Значит, чтобы минимизировать стоимость, нужно максимизировать сумму цветов слаймов,
# которые не меняем (оставляем их цвет).
#
# И при этом последовательность должна быть "хорошей", т.е. внутри каждого цвета P строго возрастают.
#
# Но P уникальны, и мы идём по возрастанию P, значит порядок P уже возрастающий.
# Значит, если мы выберем слаймы с одним цветом, то они уже идут в порядке возрастания P.
#
# Значит, задача сводится к поиску максимальной суммы цветов для подпоследовательности,
# где цвета одинаковы.
#
# Но слаймы идут в порядке P, значит подпоследовательность с одним цветом — это просто сумма цветов
# слаймов с этим цветом.
#
# Значит, минимальная стоимость = сумма всех цветов - максимальная сумма цветов для какого-то цвета.
#
# Проверим на примерах:
# Sample Input 1:
# N=4
# P=[3,1,2,4]
# C=[1,2,1,3]
# Сумма цветов = 1+2+1+3=7
# Суммы по цветам:
# цвет 1: слаймы 1 и 3 (P=3 и 2) => сумма цветов = 1+1=2
# цвет 2: слайм 2 (P=1) => 2
# цвет 3: слайм 4 (P=4) => 3
# Максимум = 3
# Ответ = 7-3=4, но в примере ответ 1.
#
# Значит, подход неверен.
#
# Ошибка: мы не можем просто взять все слаймы одного цвета, т.к. внутри цвета порядок P должен быть строго возрастающим.
# В примере 1 слаймы цвета 1 идут в порядке P=3 и P=2, что не возрастающее.
#
# Значит, внутри цвета нужно найти максимальную по сумме подпоследовательность с возрастающим P.
#
# Поскольку P уникальны, и мы идём по возрастанию P, то подпоследовательность с возрастающим P — это просто
# подпоследовательность слаймов с одинаковым цветом, выбранных в порядке возрастания P.
#
# Значит, для каждого цвета нужно найти максимальную сумму цветов подпоследовательности с этим цветом,
# где индексы идут по возрастанию P.
#
# Но P уникальны и мы уже отсортировали по P, значит для каждого цвета нужно найти максимальную сумму
# подпоследовательности с этим цветом.
#
# Но цвета могут повторяться, и мы можем менять цвет слайма.
#
# Значит, нам нужно найти максимальную сумму цветов подпоследовательности,
# где цвета не меняются и P возрастают.
#
# Но мы можем менять цвет слайма, платя цвет слайма до изменения.
#
# Значит, если мы хотим получить хорошую последовательность, мы можем сгруппировать слаймы по цветам,
# внутри каждого цвета порядок P должен быть возрастающим.
#
# Если порядок P внутри цвета не возрастающий, нужно изменить цвет некоторых слаймов,
# платя их исходный цвет.
#
# Значит, задача сводится к поиску максимальной суммы цветов подпоследовательности,
# где цвета одинаковы и P возрастают.
#
# Тогда минимальная стоимость = сумма всех цветов - максимальная сумма цветов такой подпоследовательности.
#
# Для решения:
# - Отсортируем слаймы по P.
# - Для каждого слайма i в порядке возрастания P:
#   dp[c_i] = max(dp[c_i], dp[c_i] + c_i) ??? Нет, нужно аккумулировать сумму цветов для цвета c_i.
#
# Но цвета могут повторяться, и мы можем менять цвет слайма.
#
# Значит, для каждого слайма i:
# dp[c_i] = max(dp[c_i], max_dp + c_i), где max_dp — максимальное значение dp для всех цветов, кроме c_i.
#
# Но это сложно.
#
# Другой подход:
# - Для каждого слайма i в порядке возрастания P:
#   dp[c_i] = max(dp[c_i], max_dp + c_i)
#   где max_dp — максимальное значение dp среди всех цветов.
#
# Но это не учитывает, что мы не можем менять цвет слайма без оплаты.
#
# В условии операция обмена разрешена только между соседними слаймами разных цветов.
# Значит, чтобы отсортировать по P, нужно, чтобы внутри каждого цвета порядок P был возрастающим.
#
# Значит, если мы изменим цвет слайма, то платим цвет слайма до изменения.
#
# Значит, чтобы минимизировать стоимость, нужно максимизировать сумму цветов слаймов,
# которые не меняем, и которые образуют подпоследовательность с возрастающим P внутри цвета.
#
# Значит, для каждого цвета нужно найти максимальную сумму цветов подпоследовательности с этим цветом,
# где P возрастают.
#
# Поскольку P уникальны и мы идём по возрастанию P, для каждого цвета просто нужно найти
# максимальную сумму цветов подряд идущих слаймов с этим цветом.
#
# Но слаймы с одним цветом могут быть разбросаны.
#
# Значит, для каждого цвета нужно найти максимальную сумму цветов подпоследовательности с этим цветом.
#
# Это задача о поиске максимальной суммы подпоследовательности с фиксированным цветом.
#
# Решение:
# - Отсортируем слаймы по P.
# - Для каждого цвета будем хранить dp[c] — максимальную сумму цветов подпоследовательности с цветом c.
# - Итерируемся по слаймам в порядке возрастания P:
#   dp[c_i] = max(dp[c_i] + c_i, c_i)
#
# Но это не учитывает, что подпоследовательность должна быть строго возрастающей по P,
# а мы уже идём по возрастанию P, значит порядок гарантирован.
#
# Значит, для каждого цвета dp[c] = dp[c] + c_i (если dp[c] > 0) или c_i (если dp[c] == 0).
#
# В итоге максимальное dp[c] по всем цветам — максимальная сумма цветов подпоследовательности с одним цветом.
#
# Тогда ответ = сумма всех цветов - max(dp[c])
#
# Проверим на Sample Input 1:
# P: 3 1 2 4
# C: 1 2 1 3
# Отсортируем по P:
# P: 1 2 3 4
# C: 2 1 1 3
# dp:
# i=0, c=2: dp[2] = 0+2=2
# i=1, c=1: dp[1] = 0+1=1
# i=2, c=1: dp[1] = 1+1=2
# i=3, c=3: dp[3] = 0+3=3
# max dp = 3
# sum colors = 1+2+1+3=7
# answer = 7-3=4, а в примере 1
#
# Значит, подход не учитывает, что внутри цвета порядок P должен быть строго возрастающим.
# В примере слаймы цвета 1 идут в порядке P=2 и P=3, что уже возрастающий порядок.
# Значит, мы можем оставить их цветами.
#
# Но в исходном порядке цвета 1 идут в позициях 1 и 3 (P=3 и P=2), что не возрастающий порядок.
#
# Значит, нужно рассматривать исходный порядок, а не отсортированный.
#
# Но операция обмена разрешена только между соседними слаймами разных цветов.
# Значит, чтобы отсортировать по P, внутри каждого цвета порядок слаймов должен быть уже возрастающим.
#
# Значит, если внутри цвета порядок P не возрастающий, нужно изменить цвет некоторых слаймов,
# платя их исходный цвет.
#
# Значит, задача сводится к поиску минимальной суммы цветов слаймов, которые нужно перекрасить,
# чтобы внутри каждого цвета порядок P был возрастающим.
#
# Это задача о минимальном удалении элементов из каждой цветовой последовательности,
# чтобы она стала строго возрастающей по P.
#
# Решение:
# - Для каждого цвета выделим последовательность P_i в порядке исходного расположения.
# - Найдем длину максимальной строго возрастающей подпоследовательности (LIS) по P_i для этого цвета.
# - Тогда количество слаймов, которые нужно перекрасить в этом цвете = длина последовательности цвета - LIS.
# - Стоимость перекраски этих слаймов = сумма цветов этих слаймов.
#
# Но мы можем менять цвет слайма на любой, значит лучше перекрасить слаймы, которые мешают порядку.
#
# Значит, минимальная стоимость = сумма цветов слаймов, которые нужно перекрасить,
# чтобы внутри каждого цвета порядок P был строго возрастающим.
#
# Но мы можем перекрасить слаймы в любой цвет, значит лучше перекрасить слаймы,
# которые мешают порядку внутри цвета.
#
# Значит, для каждого цвета:
# - Найдем LIS по P_i в порядке исходного расположения.
# - Сумма цветов слаймов этого цвета - сумма цветов слаймов, входящих в LIS = стоимость перекраски для этого цвета.
#
# Итоговая минимальная стоимость = сумма всех цветов - сумма цветов всех LIS по цветам.
#
# Реализация:
# - Для каждого цвета соберём список (индекс, P_i, цвет_i).
# - Отсортируем по индексу (исходному порядку).
# - Найдём LIS по P_i.
# - Суммируем цвета слаймов, входящих в LIS.
# - Суммируем по всем цветам.
# - Ответ = сумма всех цветов - сумма цветов LIS по всем цветам.
#
# LIS по P_i с учётом сумм цветов:
# - Для каждого цвета:
#   - Получаем последовательность P_i и соответствующие цвета.
#   - Найдём LIS по P_i.
#   - Для LIS нужно максимизировать сумму цветов.
#
# Для LIS с максимальной суммой:
# - Используем классический алгоритм LIS с бинарным поиском,
#   но вместо длины храним максимальную сумму цветов.
#
# Сложность: O(N log N)

from bisect import bisect_left

color_positions = dict()
color_values = dict()
total_sum = 0

for i in range(N):
    c = C[i]
    if c not in color_positions:
        color_positions[c] = []
        color_values[c] = []
    color_positions[c].append(i)
    color_values[c].append(P[i])
    total_sum += c

def max_sum_LIS(arr, vals):
    # arr - последовательность P_i в порядке исходного расположения
    # vals - цвета слаймов (стоимости)
    # Найти LIS по arr с максимальной суммой vals
    import bisect
    dp = []  # dp[i] = максимальная сумма vals для LIS длины i+1
    for i in range(len(arr)):
        x = arr[i]
        v = vals[i]
        # Найдём позицию для x в dp по возрастанию
        # Для LIS по возрастанию используем bisect_left
        pos = bisect.bisect_left([arr[j] for j in range(len(dp))], x) if dp else 0
        # Но dp хранит суммы, а не элементы arr
        # Нужно хранить пары (x, sum)
        # Перепишем:
    # Перепишем с хранением пар (x, sum)
    dp = []
    for i in range(len(arr)):
        x = arr[i]
        v = vals[i]
        # Найдём позицию для x в dp по возрастанию x
        # dp хранит пары (x, sum)
        # Нужно найти позицию для x в dp по x
        # Используем bisect_left по x
        pos = bisect.bisect_left(dp, (x, -1))
        curr_sum = v
        if pos > 0:
            curr_sum += dp[pos-1][1]
        if pos == len(dp):
            dp.append((x, curr_sum))
        elif dp[pos][1] < curr_sum:
            dp[pos] = (x, curr_sum)
    if dp:
        return dp[-1][1]
    else:
        return 0

# Исправим функцию max_sum_LIS:
# dp[i] - минимальный последний элемент LIS длины i+1 и максимальная сумма цветов для этой длины
# Будем хранить dp как список пар (last_element, max_sum)
# Для каждого элемента x,v:
# - Найдём позицию pos для x в dp по last_element (используем bisect_left)
# - max_sum для pos = max_sum для pos-1 + v
# - Обновим dp[pos], если max_sum больше текущего

def max_sum_LIS(arr, vals):
    import bisect
    dp = []  # (last_element, max_sum)
    for x, v in zip(arr, vals):
        pos = bisect.bisect_left(dp, (x, -1))
        curr_sum = v
        if pos > 0:
            curr_sum += dp[pos-1][1]
        if pos == len(dp):
            dp.append((x, curr_sum))
        elif dp[pos][1] < curr_sum:
            dp[pos] = (x, curr_sum)
    if dp:
        return dp[-1][1]
    else:
        return 0

sum_lis = 0
for c in color_positions:
    arr = []
    vals = []
    for idx in color_positions[c]:
        arr.append(P[idx])
        vals.append(c)
    sum_lis += max_sum_LIS(arr, vals)

print(total_sum - sum_lis)