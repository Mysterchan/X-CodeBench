import sys
input = sys.stdin.readline

N = int(input())
P = list(map(int, input().split()))
C = list(map(int, input().split()))

# 將史萊姆按大小排序後的顏色序列
# P 是 1..N 的排列，P_i 是第 i 隻史萊姆的大小
# 我們想要將史萊姆按大小升序排列，即 P_i = i
# 現在序列是 P，對應顏色是 C
# 我們考慮將史萊姆按大小排序後的顏色序列：
# 對於大小 i 的史萊姆，找到其在原序列中的位置 pos，顏色為 C[pos]
# 形成序列 D，D[i] = C[pos]，其中 P[pos] = i

pos_of_size = [0]*(N+1)
for i, p in enumerate(P):
    pos_of_size[p] = i

D = [0]*N
for i in range(1, N+1):
    D[i-1] = C[pos_of_size[i]]

# 好序列的定義是：
# 可以通過交換顏色不同的相鄰史萊姆，使序列按大小升序排列
# 也就是說，序列 D 可以通過交換顏色不同的相鄰元素變成非降序序列（因為大小已排序）
# 但大小已排序，D 是顏色序列
# 交換限制：只能交換顏色不同的相鄰元素
# 目標是使 D 可以通過這種交換變成非降序序列（即顏色序列不會阻礙排序）

# 事實上，這等價於 D 中的顏色序列是「可排序」的，
# 也就是說，D 中的顏色序列中不會有「同色塊」阻礙排序。
# 具體來說，若 D 中的顏色序列中存在一個顏色塊被另一顏色塊包圍，且無法通過交換顏色不同的相鄰元素排序，
# 則需要改變顏色。

# 但題目中，大小是唯一的，且我們想要使序列成為好序列，
# 也就是說，D 中的顏色序列必須是「非降序」的（因為大小已排序），
# 且相同顏色的元素必須是連續的（否則無法通過交換顏色不同的相鄰元素排序）。

# 因此，我們的目標是將 D 改成一個「顏色分段」的序列，
# 使得相同顏色的元素連續出現，且整體序列是「可排序」的。

# 由於大小已排序，D 的顏色序列中相同顏色的元素必須是連續的。
# 若不連續，則需要改變顏色。

# 問題轉化為：
# 將 D 改成一個顏色分段的序列，使得相同顏色的元素連續，
# 且通過交換顏色不同的相鄰元素可以排序，
# 代價是改變顏色的史萊姆的顏色改變成本為該史萊姆原本的顏色值。

# 但題目中改變顏色的成本是「改變前的顏色值」，
# 我們可以將某些史萊姆的顏色改成任意顏色（1..N），
# 使得整個序列成為好序列。

# 觀察：
# 只要序列中相同顏色的元素是連續的，且顏色序列本身是「非降序」的，
# 就是好序列。

# 因為大小已排序，顏色序列中相同顏色的元素連續，
# 且顏色序列非降序，則可以通過交換顏色不同的相鄰元素排序。

# 因此，我們的目標是：
# 將 D 改成一個「非降序的顏色序列」且相同顏色的元素連續，
# 代價是改變顏色的史萊姆的顏色改變成本為該史萊姆原本的顏色值。

# 但題目中沒有要求顏色序列非降序，只要求能通過交換顏色不同的相鄰元素排序成大小升序，
# 但大小已排序，顏色序列是 D。

# 事實上，題目中「好序列」的定義是：
# 可以通過交換顏色不同的相鄰史萊姆，使序列按大小升序排列。
# 由於大小已排序，這等價於：
# 顏色序列 D 中不存在「同色塊被另一顏色塊分隔」的情況，
# 即相同顏色的元素在 D 中是連續的。

# 因此，我們只要保證 D 中相同顏色的元素是連續的即可。

# 目標：
# 將 D 改成一個顏色序列，使得相同顏色的元素連續，
# 且改變顏色的成本為改變前的顏色值之和。

# 我們可以將 D 分成若干段，每段顏色相同。
# 但原本 D 中相同顏色的元素可能不連續，
# 我們需要將不連續的顏色塊改成其他顏色。

# 觀察：
# 對於每個顏色 c，D 中出現了若干個不連續的塊，
# 我們可以保留其中一個塊的顏色為 c，
# 其他塊改成其他顏色。

# 改變顏色的成本是改變前的顏色值，
# 因此我們希望保留的塊是成本最高的（因為不改變該塊的顏色，節省成本），
# 其他塊改色，成本為這些塊中所有史萊姆原本顏色的和。

# 因此對每個顏色 c：
# - 找出所有 c 顏色的塊（連續區間）
# - 對每個塊計算該塊中所有史萊姆顏色值的和（即 c * 該塊長度）
# - 保留和最大的那個塊，其他塊改色，成本為其他塊的和

# 最終答案為所有顏色的其他塊成本之和。

# 實作：

from collections import defaultdict

color_positions = defaultdict(list)
for i, c in enumerate(D):
    color_positions[c].append(i)

total_cost = 0

for c, positions in color_positions.items():
    # 找出 c 顏色的所有連續塊
    blocks = []
    start = positions[0]
    prev = positions[0]
    for pos in positions[1:]:
        if pos == prev + 1:
            prev = pos
        else:
            blocks.append((start, prev))
            start = pos
            prev = pos
    blocks.append((start, prev))

    # 計算每個塊的成本（該塊中所有史萊姆顏色值的和）
    # 由於該塊中所有史萊姆顏色都是 c，成本為 c * (塊長度)
    block_costs = []
    for s, e in blocks:
        length = e - s + 1
        block_costs.append(length * c)

    # 保留成本最大的塊，其他塊改色，成本為其他塊成本之和
    max_cost = max(block_costs)
    total_cost += sum(block_costs) - max_cost

print(total_cost)