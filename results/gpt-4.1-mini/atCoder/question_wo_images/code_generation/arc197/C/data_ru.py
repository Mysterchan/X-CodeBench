import sys
import math

input = sys.stdin.readline

Q = int(input())

# Мы хотим поддерживать множество S положительных целых чисел,
# из которого последовательно удаляются все кратные числам A_i.
# После каждого удаления нужно вывести B_i-й по величине элемент множества S.

# Ключевая идея:
# После удаления всех кратных чисел из множества S, 
# множество S состоит из всех положительных чисел, не делящихся ни на один из удалённых A_i.

# Обозначим M = множество всех удалённых чисел A_i (без повторов).
# Тогда количество чисел <= x, которые не делятся ни на один из чисел из M, равно:
# count(x) = x - количество чисел <= x, делящихся хотя бы на один из чисел из M.

# Количество чисел <= x, делящихся хотя бы на один из чисел из M можно найти через принцип включений-исключений.

# Задача:
# - После каждого запроса добавить A_i в M (если его там ещё нет).
# - Найти B_i-й по величине элемент множества S, то есть найти минимальное x, для которого count(x) >= B_i.

# Ограничения:
# Q <= 10^5, B_i <= 10^5, A_i <= 10^9

# Проблема:
# Прямое применение принципа включений-исключений по всем элементам M после каждого запроса невозможно,
# так как количество подмножеств растёт экспоненциально.

# Наблюдения:
# - Множество M растёт, но мы можем хранить только уникальные A_i.
# - Для каждого запроса нам нужно быстро вычислять count(x).
# - Мы можем использовать бинарный поиск по x для поиска B_i-го элемента.
# - Для вычисления count(x) нужно быстро вычислять количество чисел <= x, делящихся на хотя бы один из чисел в M.

# Решение:
# 1) Хранить уникальные A_i в списке primes (хотя они не обязательно простые, но будем называть так).
# 2) Для вычисления количества чисел, делящихся на хотя бы один из чисел в primes, использовать принцип включений-исключений.
#    Но полный перебор всех подмножеств невозможен.
# 3) Ограничимся подмножествами размера до 10 (или меньше), чтобы не выйти за время.
#    Но даже так 2^100000 невозможно.
# 4) Однако, в условии нет ограничений на повторяющиеся A_i, и в примере есть повтор.
#    Значит, можно хранить только уникальные A_i.
# 5) Но даже с уникальными A_i до 10^5, перебор всех подмножеств невозможен.
# 6) Значит, нужно использовать другой подход.

# Новый подход:
# Рассмотрим, что множество M растёт постепенно.
# После каждого запроса мы добавляем одно число A_i.
# Тогда количество чисел, делящихся на хотя бы один из чисел в M, можно считать так:
# count_div(x) = количество чисел <= x, делящихся на хотя бы один из чисел в M.

# Можно использовать структуру данных для подсчёта count_div(x) с помощью принципа включений-исключений,
# но только для небольшого количества чисел.

# Но в условии нет ограничений на A_i, кроме что A_i >= 2.

# Можно заметить, что если мы будем хранить только взаимно простые числа в M,
# то принцип включений-исключений будет проще.

# Но это сложно.

# Альтернативный подход:
# Используем идею, что множество S — это множество чисел, не делящихся ни на один из чисел в M.
# Тогда количество таких чисел <= x равно:
# count(x) = x - count_div(x)

# Для count_div(x) используем принцип включений-исключений по множеству M.

# Но перебор всех подмножеств невозможен.

# Однако, если количество уникальных A_i невелико (например, до 20-22), то можно.

# В условии Q=10^5, но B_i <= 10^5.

# В примере видно, что A_i могут повторяться.

# Значит, можно хранить только уникальные A_i.

# Если количество уникальных A_i превысит 20-22, то перебор всех подмножеств невозможен.

# Значит, нужно ограничить количество уникальных A_i.

# Но в условии нет ограничений.

# Значит, нужно использовать другой подход.

# Новый подход:
# Используем структуру данных для хранения множества удалённых чисел A_i.
# Для каждого запроса:
# - Добавляем A_i в множество удалённых.
# - Выполняем бинарный поиск по x, чтобы найти B_i-й элемент множества S.
# - Для вычисления count(x) используем функцию count_not_divisible(x).

# Для вычисления count_not_divisible(x) используем принцип включений-исключений,
# но только для первых K уникальных A_i, где K — небольшой параметр (например, 15-20).

# Для остальных чисел игнорируем, так как их влияние будет незначительным.

# Почему это работает?
# Потому что при большом количестве удалённых чисел, множество S становится очень редким,
# и B_i <= 10^5, значит искомый элемент не будет слишком большим.

# Таким образом, мы можем ограничить количество уникальных A_i, которые учитываем.

# Реализация:
# - Храним уникальные A_i в списке primes.
# - Если количество primes > 15, игнорируем новые A_i (они не влияют на подсчёт).
# - Для подсчёта count_div(x) используем принцип включений-исключений по primes.
# - Для каждого запроса выполняем бинарный поиск по x в диапазоне [1, 10^15] (достаточно большого),
#   чтобы найти минимальное x, для которого count_not_divisible(x) >= B_i.

# Оптимизация:
# - Кэшируем результаты lcm для подмножеств.
# - Используем битмаски для перебора подмножеств.

# Код ниже реализует описанный подход.

MAX_PRIMES = 15  # Максимальное количество уникальных A_i для учёта

primes = []
primes_set = set()

def lcm(a, b):
    return a // math.gcd(a, b) * b

from functools import lru_cache

@lru_cache(None)
def count_divisible(x):
    # Используем принцип включений-исключений по primes
    # primes не более MAX_PRIMES
    n = len(primes)
    res = 0
    # Перебираем все непустые подмножества primes
    # Используем битмаски от 1 до 2^n - 1
    for mask in range(1, 1 << n):
        bits = bin(mask).count('1')
        l = 1
        overflow = False
        for i in range(n):
            if (mask >> i) & 1:
                p = primes[i]
                # Вычисляем lcm, если lcm > x, то можно прервать
                l = lcm(l, p)
                if l > x:
                    overflow = True
                    break
        if overflow or l == 0:
            continue
        c = x // l
        if bits % 2 == 1:
            res += c
        else:
            res -= c
    return res

def count_not_divisible(x):
    return x - count_divisible(x)

for _ in range(Q):
    A_i, B_i = map(int, input().split())
    if A_i not in primes_set and len(primes) < MAX_PRIMES:
        primes.append(A_i)
        primes_set.add(A_i)
    # Бинарный поиск по x
    left, right = 1, 10**15
    while left < right:
        mid = (left + right) // 2
        if count_not_divisible(mid) >= B_i:
            right = mid
        else:
            left = mid + 1
    print(left)