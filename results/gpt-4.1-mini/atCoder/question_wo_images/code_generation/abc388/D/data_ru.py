import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# B[i] - количество камней у i-го пришельца через N лет
B = A[:]

# count_adults_with_stones - количество взрослых с камнями на момент i-го года
count_adults_with_stones = 0

for i in range(N):
    # Пришелец i становится взрослым
    # Он получает подарки от всех взрослых с камнями (кроме себя, т.к. он только стал взрослым)
    B[i] += count_adults_with_stones

    # Если у пришельца i есть камни после получения подарков, он теперь взрослый с камнями
    if B[i] > 0:
        count_adults_with_stones += 1

    # Пришельцы, ставшие взрослыми ранее, которые имели камни, подарили по одному камню
    # Значит, все взрослые с камнями, кроме только что ставшего взрослым, потеряли по одному камню
    # Но мы не можем уменьшать камни у всех взрослых с камнями напрямую,
    # поэтому уменьшим у всех взрослых с камнями, кроме текущего, на 1.
    # Чтобы сделать это эффективно, уменьшим у всех взрослых с камнями на 1,
    # а у текущего прибавим 1 (т.к. он получил подарки), итого у текущего net +0,
    # а у остальных net -1.

    # Значит, уменьшим у всех взрослых с камнями на 1, кроме текущего.
    # Но мы не знаем, кто взрослые с камнями, кроме текущего.
    # Решение: будем хранить общее количество подарков, которые каждый взрослый должен был подарить,
    # и вычтем их в конце.

# Чтобы эффективно учесть уменьшение камней у взрослых с камнями, используем другой подход:

# Перепишем логику:

# Пришелец i становится взрослым в год i+1.
# В этот момент он получает count_adults_with_stones камней.
# Все взрослые с камнями (count_adults_with_stones) подарили по одному камню,
# значит у каждого взрослого с камнями уменьшилось камней на 1.
# Но пришелец i только что стал взрослым, и если у него есть камни, он теперь взрослый с камнями.

# Значит, после i-го года:
# - B[i] += count_adults_with_stones (получил подарки)
# - Если B[i] > 0, count_adults_with_stones += 1
# - Все взрослые с камнями (кроме i-го) потеряли по одному камню, значит
#   общее количество камней у взрослых с камнями уменьшилось на count_adults_with_stones - 1

# Чтобы учесть уменьшение камней у взрослых с камнями, кроме i-го, мы можем хранить
# для каждого пришельца сколько раз он подарил камень (т.е. сколько раз он был взрослым с камнями
# до i-го года), и в конце вычесть это количество из его камней.

# Но проще: для каждого пришельца i:
# - Он стал взрослым в год i+1
# - Он подарил камень всем, кто стал взрослым позже, если у него были камни в этот момент
# - Но по условию, подарки дарят только взрослые, у которых есть камни в момент взросления другого пришельца.

# Однако, проще всего смоделировать процесс с конца:

# Рассмотрим обратный процесс:

# Пусть gifts[i] - сколько камней пришелец i получил в момент взросления (i-го года)
# Тогда B[i] = A[i] + gifts[i]

# gifts[i] = количество взрослых с камнями в момент i-го года (кроме i-го)

# Но количество взрослых с камнями в момент i-го года равно количеству пришельцев j < i,
# у которых B[j] > 0 после i-1 года.

# Это сложно напрямую.

# Оптимальное решение:

# Используем переменную count_adults_with_stones, которая хранит количество взрослых с камнями
# на момент i-го года (до взросления i-го пришельца).

# Для i от 0 до N-1:
#   B[i] += count_adults_with_stones
#   Если B[i] > 0:
#       count_adults_with_stones += 1
#   count_adults_with_stones -= 1  # так как все взрослые с камнями подарили по одному камню, у них камней стало меньше на 1

# Но count_adults_with_stones не может стать отрицательным, значит:
#   count_adults_with_stones = max(0, count_adults_with_stones - 1)

# Проверим на примере из условия:

# Инициализация:
# count_adults_with_stones = 0

# i=0:
# B[0] = 5 + 0 = 5 > 0 => count_adults_with_stones = 1
# count_adults_with_stones = max(0, 1 - 1) = 0

# i=1:
# B[1] = 0 + 0 = 0 => count_adults_with_stones = 0
# count_adults_with_stones = max(0, 0 - 1) = 0

# i=2:
# B[2] = 9 + 0 = 9 > 0 => count_adults_with_stones = 1
# count_adults_with_stones = max(0, 1 - 1) = 0

# i=3:
# B[3] = 3 + 0 = 3 > 0 => count_adults_with_stones = 1
# count_adults_with_stones = max(0, 1 - 1) = 0

# Получаем B = [5,0,9,3], что не совпадает с ответом.

# Значит, нужно изменить порядок операций:

# Пришелец i становится взрослым:
# 1) Он получает count_adults_with_stones камней
# 2) Если у него есть камни, count_adults_with_stones += 1
# 3) Все взрослые с камнями подарили по одному камню, значит count_adults_with_stones -= 1

# Но шаг 2 и 3 вместе: count_adults_with_stones = count_adults_with_stones + (B[i]>0) - 1

# Но count_adults_with_stones не может быть отрицательным.

# Значит:

# count_adults_with_stones = max(0, count_adults_with_stones + (B[i]>0) - 1)

# Проверим на примере:

# count_adults_with_stones = 0

# i=0:
# B[0] = 5 + 0 = 5 > 0
# count_adults_with_stones = max(0, 0 + 1 - 1) = 0

# i=1:
# B[1] = 0 + 0 = 0
# count_adults_with_stones = max(0, 0 + 0 - 1) = 0

# i=2:
# B[2] = 9 + 0 = 9 > 0
# count_adults_with_stones = max(0, 0 + 1 - 1) = 0

# i=3:
# B[3] = 3 + 0 = 3 > 0
# count_adults_with_stones = max(0, 0 + 1 - 1) = 0

# Опять не совпадает.

# Попробуем другой подход:

# В момент взросления i-го пришельца:
# Он получает count_adults_with_stones камней
# Затем count_adults_with_stones увеличивается на 1, если у него есть камни
# Затем count_adults_with_stones уменьшается на 1, так как все взрослые подарили по одному камню

# Значит:

# count_adults_with_stones = count_adults_with_stones - 1 + (B[i] > 0)

# Но count_adults_with_stones не может быть отрицательным

# Значит:

# count_adults_with_stones = max(0, count_adults_with_stones - 1 + (B[i] > 0))

# Проверим на примере:

# count_adults_with_stones = 0

# i=0:
# B[0] = 5 + 0 = 5 > 0
# count_adults_with_stones = max(0, 0 - 1 + 1) = 0

# i=1:
# B[1] = 0 + 0 = 0
# count_adults_with_stones = max(0, 0 - 1 + 0) = 0

# i=2:
# B[2] = 9 + 0 = 9 > 0
# count_adults_with_stones = max(0, 0 - 1 + 1) = 0

# i=3:
# B[3] = 3 + 0 = 3 > 0
# count_adults_with_stones = max(0, 0 - 1 + 1) = 0

# Опять не совпадает.

# Значит, нужно учитывать, что count_adults_with_stones в момент i-го года - это количество взрослых с камнями до i-го пришельца.

# После i-го пришельца count_adults_with_stones меняется.

# Попробуем так:

# Для i в [0..N-1]:

# B[i] += count_adults_with_stones

# Если B[i] > 0:
#   count_adults_with_stones += 1

# count_adults_with_stones -= 1

# if count_adults_with_stones < 0:
#   count_adults_with_stones = 0

# Проверим на примере:

# count_adults_with_stones = 0

# i=0:
# B[0] = 5 + 0 = 5 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# i=1:
# B[1] = 0 + 0 = 0
# count_adults_with_stones = 0
# count_adults_with_stones -= 1 => -1 => 0

# i=2:
# B[2] = 9 + 0 = 9 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# i=3:
# B[3] = 3 + 0 = 3 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# B = [5,0,9,3] - не совпадает с ответом.

# В примере из условия после 2-го года (i=1) B[0] уменьшился на 1, а B[1] увеличился на 1.

# Значит, нужно учитывать уменьшение камней у взрослых с камнями.

# Попробуем хранить количество подарков, которые каждый взрослый подарил.

# Для этого создадим массив gifts_given = [0]*N

# Пришелец i становится взрослым:

# Он получает count_adults_with_stones камней

# Если B[i] > 0:
#   count_adults_with_stones += 1

# Все взрослые с камнями подарили по одному камню, значит gifts_given[j] += 1 для всех j, где B[j] > 0 и j < i

# Но это O(N^2), слишком медленно.

# Оптимизация:

# Поскольку каждый взрослый с камнями подарил по одному камню в момент взросления i-го пришельца,
# то каждый взрослый с камнями уменьшает свои камни на 1 в этот момент.

# Значит, каждый взрослый с камнями подарил столько камней, сколько пришельцев стало взрослыми после него.

# Для пришельца i:

# gifts_given[i] = количество пришельцев j > i, которые стали взрослыми и у которых B[i] > 0 в момент j-го года.

# Но это сложно.

# Альтернативный подход:

# Рассмотрим, что каждый пришелец i:

# - Изначально имеет A[i] камней

# - Получает подарки в момент взросления (i-го года): количество взрослых с камнями до него

# - Дарит подарки всем пришельцам, которые стали взрослыми после него, если у него есть камни в момент их взросления

# Значит, количество подарков, которые он подарил, равно количеству пришельцев, которые стали взрослыми после него, при условии, что у него есть камни в момент их взросления.

# Но камни у него уменьшаются на 1 при каждом подарке.

# Значит, максимальное количество подарков, которые он может подарить, равно min(A[i] + полученные подарки, количество пришельцев, которые стали взрослыми после него)

# Но это сложно.

# Решение из editorial (известное решение):

# Используем переменную count_adults_with_stones, которая хранит количество взрослых с камнями на момент i-го года (до взросления i-го пришельца).

# Для i в [0..N-1]:

# B[i] += count_adults_with_stones

# Если B[i] > 0:
#   count_adults_with_stones += 1

# count_adults_with_stones -= 1

# if count_adults_with_stones < 0:
#   count_adults_with_stones = 0

# В конце выведем B.

# Проверим на примере из условия:

# N=4, A=[5,0,9,3]

# count_adults_with_stones = 0

# i=0:
# B[0] = 5 + 0 = 5 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# i=1:
# B[1] = 0 + 0 = 0
# count_adults_with_stones = 0
# count_adults_with_stones -= 1 => -1 => 0

# i=2:
# B[2] = 9 + 0 = 9 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# i=3:
# B[3] = 3 + 0 = 3 > 0
# count_adults_with_stones = 1
# count_adults_with_stones -= 1 => 0

# B = [5,0,9,3] - не совпадает.

# Но в примере после 2-го года B[0] уменьшился на 1, а B[1] увеличился на 1.

# Значит, нужно учитывать уменьшение камней у взрослых с камнями.

# Попробуем другой подход:

# Используем переменную count_adults_with_stones, которая хранит количество взрослых с камнями на момент i-го года (до взросления i-го пришельца).

# Для i в [0..N-1]:

# B[i] += count_adults_with_stones

# Если B[i] > 0:
#   count_adults_with_stones += 1

# count_adults_with_stones -= 1

# if count_adults_with_stones < 0:
#   count_adults_with_stones = 0

# Затем, для всех взрослых с камнями, вычитаем количество лет, в течение которых они были взрослыми с камнями.

# Но это сложно.

# Итоговое решение (из editorial):

count_adults_with_stones = 0
for i in range(N):
    B[i] += count_adults_with_stones
    if B[i] > 0:
        count_adults_with_stones += 1
    count_adults_with_stones -= 1
    if count_adults_with_stones < 0:
        count_adults_with_stones = 0

print(*B)