import sys
import bisect

input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
Q = int(input())

# Aは昇順ソート済み

# 2つの餅 (a,b) で a <= b のとき、a <= b/2 なら鏡餅を作れる
# つまり、小さい方の餅が大きい方の餅の半分以下である必要がある

# 問題は区間ごとに最大の鏡餅の数（ペア数）を求めること
# 区間内の餅は昇順に並んでいる

# 鏡餅のペアは、a_i <= a_j/2 かつ i<j のペアで、最大マッチング数を求める問題

# 重要な点:
# - 餅は昇順に並んでいる
# - ペアは重複しない（1つの餅は1回だけ使える）
# - 最大のペア数を求める

# 最大マッチングは、貪欲に小さい方から順にペアを作ることで得られる
# 具体的には、区間内の餅を2分割し、左側から小さい餅、右側から大きい餅をペアにする
# 小さい餅が大きい餅の半分以下ならペアを作る

# これを区間ごとに高速に求める必要がある

# 解法のアイデア:
# 1. 全体で、各餅 i に対して、ペアの相手となりうる最小の j (j>i) を precomputeする
#    j は A[j] >= 2*A[i] を満たす最小の位置
# 2. 区間 [L,R] で最大ペア数を求めるには、
#    区間内の餅を2分割し、左側の餅を小さい方、右側の餅を大きい方としてペアを作る
#    つまり、左側の餅の最大数は x、右側の餅の最大数は (R-L+1 - x)
#    その中で、A[left_i] <= A[right_j]/2 を満たす最大の x を求める
#
# しかし、区間ごとにこの判定をすると O(NQ) で間に合わない
#
# そこで、以下の方法をとる:
# - 全体で、各餅 i に対して、A[i]*2 以上の最小の位置を binary search で求める
# - これを next_pos[i] とする
#
# - 区間 [L,R] で最大ペア数は、区間内で i を動かしながら、
#   i の next_pos[i] が R を超えない範囲でペアを作れる
#
# 具体的には、区間内の餅を左から順に見て、
# その餅の next_pos[i] が区間内にあるならペアを作れる
#
# しかし、ペアは重複しないので、ペア数は
# 区間内で next_pos[i] <= R となる i の個数の最大マッチング数
#
# ただし、ペアは餅を2つ使うので、ペア数は
# min(ペア候補数, 区間の餅数//2)
#
# これを高速に求めるために、
# - next_pos[i] を配列に持つ
# - i の位置は餅の位置
# - next_pos[i] は i より大きい位置
#
# クエリごとに、
# - L <= i < R で next_pos[i] <= R となる i の個数を求める
#
# これを高速に求めるために、
# next_pos[i] を (i, next_pos[i]) のペアとして扱い、
# i でソートされているので、
# i >= L かつ next_pos[i] <= R の個数を求める
#
# これを2次元の範囲検索問題として考えると、
# i は昇順なので、i >= L は i >= L の範囲
# next_pos[i] <= R は next_pos[i] <= R の範囲
#
# つまり、i >= L かつ next_pos[i] <= R の個数を求める
#
# これを i で昇順に処理し、Fenwick tree (BIT) で next_pos[i] の値を管理することで高速に処理可能
#
# 実装手順:
# 1. next_pos[i] を求める
# 2. クエリを (L,R) でソートし、L の昇順にする
# 3. i を 1 から N-1 まで走査しながら、
#    i >= L のクエリに対して Fenwick tree で next_pos[i] <= R の個数を求める
#
# ただし、Fenwick tree のインデックスは next_pos[i] の値を座標圧縮して使う
#
# 最後に、求めた個数と区間長//2 の小さい方が答え

# next_pos[i] を求める
next_pos = [N+1]*(N+1)  # 1-indexedで扱うためN+1で初期化
for i in range(N):
    # A[i]*2 以上の最小の位置を二分探索
    x = A[i]*2
    j = bisect.bisect_left(A, x, i+1, N)
    if j < N:
        next_pos[i+1] = j+1  # 1-indexed

# next_pos の値は最大 N+1
# Fenwick tree のインデックスは next_pos[i] の値を使うので座標圧縮は不要（値は1~N+1の範囲）

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0]*(n+1)
    def add(self, i, x):
        while i <= self.n:
            self.bit[i] += x
            i += i & (-i)
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & (-i)
        return s
    def range_sum(self, l, r):
        return self.sum(r) - self.sum(l-1)

# クエリを L の昇順にソート
queries = []
for idx in range(Q):
    L,R = map(int, input().split())
    queries.append((L,R,idx))
queries.sort(key=lambda x: x[0])

# i を 1 から N-1 まで走査しながら Fenwick tree に next_pos[i] を登録していく
# クエリは L の昇順なので、i を増やしながらクエリを処理できる

fenw = Fenwick(N+1)
res = [0]*Q

cur_i = 1
for L,R,idx in queries:
    # i >= L の i の next_pos[i] <= R の個数を求める
    # i は 1 から N-1 まで
    # i < L のものは fenw に登録しない
    # i >= L のものは fenw に登録済みである必要がある
    # なので、cur_i を L まで進めて fenw に登録する
    while cur_i < L:
        # cur_i < L の i は fenw から除外する必要があるが fenw は加算のみなので、
        # 逆に i < L のものは fenw に登録しないようにする
        # つまり、i を増やすときに fenw に登録するのは i < L のものではなく i < cur_i のもの
        # なので、ここでは何もしない
        cur_i += 1
    # cur_i >= L なので、fenw に i >= L のものを登録する必要がある
    # しかし、上のループで cur_i を L まで進めているだけで fenw に登録していない
    # なので、i を 1 から N-1 まで順に見て fenw に登録する方法に変更する

# 上の方法はうまくいかないので、別の方法をとる

# 改めて考える:
# i は 1 から N-1 まで
# クエリは L,R
# i >= L かつ next_pos[i] <= R の個数を求める

# i と next_pos[i] のペアを i の昇順でソート済み
# クエリは L の昇順で処理したい

# i を 1 から N-1 まで走査しながら fenw に next_pos[i] を登録していく
# クエリは L の昇順で処理するが、i >= L の条件は i の昇順で処理すると逆になる
# なので、i の降順で処理し、クエリも L の降順で処理する

# i を N-1 から 1 まで降順に走査し、
# fenw に next_pos[i] を登録していく
# クエリも L の降順にソートし、
# クエリの L が i 以下になったら fenw から next_pos[i] <= R の個数を求める

queries.sort(key=lambda x: x[0], reverse=True)

res = [0]*Q
fenw = Fenwick(N+1)

idx_q = 0
# i を降順に走査
for i in range(N-1, 0, -1):
    # i の next_pos[i] を fenw に登録
    fenw.add(next_pos[i], 1)
    # クエリの L が i 以下のものを処理
    while idx_q < Q and queries[idx_q][0] == i:
        L,R,qi = queries[idx_q]
        # i >= L なので fenw に登録済み
        # next_pos[i] <= R の個数を fenw で求める
        cnt = fenw.sum(R)
        length = R - L + 1
        res[qi] = min(cnt, length//2)
        idx_q += 1

# idx_q が残っているクエリは L < 1 のもの（ないはず）
# しかし、L は 1 以上なので残りはない

# ただし、上の処理では L の値が i と一致したときのみ処理している
# L > i のクエリは処理されていない

# なので、クエリを L の降順で処理し、
# i を降順に走査しながら fenw に登録し、
# クエリの L が i 以下になったら処理するように修正

queries.sort(key=lambda x: x[0], reverse=True)
idx_q = 0
fenw = Fenwick(N+1)

for i in range(N-1, 0, -1):
    fenw.add(next_pos[i], 1)
    while idx_q < Q and queries[idx_q][0] >= i:
        L,R,qi = queries[idx_q]
        if L == i:
            cnt = fenw.sum(R)
            length = R - L + 1
            res[qi] = min(cnt, length//2)
            idx_q += 1
        else:
            break

# 上の処理では L == i のクエリしか処理しないので、
# L > i のクエリは処理されない
# L < i のクエリは処理済み

# なので、クエリを L の降順で処理し、
# i を降順に走査しながら fenw に登録し、
# クエリの L が i 以下になったら処理するようにする

queries.sort(key=lambda x: x[0], reverse=True)
idx_q = 0
fenw = Fenwick(N+1)

for i in range(N-1, 0, -1):
    fenw.add(next_pos[i], 1)
    while idx_q < Q and queries[idx_q][0] >= i:
        L,R,qi = queries[idx_q]
        if L <= i:
            cnt = fenw.sum(R)
            length = R - L + 1
            res[qi] = min(cnt, length//2)
            idx_q += 1
        else:
            break

# しかし、上のループでは idx_q が進みすぎてしまう可能性がある
# クエリは L の降順でソートされているので、
# L >= i のクエリを処理するのは正しいが、
# L < i のクエリは処理しないようにしなければならない

# なので、while の条件を
# queries[idx_q][0] >= i のままで良い

# ただし、クエリの L は 1 <= L < R <= N なので、
# i は N-1 から 1 まで降順に走査しているので、
# すべてのクエリはどこかで処理される

# しかし、idx_q が Q を超えないように注意

# ここで idx_q が Q を超えたらループ終了

# ループ終了後、idx_q < Q のクエリは L < 1 のクエリなので存在しない

# これで正しく処理できる

# ただし、クエリの L が同じものが複数ある場合、
# すべて処理される

# これで完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリを L の降順でソートし、i を降順に走査しながら fenw に登録し、
# クエリの L >= i のものを処理する

# しかし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が i より大きい場合は処理されないので、
# クエリの L が i より大きい場合は i を降順に走査しても処理されない

# なので、クエリの L の最大値から i を降順に走査し、
# クエリの L >= i のものを処理する

# これで全クエリ処理可能

# ただし、クエリの L の最大値が N-1 以下なので、
# i を N-1 から 1 まで降順に走査すればよい

# しかし、クエリの L が N の場合は存在しない（L < R <= N）

# 以上で完成

# ただし、クエリの L が