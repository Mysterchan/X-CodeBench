import sys
import bisect

input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))
Q = int(input())

# Предварительно вычислим для каждого i (1-based) индекс j = f(i):
# минимальный j > i, такой что A[j] >= 2 * A[i]
# Если такого j нет, f(i) = N+1 (за пределами массива)
f = [0] * N
for i in range(N):
    # Ищем минимальный j > i, где A[j] >= 2 * A[i]
    # Используем бинарный поиск по A
    val = 2 * A[i]
    j = bisect.bisect_left(A, val, i + 1, N)
    if j == N:
        f[i] = N + 1
    else:
        f[i] = j + 1  # 1-based

# Теперь у нас есть массив f (1-based индексы)
# Для каждого запроса (L, R) нужно найти максимальное количество пар K,
# таких что можно выбрать 2K моти из [L..R] и сформировать K пар (a,b),
# где a ≤ b/2.

# Заметим, что пары можно формировать только между i и f(i),
# если f(i) ≤ R и f(i) > i (т.е. внутри интервала).
# Каждая пара использует два моти: i и f(i).
# Чтобы пары не пересекались по элементам, они должны быть непересекающимися.

# Поскольку A отсортирован, и f(i) > i, пары (i, f(i)) идут в порядке возрастания i.
# Можно рассматривать пары (i, f(i)) как ребра, и задача сводится к
# нахождению максимального количества непересекающихся пар (i, f(i)) внутри [L,R].

# Пары (i, f(i)) упорядочены по i, и f(i) > i.
# Максимальное количество непересекающихся пар в интервале [L,R]
# можно найти жадно, выбирая пары с минимальным f(i), чтобы не пересекаться.

# Для быстрого ответа на запросы построим структуру данных:
# Отсортируем пары по f(i), затем по i.
# Для каждого запроса нужно быстро найти максимальное количество непересекающихся пар,
# где i и f(i) ∈ [L,R].

# Но это сложно сделать напрямую.

# Альтернативный подход:
# Рассмотрим массив f: для каждого i, f(i) - индекс пары.
# Построим массив f и отсортируем пары по f(i).
# Для каждого i, если f(i) ≤ N, пара (i, f(i)) существует.

# Построим массив пар (i, f(i)) с f(i) ≤ N.

pairs = []
for i in range(N):
    if f[i] <= N:
        pairs.append((i + 1, f[i]))  # 1-based

# Отсортируем пары по f(i)
pairs.sort(key=lambda x: x[1])

# Теперь для каждого запроса (L,R) нужно найти максимальное количество непересекающихся пар,
# где i ≥ L, f(i) ≤ R, и i < f(i).

# Поскольку пары отсортированы по f(i), можно использовать двухмерную структуру для запросов.

# Построим массив i и f(i) из pairs:
I = [p[0] for p in pairs]
F = [p[1] for p in pairs]
M = len(pairs)

# Для каждого запроса (L,R) нужно найти максимальное количество непересекающихся пар,
# где i ≥ L и f(i) ≤ R.

# Пары отсортированы по f(i), значит для f(i) ≤ R можно взять префикс массива pairs.
# В этом префиксе нужно выбрать пары с i ≥ L, и найти максимальное количество непересекающихся пар,
# где пары не пересекаются по элементам.

# Пары упорядочены по f(i), и i < f(i).
# Чтобы пары не пересекались, нужно, чтобы i и f(i) не пересекались с другими парами.
# Поскольку пары идут по возрастанию f(i), и i < f(i), и i возрастают в pairs,
# максимальное количество непересекающихся пар в префиксе с i ≥ L
# можно найти с помощью жадного алгоритма.

# Но для быстрого ответа на Q запросов нужно использовать структуру данных.

# Предлагаем следующий подход:

# 1) Для каждого префикса по f(i) (т.е. для j от 1 до M),
#    построим массив i_j = I[j-1].
# 2) Для каждого запроса (L,R):
#    - Найдем pos = верхняя граница для f(i) ≤ R (т.е. max j, что F[j-1] ≤ R)
#    - В префиксе pairs[0..pos-1] нужно выбрать пары с i ≥ L.
#    - Максимальное количество непересекающихся пар среди них
#      можно найти, выбрав пары с минимальным i, так как пары отсортированы по f(i),
#      и i < f(i), и пары не пересекаются, если i и f(i) не пересекаются.
#    - Но i могут быть в любом порядке, поэтому нужно быстро найти количество пар с i ≥ L в префиксе.

# 3) Построим Fenwick tree (BIT) по i, чтобы быстро считать количество пар с i ≥ L в префиксе.

# Но i могут быть до N, и нам нужно считать количество пар с i ≥ L в префиксе.

# Решение:
# - Для каждого префикса j, мы можем считать количество пар с i ≥ L.
# - Для этого отсортируем i по возрастанию.
# - Для каждого запроса:
#   - Найдем pos по f(i) ≤ R
#   - В префиксе pairs[0..pos-1] найдем количество пар с i ≥ L.

# Для этого:
# - Отсортируем пары по f(i)
# - Для i в pairs, построим массив i
# - Для каждого запроса:
#   - pos = bisect_right(F, R)
#   - В i[0..pos-1] нужно найти количество элементов ≥ L

# Для быстрого подсчёта количества элементов ≥ L в подмассиве i[0..pos-1],
# построим для i массив отсортированных значений и используем бинарный поиск.

# Но i в pairs не отсортированы по i, а по f(i).

# Для каждого префикса pairs[0..pos-1], i могут быть в любом порядке.

# Чтобы быстро отвечать на запросы, построим структуру данных:

# - Для i в pairs, построим массив i
# - Для каждого префикса pairs[0..pos-1], отсортируем i[0..pos-1]
# - Для каждого запроса (L,R):
#   - pos = bisect_right(F, R)
#   - В отсортированном i[0..pos-1] найдем количество элементов ≥ L с помощью бинарного поиска

# Но Q и N до 2*10^5, и сортировка для каждого запроса невозможна.

# Оптимизация:

# Построим массив i и f(i) отсортированных по f(i).
# Построим массив i.
# Построим структуру данных для поиска количества элементов ≥ L в префиксе i[0..pos-1].

# Для этого построим массив i и отсортируем его.
# Но нам нужно быстро считать количество элементов ≥ L в префиксе i[0..pos-1].

# Построим Fenwick tree по i, добавляя элементы по возрастанию f(i).

# Алгоритм:

# - Отсортируем пары по f(i)
# - Создадим массив i
# - Создадим массив уникальных i для сжатия координат
# - Построим Fenwick tree по i (сжатым координатам)
# - Итерируем по парам по возрастанию f(i), добавляя i в Fenwick tree
# - Для каждого запроса (L,R):
#   - Найдем pos = bisect_right(F, R)
#   - В Fenwick tree посчитаем количество i ≥ L среди первых pos элементов
#   - Для этого Fenwick tree должен уметь считать количество элементов с i ≥ L в префиксе pos

# Для Fenwick tree:
# - Индексы по порядку добавления (по f(i))
# - Значения i сжаты
# - Для запроса нужно посчитать количество элементов с i ≥ L в первых pos элементах

# Для этого:
# - Для каждого pos, Fenwick tree хранит количество элементов с i = x
# - Чтобы посчитать количество элементов с i ≥ L, нужно суммировать по i ≥ L

# Но Fenwick tree индексируется по i, а pos - по порядку добавления.

# Решение: используем offline обработку запросов.

# Алгоритм:

# 1) Сжать координаты i (i от 1 до N)
# 2) Отсортировать пары по f(i)
# 3) Для каждого запроса (L,R), вычислить pos = bisect_right(F, R)
# 4) Запросы отсортировать по pos по возрастанию
# 5) Итерируем по pos от 1 до M, добавляя i в Fenwick tree
# 6) Для каждого запроса с pos = current pos, считаем количество элементов с i ≥ L
#    = количество элементов в Fenwick tree - количество элементов с i < L
# 7) Выводим ответы

# Реализация:

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.fw = [0] * (n + 1)

    def update(self, i, v):
        while i <= self.n:
            self.fw[i] += v
            i += i & -i

    def query(self, i):
        s = 0
        while i > 0:
            s += self.fw[i]
            i -= i & -i
        return s

    def query_range(self, l, r):
        return self.query(r) - self.query(l - 1)

# Сжатие координат i
unique_i = sorted(set(I))
def get_idx(x):
    # возвращает 1-based индекс в unique_i
    return bisect.bisect_left(unique_i, x) + 1

I_comp = [get_idx(x) for x in I]

# Обработка запросов
queries = []
for idx in range(Q):
    L, R = map(int, input().split())
    # Найдем pos = количество пар с f(i) ≤ R
    pos = bisect.bisect_right(F, R)
    queries.append((pos, L, idx))

# Отсортируем запросы по pos
queries.sort(key=lambda x: x[0])

fenw = Fenwick(len(unique_i))
res = [0] * Q

cur = 0
for pos, L, idx_q in queries:
    # Добавляем пары с индексами от cur до pos-1
    while cur < pos:
        fenw.update(I_comp[cur], 1)
        cur += 1
    # Количество элементов с i ≥ L
    # Найдем индекс для L
    idL = bisect.bisect_left(unique_i, L) + 1
    total = fenw.query(len(unique_i))
    less = fenw.query(idL - 1)
    res[idx_q] = total - less

print('\n'.join(map(str, res)))