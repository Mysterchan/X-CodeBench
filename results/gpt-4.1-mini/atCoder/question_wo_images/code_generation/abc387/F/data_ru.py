import sys
sys.setrecursionlimit(10**7)
MOD = 998244353

N, M = map(int, sys.stdin.readline().split())
A = list(map(lambda x: int(x)-1, sys.stdin.readline().split()))

# Построим граф зависимостей: ребро i->A[i]
# Условие: x_i ≤ x_{A_i}
# Значит, x_i ≤ x_{A_i}, то есть x_i не может быть больше x_{A_i}.
# Это задаёт неравенства, которые можно интерпретировать как ребра i->A[i].

# Чтобы понять, сколько существует последовательностей x,
# удовлетворяющих x_i ≤ x_{A_i}, рассмотрим компоненты связности и циклы.

# Если в графе есть цикл, то для всех вершин цикла значения x_i равны,
# так как по цепочке неравенств x_i ≤ x_j ≤ ... ≤ x_i, значит все равны.

# Значит, граф разбивается на компоненты сильной связности (SCC).
# В каждой SCC все x_i равны.
# Между SCC образуется DAG (ацикличный граф).

# Обозначим компоненты SCC:
# Для каждой компоненты SCC значение x_c ∈ [1..M].
# Для ребра из компоненты c1 в c2 (c1->c2) условие: x_c1 ≤ x_c2.

# Значит, для DAG из компонент SCC нужно посчитать количество функций x_c,
# где x_c ∈ [1..M], и для каждого ребра c1->c2: x_c1 ≤ x_c2.

# Это классическая задача подсчёта количества неубывающих функций на DAG.

# Решение:
# 1) Найти SCC.
# 2) Построить DAG из компонент.
# 3) Для каждой компоненты посчитать dp[c][v] = количество способов назначить значения компонентам в подграфе с корнем c,
#    если x_c = v.
# 4) Итог: сумма dp[c][v] по v для всех компонент без входящих рёбер (истоков).

# Но проще:
# Поскольку условие x_c1 ≤ x_c2 для ребра c1->c2,
# значения по пути в DAG неубывающие.

# Можно сделать топологический порядок по DAG компонент,
# и для каждой компоненты c вычислить dp_c[v] = количество способов назначить значения компонентам,
# учитывая ограничения, если x_c = v.

# Для компоненты без входящих рёбер dp_c[v] = 1 (можно выбрать любое v).

# Для компоненты c с входящими рёбрами из c1, c2, ..., условие:
# x_c1 ≤ x_c, x_c2 ≤ x_c, ...
# Значит, x_c ≥ max(x_c1, x_c2, ...)

# Тогда dp_c[v] = произведение по предкам c' суммы dp_c'[u] для u ≤ v.

# Для ускорения вычислений используем префиксные суммы.

# В итоге ответ = сумма dp_c[v] по v для всех компонент c без входящих рёбер.

# Но так как DAG может иметь несколько истоков, итоговое количество - это сумма по всем возможным значениям
# для всех истоков, а остальные компоненты зависят от них.

# Однако, поскольку все компоненты связаны через ребра, итоговое количество - это сумма dp по всем вершинам,
# но нужно аккуратно.

# На самом деле, поскольку условие задано для всех i, и граф из ребер i->A[i],
# то каждая вершина имеет ровно один исходящий ребро (кроме тех, где A[i]=i),
# значит граф состоит из циклов и деревьев, входящих в циклы.

# Для каждой SCC (цикл или одиночная вершина без цикла) значения равны.
# Для дерева, ведущего в SCC, значения неубывающие по пути к SCC.

# Значит, можно рассчитать для каждой SCC количество способов выбора значения x_c ∈ [1..M].
# Для дерева, ведущего в SCC, количество способов - количество неубывающих последовательностей от листа к корню.

# Можно сделать обратный обход по графу, считая для каждой вершины количество способов.

# Предлагаю следующий алгоритм:

# 1) Найти SCC.
# 2) Построить DAG компонент.
# 3) Для каждой компоненты c определить размер (число вершин).
# 4) Для каждой компоненты c определить dp_c[v] - количество способов назначить значения вершинам компоненты и всем вершинам,
#    ведущим в неё, при условии, что значение компоненты c равно v.
# 5) Для компоненты без входящих рёбер dp_c[v] = v^{size_c} (т.к. значения в компоненте равны v, и для каждой вершины в компоненте x_i = v).
#    Но нужно учесть, что внутри компоненты все x_i равны, значит количество способов для компоненты - 1 (выбор значения v).
#    Но для деревьев, ведущих в компоненту, нужно учитывать неубывающие ограничения.

# Но проще:

# Для каждой компоненты c:
# - Если размер компоненты > 1 (цикл), то все вершины в компоненте равны x_c.
# - Если размер компоненты = 1 и нет ребра в себя, то это просто вершина.

# Построим DAG компонент, где ребро c1->c2 означает x_c1 ≤ x_c2.

# Для каждой компоненты c определим dp_c[v] - количество способов назначить значения вершинам в подграфе компоненты c и всех её предков,
# при условии, что x_c = v.

# Тогда для компоненты c:
# dp_c[v] = v^{size_c} * product по предкам p от sum_{u=1}^{v} dp_p[u]

# Но поскольку внутри компоненты все x_i равны x_c, количество способов для компоненты - 1 (выбор значения x_c),
# а для предков - сумма по u ≤ v.

# Значит, dp_c[v] = product по предкам p от prefix_sum_p[v]

# Для компоненты без предков dp_c[v] = 1

# Но нужно учитывать размер компоненты: внутри компоненты все x_i равны, значит количество способов для компоненты - 1 (выбор значения x_c).

# Таким образом, для компоненты c:
# dp_c[v] = product по предкам p от prefix_sum_p[v]

# prefix_sum_c[v] = sum_{i=1}^v dp_c[i]

# Итоговый ответ - сумма dp_c[v] по v для компонент без исходящих рёбер (стоков),
# но так как условие задано для всех i, и граф из ребер i->A[i], то итоговый ответ - сумма dp_c[v] по v для компонент без входящих рёбер (истоков).

# Но в нашем графе каждый i имеет ровно один выход (кроме тех, где A[i]=i), значит DAG компонент образует цепочки.

# Для упрощения, можно найти компоненты SCC, построить DAG компонент,
# и сделать топологический порядок по компонентам.

# Для каждой компоненты c:
# dp_c[v] = product по предкам p от prefix_sum_p[v]

# prefix_sum_c[v] = prefix_sum_c[v-1] + dp_c[v]

# Для компоненты без предков dp_c[v] = 1

# В конце ответ = sum_{v=1}^M dp_c[v] для компоненты, в которую входят вершины, на которые нет ребер (истоки).

# Но в нашем случае, поскольку каждый i имеет ровно один выход, то DAG компонент - это цепочки, и есть ровно одна компонента без входящих рёбер.

# Значит ответ = sum_{v=1}^M dp_c[v] для компоненты без входящих рёбер.

# Реализация:

# 1) Найти SCC (Косарайю).
# 2) Построить DAG компонент.
# 3) Найти топологический порядок.
# 4) Для каждой компоненты c в топологическом порядке вычислить dp_c[v].
# 5) Вывести сумму dp_c[v] для компоненты без входящих рёбер.

def kosaraju_scc(n, edges):
    g = [[] for _ in range(n)]
    gr = [[] for _ in range(n)]
    for u,v in edges:
        g[u].append(v)
        gr[v].append(u)
    order = []
    used = [False]*n
    def dfs1(u):
        used[u] = True
        for w in g[u]:
            if not used[w]:
                dfs1(w)
        order.append(u)
    for i in range(n):
        if not used[i]:
            dfs1(i)
    comp = [-1]*n
    def dfs2(u, cl):
        comp[u] = cl
        for w in gr[u]:
            if comp[w] == -1:
                dfs2(w, cl)
    j = 0
    for u in reversed(order):
        if comp[u] == -1:
            dfs2(u, j)
            j += 1
    return comp, j

edges = [(i, A[i]) for i in range(N)]
comp, K = kosaraju_scc(N, edges)

# Размеры компонент
size_comp = [0]*K
for c in comp:
    size_comp[c] += 1

# Построим DAG компонент
g_comp = [[] for _ in range(K)]
in_deg = [0]*K
for i in range(N):
    c1 = comp[i]
    c2 = comp[A[i]]
    if c1 != c2:
        g_comp[c1].append(c2)
        in_deg[c2] += 1

# Топологический порядок
from collections import deque
q = deque()
for i in range(K):
    if in_deg[i] == 0:
        q.append(i)
topo = []
while q:
    u = q.popleft()
    topo.append(u)
    for w in g_comp[u]:
        in_deg[w] -= 1
        if in_deg[w] == 0:
            q.append(w)

# Для каждой компоненты dp_c[v], v=1..M
# dp_c[v] = product по предкам p от prefix_sum_p[v]
# prefix_sum_c[v] = prefix_sum_c[v-1] + dp_c[v]

# Для компоненты без предков dp_c[v] = 1

# Найдем предков для каждой компоненты
pred = [[] for _ in range(K)]
for u in range(K):
    for w in g_comp[u]:
        pred[w].append(u)

dp = [None]*K
prefix = [None]*K

for c in topo:
    if not pred[c]:
        # Нет предков
        dp_c = [1]*(M+1)  # 1-based indexing, dp_c[0] не используется
        prefix_c = [0]*(M+1)
        for v in range(1, M+1):
            prefix_c[v] = (prefix_c[v-1] + dp_c[v]) % MOD
        dp[c] = dp_c
        prefix[c] = prefix_c
    else:
        dp_c = [1]*(M+1)
        for v in range(1, M+1):
            val = 1
            for p in pred[c]:
                val = (val * prefix[p][v]) % MOD
            dp_c[v] = val
        prefix_c = [0]*(M+1)
        for v in range(1, M+1):
            prefix_c[v] = (prefix_c[v-1] + dp_c[v]) % MOD
        dp[c] = dp_c
        prefix[c] = prefix_c

# Найдем компоненты без исходящих рёбер (стоки)
out_deg = [0]*K
for u in range(K):
    for w in g_comp[u]:
        out_deg[u] += 1

# Ответ - произведение по всем стокам суммы dp_c[v] по v=1..M
# Но в нашем графе из условия каждый i имеет ровно один выход, значит DAG компонент - цепочки,
# и есть ровно одна стоковая компонента (без исходящих рёбер).

ans = 1
for c in range(K):
    if out_deg[c] == 0:
        s = prefix[c][M]  # sum dp_c[v] по v=1..M
        ans = (ans * s) % MOD

print(ans)