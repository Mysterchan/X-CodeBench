#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n; cin >> n;
    vector<int> A(n);
    for (int i = 0; i < n; i++) cin >> A[i];

    // The key insight:
    // After operation (L,R), all A[L..R] become A[L].
    // The resulting sequence differs from original only in positions [L..R].
    // Positions outside [L..R] remain the same.
    //
    // To count distinct sequences, consider all pairs (L,R).
    // For fixed L, the replaced value is A[L].
    // The replaced segment is [L..R], R >= L.
    //
    // The resulting sequence is uniquely identified by (L, R) and A[L].
    // But sequences can coincide if the replaced segment is extended beyond
    // positions where A[i] == A[L], because replacing a segment with the same value
    // as original does not change those positions.
    //
    // So, for each L, the maximal R such that A[i] == A[L] for i in [L..R]
    // can be extended without changing the sequence.
    //
    // Therefore, for each L, the distinct sequences correspond to choosing R
    // from L to the last position where A[i] != A[L].
    //
    // More concretely:
    // For each L, the number of distinct sequences generated by varying R is:
    // (maxR - L + 1), where maxR is the last position where A[i] != A[L].
    //
    // But we must consider that replacing a segment with the same value as original
    // does not change the sequence.
    //
    // The original sequence is counted once.
    //
    // The total number of distinct sequences is:
    // 1 (original) + sum over all L of (number of distinct R that produce new sequences)
    //
    // To count efficiently:
    // For each position i, find the next position j > i where A[j] != A[i].
    // Then, for L = i, the possible R are from i to j-1 (inclusive).
    //
    // So number of distinct sequences from L = i is (j - i).
    //
    // Summing over i gives total sequences including original counted multiple times.
    //
    // But original sequence is counted once, so final answer is:
    // 1 + sum over i of (j - i - 1)
    //
    // Because R = L to j-1, total (j - i) sequences including R = i (which is no change).
    // So new sequences per i is (j - i - 1).
    //
    // Finally, answer = 1 + sum_{i=0}^{n-1} (j - i - 1) = 1 + sum_{i=0}^{n-1} (j - i) - n
    //
    // We'll implement this using a next different element array.

    vector<int> next_diff(n, n); // next position where A[pos] != A[i]
    // We'll process from right to left
    unordered_map<int, int> last_pos; // last position of each value
    for (int i = n - 1; i >= 0; i--) {
        if (last_pos.count(A[i])) {
            next_diff[i] = last_pos[A[i]];
        } else {
            next_diff[i] = n;
        }
        last_pos[A[i]] = i;
    }

    // Now sum over i of (next_diff[i] - i - 1)
    // next_diff[i] is the next position where A[i] != A[i], or n if none
    // Actually, next_diff[i] is the next occurrence of A[i], so positions between i and next_diff[i]-1 are equal to A[i]
    // So the maximal R for L=i is next_diff[i]-1
    // Number of distinct R for L=i is (next_diff[i] - i)
    // Number of new sequences (excluding R=i) is (next_diff[i] - i -1)

    long long ans = 1; // original sequence
    for (int i = 0; i < n; i++) {
        ans += (long long)(next_diff[i] - i - 1);
    }

    cout << ans << "\n";

    return 0;
}