import sys
sys.setrecursionlimit(10**7)

MOD = 998244353

N = int(sys.stdin.readline())
S = sys.stdin.readline().strip()

# DP approach based on the structure of valid parentheses sequences:
# Let dp[l][r] = number of distinct sequences obtainable from S[l:r+1]
# by the allowed operations.
# The operations allow reversing any valid substring, which means
# we can reorder concatenations of valid substrings arbitrarily.
#
# The key insight:
# - The string is a valid parentheses sequence.
# - It can be decomposed uniquely into concatenation of primitive valid sequences.
# - Reversing a valid substring corresponds to reversing a subtree in the parse tree.
# - The number of distinct sequences is the product of the number of distinct sequences
#   of each primitive component, multiplied by the number of ways to reorder these components
#   by reversing concatenations.
#
# However, the problem states the reversal operation is on valid substrings,
# and reversing a valid substring flips the order of concatenated valid sequences inside it.
#
# This means the number of distinct sequences for a valid sequence is:
# - If empty: 1
# - If (A): dp of A
# - If A B: dp(A) * dp(B) + dp(B) * dp(A) if A != B (because we can reverse the concatenation)
#   but since reversing is allowed on any valid substring, the order of concatenation can be reversed.
#
# But the problem states the reversal flips the substring and swaps '(' and ')'.
# This operation on a valid substring corresponds to reversing the order of concatenated valid sequences inside it.
#
# So the number of distinct sequences for a concatenation of two valid sequences A and B is:
# dp(A) * dp(B) + (if A != B) dp(B) * dp(A)
# But since sequences can be equal, and reversing twice returns to original,
# the number of distinct sequences for concatenation is:
# If A == B: dp(A)*dp(B)
# Else: dp(A)*dp(B)*2
#
# But the problem's sample shows that for (())() the answer is 2, which matches the idea that
# the two primitive sequences (()) and () can be reversed.
#
# To implement this efficiently, we parse the string into its primitive components,
# compute dp for each, and combine.

# We'll implement a DP that:
# - For each substring S[l:r], if it's valid, compute dp[l][r].
# - Use memoization to avoid recomputation.
# - Use the standard approach to find the matching parenthesis for each '('.

# Precompute matching parentheses using a stack
match = [-1]*N
stack = []
for i, ch in enumerate(S):
    if ch == '(':
        stack.append(i)
    else:
        j = stack.pop()
        match[j] = i

dp = [[-1]*(N) for _ in range(N)]

def dfs(l, r):
    if l > r:
        return 1  # empty string
    if dp[l][r] != -1:
        return dp[l][r]
    if match[l] != r:
        # The substring is concatenation of multiple valid sequences
        res = 1
        i = l
        while i <= r:
            j = match[i]
            res = (res * dfs(i, j)) % MOD
            i = j + 1
        dp[l][r] = res
        return res
    else:
        # substring is (A)
        res = dfs(l+1, r-1)
        dp[l][r] = res
        return res

# Now, the above dp counts the number of distinct sequences for the substring,
# but we need to consider that reversing concatenations can reorder components.
# The above dp counts only one order (the original order).
#
# To account for reversals, we need to consider that concatenations can be reversed,
# so for concatenation of multiple components, the number of distinct sequences is
# the number of distinct permutations of these components considering reversals.
#
# But the problem states the reversal operation reverses a valid substring,
# which can reverse the order of concatenated valid sequences inside it.
#
# For multiple concatenated components, the number of distinct sequences is
# the number of distinct sequences of each component multiplied by the number of
# distinct permutations of these components under reversal operations.
#
# Since reversal can only reverse contiguous substrings, the reachable sequences
# correspond to all sequences obtainable by reversing any contiguous subsequence of components.
#
# This is equivalent to the group generated by reversals of contiguous subsequences,
# which is the dihedral group acting on the sequence of components.
#
# The number of distinct sequences obtainable by reversing any contiguous subsequence
# of a sequence of length k is equal to the number of distinct sequences obtainable
# by applying any sequence of reversals of contiguous subsequences.
#
# It is known that the group generated by all reversals of contiguous subsequences
# is the full symmetric group on the sequence if all components are distinct.
#
# But since components can be equal, the number of distinct sequences is the number
# of distinct permutations of the multiset of components.
#
# However, the problem's sample input 1 shows only 2 sequences for (())(), which has two components: (()) and ()
# So the number of distinct sequences is 2, which matches the number of permutations of the components.
#
# So the problem reduces to:
# - Decompose S into primitive components (maximal valid substrings)
# - For each component, compute dp (number of distinct sequences for that component)
# - The total number of distinct sequences is the number of distinct permutations of these components,
#   multiplied by the product of dp of each component.
#
# Since components can be equal, the number of distinct permutations is factorial of number of components
# divided by factorial of counts of identical components.
#
# We need to:
# 1. Decompose S into primitive components.
# 2. For each component, compute dp recursively.
# 3. Count frequency of each component's dp result (or better, hash of component).
# 4. Compute factorial and inverse factorial for permutations count.
#
# To distinguish components, we can hash their dp results or the substring itself.
# But dp result alone is not unique enough.
#
# Instead, we can hash the substring itself (e.g. using a rolling hash) to identify identical components.
#
# Let's implement rolling hash to identify components.

# Precompute factorials for permutations count
max_k = N  # max number of components
fact = [1]*(max_k+1)
inv_fact = [1]*(max_k+1)
for i in range(2, max_k+1):
    fact[i] = fact[i-1]*i % MOD

def modinv(x):
    return pow(x, MOD-2, MOD)

inv_fact[max_k] = modinv(fact[max_k])
for i in reversed(range(max_k)):
    inv_fact[i] = inv_fact[i+1]*(i+1) % MOD

def nCr(n, r):
    if r > n or r < 0:
        return 0
    return fact[n]*inv_fact[r]%MOD*inv_fact[n-r]%MOD

# Rolling hash parameters
base = 131
mod1 = 10**9+7
mod2 = 10**9+9

prefix_hash1 = [0]*(N+1)
prefix_hash2 = [0]*(N+1)
power1 = [1]*(N+1)
power2 = [1]*(N+1)

for i in range(N):
    prefix_hash1[i+1] = (prefix_hash1[i]*base + (1 if S[i]=='(' else 2)) % mod1
    prefix_hash2[i+1] = (prefix_hash2[i]*base + (1 if S[i]=='(' else 2)) % mod2
    power1[i+1] = (power1[i]*base) % mod1
    power2[i+1] = (power2[i]*base) % mod2

def get_hash(l, r):
    x1 = (prefix_hash1[r+1] - prefix_hash1[l]*power1[r-l+1]) % mod1
    x2 = (prefix_hash2[r+1] - prefix_hash2[l]*power2[r-l+1]) % mod2
    return (x1, x2)

# Compute dp for all substrings
# We'll memoize dp[l][r] as number of distinct sequences for S[l:r+1]
# using the same dfs function as above.

def dfs_dp(l, r):
    if l > r:
        return 1
    if dp[l][r] != -1:
        return dp[l][r]
    if match[l] != r:
        # concatenation of multiple components
        res = 1
        i = l
        while i <= r:
            j = match[i]
            res = (res * dfs_dp(i, j)) % MOD
            i = j + 1
        dp[l][r] = res
        return res
    else:
        # (A)
        res = dfs_dp(l+1, r-1)
        dp[l][r] = res
        return res

# Decompose S into primitive components
components = []
i = 0
while i < N:
    j = match[i]
    components.append((i, j))
    i = j + 1

# For each component, compute dp and hash
comp_info = []
for l, r in components:
    val = dfs_dp(l, r)
    h = get_hash(l, r)
    comp_info.append((val, h))

# Count frequency of each component by hash and dp value
freq = {}
for val, h in comp_info:
    freq[(val, h)] = freq.get((val, h), 0) + 1

# Number of components
k = len(components)

# Number of distinct permutations of components considering identical ones:
# factorial(k) / product of factorial(freq_i)
perm_count = fact[k]
for v in freq.values():
    perm_count = (perm_count * inv_fact[v]) % MOD

# The total number of distinct sequences is:
# perm_count * product of dp(component)
prod_dp = 1
for val, h in comp_info:
    prod_dp = (prod_dp * val) % MOD

ans = (perm_count * prod_dp) % MOD

print(ans)