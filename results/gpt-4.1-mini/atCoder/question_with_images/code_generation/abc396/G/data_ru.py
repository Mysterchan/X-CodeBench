import sys
input = sys.stdin.readline

H, W = map(int, input().split())
rows = [int(input().strip(), 2) for _ in range(H)]

# Предположим, что мы сначала применим операции Y (по столбцам).
# Каждая операция Y с выбранным столбцом y инвертирует этот столбец во всех строках.
# После выбора набора столбцов для инверсии (битовая маска mask длины W),
# каждая строка будет XOR с mask.

# Затем мы можем применить операции X (по строкам).
# Для каждой строки мы можем либо оставить как есть, либо инвертировать (1 - A[i,j]),
# чтобы минимизировать сумму.

# Для фиксированного mask (выбранных столбцов для инверсии),
# для каждой строки i:
#   s = rows[i] ^ mask
#   количество единиц в s = popcount(s)
#   минимальное количество единиц после возможной инверсии строки = min(popcount(s), W - popcount(s))

# Задача: перебрать все mask (2^W), найти минимальную сумму по всем строкам.

# W ≤ 18, значит 2^W ≤ 262144 — перебор возможен.

def popcount(x):
    return bin(x).count('1')

ans = H * W  # максимум

for mask in range(1 << W):
    total = 0
    for r in rows:
        s = r ^ mask
        c = popcount(s)
        total += min(c, W - c)
        if total >= ans:
            break
    if total < ans:
        ans = total

print(ans)