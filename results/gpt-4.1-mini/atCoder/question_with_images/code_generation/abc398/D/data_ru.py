import sys
input = sys.stdin.readline

N, R, C = map(int, input().split())
S = input().strip()

# Смещение ветра для каждого направления
dir_map = {
    'N': (-1, 0),
    'W': (0, -1),
    'S': (1, 0),
    'E': (0, 1)
}

# Изначально дым в (0,0)
# На каждом шаге t дым сдвигается по ветру
# Если в (0,0) нет дыма после сдвига, появляется новый дым в (0,0)

# Нам нужно для каждого t определить, есть ли дым в (R,C) в момент t+0.5

# Рассмотрим обратный ход:
# Чтобы дым был в (R,C) в момент t+0.5, он должен был быть в (R',C') в момент (t-1)+0.5,
# где (R',C') - клетка, из которой ветер t-го шага сдвинул дым в (R,C).

# Также дым может появиться в (0,0) в момент t+0.5, если в (0,0) не было дыма в момент t-0.5.

# Будем идти по времени от 1 до N, храня множество клеток с дымом в момент t+0.5.
# Но N до 200000, множество может расти экспоненциально, это неэффективно.

# Оптимизация:
# Дым можно представить как множество путей, начинающихся в (0,0) в разные моменты времени,
# и сдвигающихся по ветру.

# Рассмотрим координаты (r_t, c_t) положения дыма, который появился в момент времени k (0 <= k <= t),
# и сдвигался ветром с k+1 по t.

# Тогда дым в момент t+0.5 - это объединение всех таких позиций для k=0..t.

# Нам нужно проверить, для каждого t, есть ли дым в (R,C).

# Перепишем условие:
# Для t, дым в (R,C) в момент t+0.5, если существует k (0 <= k <= t), такой что
# дым, появившийся в момент k (в (0,0)), сдвинулся ветром с k+1 по t и оказался в (R,C).

# Значит:
# (R,C) = sum_{i=k+1}^t (dx_i, dy_i)
# где (dx_i, dy_i) - сдвиг ветра на шаге i.

# Перепишем:
# sum_{i=1}^t (dx_i, dy_i) - sum_{i=1}^k (dx_i, dy_i) = (R,C)

# Обозначим prefix[i] = sum_{j=1}^i (dx_j, dy_j), prefix[0] = (0,0)

# Тогда:
# prefix[t] - prefix[k] = (R,C)
# => prefix[k] = prefix[t] - (R,C)

# Для каждого t нам нужно проверить, существует ли k <= t, что prefix[k] = prefix[t] - (R,C).

# Будем идти по t от 1 до N, вычислять prefix[t], и проверять, встречалось ли prefix[t] - (R,C) ранее.

# Если да, то ответ для t = '1', иначе '0'.

# Также prefix[0] = (0,0) встречается в начале.

prefix = [(0,0)]
dx = dy = 0
for ch in S:
    ddx, ddy = dir_map[ch]
    dx += ddx
    dy += ddy
    prefix.append((dx, dy))

pos_map = dict()
pos_map[(0,0)] = 0  # prefix[0]

res = []
for t in range(1, N+1):
    target = (prefix[t][0] - R, prefix[t][1] - C)
    # Проверяем, встречалось ли target в prefix с индексом <= t-1
    # Если да, значит существует k < t, prefix[k] = target
    # Тогда дым есть в (R,C) в момент t+0.5
    if target in pos_map and pos_map[target] < t:
        res.append('1')
    else:
        res.append('0')
    # Запоминаем prefix[t]
    if prefix[t] not in pos_map:
        pos_map[prefix[t]] = t

print(''.join(res))