import sys
sys.setrecursionlimit(10**7)

MOD = 998244353

def main():
    input = sys.stdin.readline
    N, M = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(M)]

    # Построим мультиграф в виде списка смежности с учётом кратных рёбер
    # Для подсчёта циклов нам важна только структура графа, кратные рёбра влияют на количество циклов
    # Но для подсчёта циклов в графе с кратными рёбрами, нужно учитывать, что каждое кратное ребро
    # даёт дополнительные варианты выбора.

    # Идея решения:
    # Количество циклов в неориентированном графе равно сумме по всем компонентам связности:
    # 2^{число рёбер в компоненте} - 2^{число вершин в компоненте} + 1
    # (Это количество циклов в циклическом пространстве графа, учитывая кратные рёбра)
    #
    # Обоснование:
    # Размер циклического пространства графа равен M - N + C,
    # где C - число компонент связности.
    #
    # Для каждой компоненты связности с n вершинами и m рёбрами количество циклов:
    # 2^m - 2^n + 1
    #
    # Итоговое количество циклов в графе - произведение по компонентам циклических пространств,
    # но так как циклы считаются как подмножества рёбер, то сумма по компонентам.

    # Однако, в условии требуется количество циклов (подмножеств рёбер, образующих простой цикл),
    # а не размер циклического пространства.
    #
    # В задаче "цикл" - простой цикл (без повторяющихся вершин), длины >= 2.
    #
    # Для графа с кратными рёбрами, каждый кратный ребро даёт дополнительные циклы длины 2 (петли из двух вершин).
    #
    # Таким образом, нужно:
    # 1) Найти все циклы длины 2 (кратные рёбра между двумя вершинами) - каждый набор из k кратных рёбер между двумя вершинами
    #    даёт C(k,2) циклов длины 2.
    # 2) Найти количество простых циклов длины >= 3.
    #
    # Для N ≤ 20 можно перебрать все подмножества вершин и проверить, образуют ли они простой цикл.
    # Но M может быть до 2*10^5, перебор рёбер невозможен.
    #
    # Решение:
    # - Для циклов длины 2: считаем количество кратных рёбер между каждой парой вершин.
    # - Для циклов длины >= 3: перебираем все подмножества вершин размером k (от 3 до N),
    #   и проверяем, образуют ли они простой цикл.
    #
    # Но перебор всех подмножеств вершин невозможен (2^N = 1_048_576, но для каждого нужно проверять рёбра).
    #
    # Оптимизация:
    # - Перебираем все циклы с помощью поиска в глубину (DFS) с ограничением длины.
    # - Для N=20 можно перебрать все простые циклы с помощью поиска в глубину с запоминанием посещённых вершин.
    #
    # Но M до 2*10^5, значит граф может быть очень плотным.
    #
    # Однако, в условии N ≤ 20, значит можно хранить граф в виде матрицы смежности.
    # Для кратных рёбер будем хранить количество рёбер между вершинами.
    #
    # Алгоритм:
    # 1) Считаем количество кратных рёбер между каждой парой вершин.
    # 2) Количество циклов длины 2 = сумма по всем парам вершин C(k,2), где k - количество рёбер между ними.
    # 3) Для циклов длины >= 3:
    #    - Перебираем все простые циклы с помощью DFS.
    #    - Чтобы не считать циклы несколько раз, будем считать циклы, начинающиеся с минимальной вершины в цикле.
    #    - Для этого запускаем DFS из каждой вершины v, ищем циклы, которые возвращаются в v, при этом все вершины > v.
    #    - Ограничиваем длину цикла до N (максимум).
    #
    # Для подсчёта количества циклов с кратными рёбрами:
    # - Если в цикле есть ребро с кратностью k, то количество вариантов выбора ребра из этих k равно k.
    # - Общее количество вариантов для цикла - произведение кратностей рёбер в цикле.
    #
    # Итог: считаем сумму по всем простым циклам произведение кратностей рёбер в цикле.
    #
    # Реализация:
    # - Матрица кратностей: mult[u][v] = количество рёбер между u и v (u < v)
    # - Для DFS используем битмаску посещённых вершин.
    # - Для каждого цикла считаем произведение кратностей рёбер.
    #
    # Сложность: N=20, DFS с ограничением длины, должно работать.

    mult = [[0]*N for _ in range(N)]
    for u,v in edges:
        u -= 1
        v -= 1
        if u > v:
            u,v = v,u
        mult[u][v] += 1

    # Подсчёт циклов длины 2 (кратные рёбра)
    ans = 0
    for i in range(N):
        for j in range(i+1,N):
            k = mult[i][j]
            if k >= 2:
                # количество циклов длины 2 - количество пар рёбер между i и j
                # C(k,2) = k*(k-1)//2
                ans += k*(k-1)//2
    ans %= MOD

    # Построим список смежности для DFS (без кратностей, но с кратностями отдельно)
    adj = [[] for _ in range(N)]
    for i in range(N):
        for j in range(i+1,N):
            if mult[i][j] > 0:
                adj[i].append(j)
                adj[j].append(i)

    # Для подсчёта циклов длины >= 3
    # Запускаем DFS из каждой вершины start
    # Чтобы не считать циклы несколько раз, будем искать циклы, где все вершины > start, кроме start
    # Это гарантирует уникальность подсчёта.

    visited = 0
    from math import prod

    # Для быстрого доступа к кратности рёбер между двумя вершинами
    def edge_mult(u,v):
        if u > v:
            u,v = v,u
        return mult[u][v]

    res = 0

    def dfs(start, current, depth, visited_mask, path):
        nonlocal res
        if depth >= 2:
            # Проверяем, есть ли ребро от current к start (замыкает цикл)
            if start in adj[current]:
                # Проверяем, что длина цикла >= 3
                # path + start образуют цикл
                # Вычисляем произведение кратностей рёбер в цикле
                cycle_vertices = path + [start]
                prod_mult = 1
                for i in range(len(cycle_vertices)-1):
                    u = cycle_vertices[i]
                    v = cycle_vertices[i+1]
                    prod_mult = (prod_mult * edge_mult(u,v)) % MOD
                res = (res + prod_mult) % MOD

        if depth == N:
            return

        for nxt in adj[current]:
            if nxt <= start:
                # Чтобы избежать повторного подсчёта, посещаем только вершины > start
                continue
            if (visited_mask & (1 << nxt)) != 0:
                continue
            dfs(start, nxt, depth+1, visited_mask | (1 << nxt), path + [nxt])

    for start in range(N):
        dfs(start, start, 0, 1 << start, [start])

    ans = (ans + res) % MOD

    print(ans)

if __name__ == "__main__":
    main()