import sys
import bisect

input = sys.stdin.readline

N, M = map(int, input().split())
segments = []
for _ in range(M):
    A, B = map(int, input().split())
    if A > B:
        A, B = B, A
    segments.append((A, B))

# Отрезки не пересекаются между собой, все A_i и B_i - четные.
# Отсортируем по левому концу
segments.sort()

# Для быстрого поиска будем хранить отдельно списки левых и правых концов
L = [seg[0] for seg in segments]
R = [seg[1] for seg in segments]

Q = int(input())
for _q in range(Q):
    C, D = map(int, input().split())
    if C > D:
        C, D = D, C

    # Запрос: отрезок с нечетными концами C и D
    # Нужно посчитать, сколько из M отрезков (A_i,B_i) пересекаются с (C,D)

    # Пересечение отрезков (A,B) и (C,D) на окружности с нумерацией по часовой стрелке
    # происходит, если и только если:
    # (A < C < B < D) или (C < A < D < B)
    # Но т.к. точки расположены по кругу, и все отрезки (A_i,B_i) не пересекаются,
    # можно считать, что все отрезки (A_i,B_i) лежат внутри интервала [A_i,B_i] по часовой стрелке.
    #
    # Для отрезка (C,D) с нечетными концами, он разбивает круг на два полуинтервала:
    # [C,D] и [D,C] (по часовой стрелке).
    #
    # Отрезок (A,B) пересекается с (C,D) если и только если один из концов (A,B) лежит внутри (C,D),
    # а другой - вне (C,D).
    #
    # Т.к. все A_i и B_i - четные, а C,D - нечетные, и точки пронумерованы по часовой стрелке,
    # можно считать, что точки идут по кругу от 1 до 2N.
    #
    # Для упрощения рассмотрим линейный порядок от 1 до 2N.
    # Если C < D, то интервал (C,D) - это все точки с номерами > C и < D.
    #
    # Отрезок (A,B) пересекает (C,D) если и только если:
    # (A < C < B < D) или (C < A < D < B)
    #
    # Но проще проверить условие:
    # Отрезок (A,B) пересекает (C,D) если и только если:
    # (A < C < B and (D < A or D > B)) или (C < A < D and (B < C or B > D))
    #
    # Но проще проверить:
    # Отрезок (A,B) пересекает (C,D) если и только если:
    # (A < C < B < D) или (C < A < D < B)
    #
    # Т.к. все отрезки (A_i,B_i) не пересекаются, они не вложены друг в друга.
    #
    # Можно проверить пересечение так:
    # Отрезок (A,B) пересекает (C,D) если и только если:
    # (A < C < B and (D < A or D > B)) или (C < A < D and (B < C or B > D))
    #
    # Но проще:
    # Отрезок (A,B) пересекает (C,D) если и только если:
    # (A < C < B < D) или (C < A < D < B)
    #
    # Т.к. все отрезки (A_i,B_i) не пересекаются, они упорядочены по левому концу.
    #
    # Для фиксированного (C,D) с C < D:
    # Пересекаются те отрезки (A,B), для которых:
    # A < D и B > C, и при этом не полностью лежат внутри (C,D) или вне (C,D).
    #
    # Но проще:
    # Пересекают (C,D) те отрезки (A,B), для которых:
    # A < D и B > C, и при этом (A < C < B < D) или (C < A < D < B)
    #
    # Рассмотрим условие пересечения для упорядоченных отрезков:
    # Пересекаются, если и только если:
    # (A < C < B < D) или (C < A < D < B)
    #
    # Значит, нам нужно посчитать количество отрезков (A,B), для которых выполняется одно из этих условий.
    #
    # Перебор всех отрезков слишком дорог.
    #
    # Решение:
    # Отрезки не пересекаются, значит они упорядочены и не вложены.
    # Значит, для каждого отрезка (A,B) можно считать, что A < B и отрезки не пересекаются.
    #
    # Для фиксированного (C,D):
    # Пересекаются те отрезки (A,B), для которых:
    # A < C < B < D  => A < C < B и B < D
    # или
    # C < A < D < B  => C < A < D и D < B
    #
    # Значит:
    # Кол-во отрезков, пересекающих (C,D) = 
    # количество отрезков с A < C < B < D + количество отрезков с C < A < D < B
    #
    # Для подсчёта:
    # 1) Найдем количество отрезков с A < C и B < D и B > C (т.е. A < C < B < D)
    # 2) Найдем количество отрезков с A > C и A < D и B > D (т.е. C < A < D < B)
    #
    # Для этого:
    # - Отрезки отсортированы по A.
    # - Для 1) нужно найти отрезки с A < C и B < D и B > C
    #   - Найдем индекс pos1 = bisect_left(L, C) - отрезки с A < C
    #   - Среди них посчитаем, сколько имеют B < D и B > C
    # - Для 2) отрезки с A > C и A < D и B > D
    #   - Найдем индексы pos2 = bisect_left(L, C+1), pos3 = bisect_left(L, D)
    #   - Среди отрезков с индексами [pos2, pos3) посчитаем, сколько имеют B > D
    #
    # Для эффективного подсчёта будем использовать отсортированные списки и бинарный поиск.
    #
    # Для 1) среди отрезков с индексами [0, pos1) нужно посчитать количество B, удовлетворяющих C < B < D
    # Для 2) среди отрезков с индексами [pos2, pos3) нужно посчитать количество B > D
    #
    # Для этого подготовим префиксные структуры.
    #
    # Но проще:
    # Для каждого запроса:
    # - Найдем pos1 = bisect_left(L, C)
    # - Среди B[:pos1] посчитаем количество B > C и B < D
    # - Найдем pos2 = bisect_left(L, C+1)
    # - pos3 = bisect_left(L, D)
    # - Среди B[pos2:pos3] посчитаем количество B > D
    #
    # Для подсчёта количества B в диапазоне используем сортировку B и бинарный поиск.
    #
    # Но B не отсортирован по возрастанию, а по A отсортирован.
    # Значит, для B[:pos1] нужно быстро считать количество B в интервале (C,D).
    #
    # Для этого построим Fenwick tree (BIT) по B, но B может быть до 2N (до 2*10^6).
    #
    # Но M ≤ 2*10^5, значит можно сжать координаты B.
    #
    # Построим массив B_sorted = sorted(B)
    # Для каждого запроса будем делать бинарный поиск по B_sorted.
    #
    # Для подсчёта количества B в диапазоне (C,D) среди первых pos1 элементов:
    # - Для каждого i от 0 до M-1, запишем B[i]
    # - Построим Fenwick tree по B, добавляя B[i] в позицию i
    #
    # Но Fenwick tree по B[i] не подходит, т.к. B[i] - значения, а не индексы.
    #
    # Решение:
    # Построим Fenwick tree по индексам i (от 0 до M-1), где в позиции i лежит B[i].
    # Для запроса:
    # - Нужно посчитать, сколько B[i] в B[:pos1] лежат в интервале (C,D)
    #
    # Для этого:
    # - Отсортируем B по возрастанию, сохраним индексы.
    # - Для каждого запроса:
    #   - Найдем pos1 = bisect_left(L, C)
    #   - Среди B[:pos1] посчитаем количество B[i], где C < B[i] < D
    #
    # Для этого построим Fenwick tree по B[i], где Fenwick tree хранит количество отрезков с B[i] ≤ x.
    #
    # Но B[i] не отсортирован по i, а i - индекс в L.
    #
    # Решение:
    # Построим массив пар (B[i], i), отсортируем по B[i].
    # Для каждого запроса:
    # - Найдем pos1 = bisect_left(L, C)
    # - Нужно посчитать, сколько i < pos1 имеют B[i] в (C,D)
    #
    # Для этого:
    # - Для каждого B[i], i, в порядке возрастания B[i], обновим Fenwick tree по i.
    # - Для запроса:
    #   - Найдем индексы в B_sorted для C и D
    #   - Посчитаем количество i < pos1 с B[i] в (C,D) через Fenwick tree.
    #
    # Аналогично для второго условия.
    #
    # Но это сложно реализовать за один проход.
    #
    # Упростим:
    # Для каждого запроса:
    # - Переберём отрезки, у которых A < D и B > C
    # - Но это слишком дорого.
    #
    # Альтернативный подход:
    # Отрезки не пересекаются, значит они упорядочены и не вложены.
    # Значит, можно считать, что отрезки упорядочены по A и B монотонно возрастают.
    #
    # Тогда для запроса (C,D):
    # Пересекаются те отрезки (A,B), для которых:
    # A < D и B > C
    #
    # Т.к. L и R отсортированы по A, то:
    # - Найдем pos = bisect_left(L, D) - отрезки с A < D
    # - Среди них посчитаем, сколько имеют B > C
    #
    # Для подсчёта количества B > C среди первых pos элементов:
    # - Можно отсортировать R и для каждого запроса делать бинарный поиск.
    #
    # Но R не отсортирован по A, а по индексу i.
    #
    # Решение:
    # Построим Fenwick tree по B, где для i-го отрезка в позиции i Fenwick tree хранит 1.
    # Для запроса:
    # - Найдем pos = bisect_left(L, D)
    # - Посчитаем количество отрезков с индексами < pos и B > C
    #
    # Для этого:
    # - Отсортируем отрезки по B
    # - Для каждого запроса:
    #   - Найдем pos по L
    #   - Посчитаем количество отрезков с индексами < pos и B > C
    #
    # Для этого построим массив индексов отрезков, отсортированных по B.
    #
    # Для каждого запроса:
    # - Найдем pos по L
    # - Посчитаем количество отрезков с индексами < pos и B > C
    #
    # Для подсчёта количества отрезков с индексами < pos и B > C:
    # - Для каждого B[i], i, отсортируем по B
    # - Построим Fenwick tree по индексам i
    # - Для каждого запроса:
    #   - Найдем pos по L
    #   - Найдем индекс в B_sorted для C
    #   - Посчитаем количество отрезков с индексами < pos и B > C через Fenwick tree
    #
    # Но это сложно.
    #
    # Упростим:
    # Пересечение отрезков (A,B) и (C,D) на окружности с нумерацией по часовой стрелке
    # происходит, если и только если:
    # (A < C < B < D) или (C < A < D < B)
    #
    # Т.к. отрезки не пересекаются, они упорядочены и не вложены.
    #
    # Значит, можно считать, что отрезки упорядочены по A и B монотонно возрастают.
    #
    # Тогда для запроса (C,D):
    # Пересекаются те отрезки (A,B), для которых:
    # A < C < B < D  или  C < A < D < B
    #
    # Рассмотрим два случая отдельно:
    #
    # 1) A < C < B < D
    # - Найдем pos1 = bisect_left(L, C)
    # - Среди отрезков с индексами < pos1 посчитаем количество с B < D и B > C
    #
    # 2) C < A < D < B
    # - Найдем pos2 = bisect_left(L, C+1)
    # - pos3 = bisect_left(L, D)
    # - Среди отрезков с индексами в [pos2, pos3) посчитаем количество с B > D
    #
    # Для подсчёта количества B в диапазоне используем отсортированные списки и бинарный поиск.
    #
    # Для 1):
    # - Для B[:pos1] отсортируем B и посчитаем количество B в (C,D)
    #
    # Для 2):
    # - Для B[pos2:pos3] отсортируем B и посчитаем количество B > D
    #
    # Для этого для каждого запроса будем делать бинарный поиск.
    #
    # Но сортировать B для каждого запроса дорого.
    #
    # Решение:
    # Для каждого запроса:
    # - pos1 = bisect_left(L, C)
    # - pos2 = bisect_left(L, C+1)
    # - pos3 = bisect_left(L, D)
    #
    # Для B[:pos1] отсортируем B[:pos1] и посчитаем количество B в (C,D)
    # Для B[pos2:pos3] отсортируем B[pos2:pos3] и посчитаем количество B > D
    #
    # Но сортировка для каждого запроса дорогая.
    #
    # Можно заранее подготовить B отсортированный по A.
    #
    # Для каждого запроса:
    # - Используем bisect для поиска pos1, pos2, pos3
    # - Для B[:pos1] и B[pos2:pos3] используем бинарный поиск, т.к. B отсортирован по A, но не по B.
    #
    # Значит, для каждого запроса нужно сортировать подмассив B, что дорого.
    #
    # Альтернативный подход:
    # Используем структуру данных для подсчёта количества B в диапазоне индексов и значений.
    #
    # Построим Fenwick tree по B, где индексы - позиции в массиве B, значения - 1.
    #
    # Для запроса:
    # - pos1 = bisect_left(L, C)
    # - Посчитаем количество B[i] в B[:pos1], где B[i] в (C,D)
    #
    # Для этого:
    # - Сжимаем координаты B
    # - Для каждого i добавляем 1 в Fenwick tree в позиции сжатого B[i]
    #
    # Но Fenwick tree по B[i] не позволяет быстро считать по индексу i.
    #
    # Решение:
    # Построим Fenwick tree по индексам i (0..M-1), где в позиции i лежит B[i].
    # Для запроса:
    # - Посчитаем количество i < pos1, для которых B[i] в (C,D)
    #
    # Для этого:
    # - Для каждого запроса:
    #   - Переберём B[:pos1], посчитаем количество B[i] в (C,D) через бинарный поиск.
    #
    # Но перебор B[:pos1] для каждого запроса дорог.
    #
    # Итог:
    # Задача сводится к подсчёту количества отрезков (A,B), для которых A < D и B > C.
    #
    # Т.к. отрезки не пересекаются, они упорядочены и не вложены.
    #
    # Значит, можно считать, что B монотонно возрастает.
    #
    # Проверим монотонность B:
    # Если B монотонно возрастает, то для pos = bisect_left(L, D):
    # Количество отрезков с A < D и B > C = pos - (количество отрезков с B ≤ C среди первых pos)
    #
    # Для подсчёта количества отрезков с B ≤ C среди первых pos можно использовать Fenwick tree.
    #
    # Проверим монотонность B:
    # Если B не монотонно, то задача сложнее.
    #
    # В условии гарантируется, что отрезки не пересекаются.
    # Значит, они упорядочены и не вложены, значит B монотонно возрастает.
    #
    # Проверим на примерах:
    # В примере 1:
    # Отрезки: (2,4), (6,8)
    # L = [2,6], R = [4,8] - B монотонно возрастает.
    #
    # В примере 2:
    # Отрезки:
    # 24 34
    # 26 28
    # 18 38
    # 2 14
    # 8 12
    # 30 32
    # 20 22
    #
    # Отсортируем по A:
    # (2,14), (8,12), (18,38), (20,22), (24,34), (26,28), (30,32)
    # B = [14,12,38,22,34,28,32]
    #
    # B не монотонно возрастает.
    #
    # Значит, B не монотонно возрастает.
    #
    # Тогда используем структуру данных для подсчёта количества B > C среди первых pos элементов.
    #
    # Построим Fenwick tree по B:
    # - Сжимаем координаты B
    # - Для каждого i добавим 1 в Fenwick tree в позиции сжатого B[i]
    #
    # Для запроса:
    # - pos = bisect_left(L, D)
    # - Нужно посчитать количество i < pos с B[i] > C
    #
    # Для этого:
    # - Количество i < pos = pos
    # - Количество i < pos с B[i] ≤ C = fenwicksum(pos, compressed_C)
    # - Ответ = pos - fenwicksum(pos, compressed_C)
    #
    # Для fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
    #
    # Для этого построим Fenwick tree по индексам i, где в позиции i лежит сжатое значение B[i].
    #
    # Но Fenwick tree обычно строится по одномерному массиву.
    #
    # Нам нужна структура, которая по индексу i и значению B[i] может быстро считать количество i < pos с B[i] ≤ x.
    #
    # Это задача 2D-запроса: количество точек (i, B[i]) с i < pos и B[i] ≤ x.
    #
    # Решение:
    # Построим массив точек (i, B[i])
    # Отсортируем точки по i (уже отсортированы)
    # Для каждого запроса (pos, x) нужно посчитать количество точек с i < pos и B[i] ≤ x
    #
    # Для этого построим Fenwick tree по i, где в каждой позиции i лежит B[i].
    #
    # Но Fenwick tree по i не позволяет быстро считать по B[i].
    #
    # Решение:
    # Используем offline обработку запросов:
    #
    # 1) Сжимаем B[i]
    # 2) Создаем события:
    #    - Для каждого i: событие "добавить точку" (i, B[i])
    #    - Для каждого запроса: событие "запрос" (pos, C)
    #
    # 3) Отсортируем события по pos
    # 4) Обрабатываем события по возрастанию pos:
    #    - При событии "добавить точку" добавляем 1 в Fenwick tree по B[i]
    #    - При событии "запрос" считаем fenwicksum по B ≤ C
    #
    # Таким образом, для каждого запроса получаем количество i < pos с B[i] ≤ C
    #
    # Аналогично для второго условия.
    #
    # Итоговый ответ для запроса:
    # count = count_1 + count_2
    #
    # где
    # count_1 = количество отрезков с A < C и C < B < D
    # count_2 = количество отрезков с C < A < D и B > D
    #
    # Для count_1:
    # pos1 = bisect_left(L, C)
    # Нужно посчитать количество i < pos1 с B[i] в (C,D)
    #
    # Для count_2:
    # pos2 = bisect_left(L, C+1)
    # pos3 = bisect_left(L, D)
    # Нужно посчитать количество i в [pos2, pos3) с B[i] > D
    #
    # Для count_1:
    # count_1 = fenwicksum(pos1, D-1) - fenwicksum(pos1, C)
    #
    # Для count_2:
    # count_2 = (pos3 - pos2) - (fenwicksum(pos3, D) - fenwicksum(pos2, D))
    #
    # Построим Fenwick tree для подсчёта fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
    #
    # Для этого:
    # - Сжимаем B[i]
    # - Для каждого i создаем событие "добавить" (i, B[i])
    # - Для каждого запроса создаем события для count_1 и count_2
    #
    # Обработаем все события offline.
    #
    # Реализация ниже.

class Fenwick2D:
    def __init__(self, n, max_b):
        self.n = n
        self.max_b = max_b
        self.tree = [dict() for _ in range(n+1)]

    # Но dict в Fenwick tree медленный, лучше использовать Fenwick tree по B для каждого i
    # Но это 2D Fenwick tree, слишком сложно.
    #
    # Упростим:
    # Для fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
    # Можно сделать Fenwick tree по i, где в каждой позиции i лежит B[i].
    #
    # Для этого:
    # - Отсортируем точки (i, B[i]) по i
    # - Для каждого запроса (pos, x) нужно посчитать количество i < pos с B[i] ≤ x
    #
    # Решение:
    # Построим массив B по i
    # Для каждого запроса:
    # - Посчитаем количество i < pos с B[i] ≤ x
    #
    # Для этого:
    # - Для каждого уникального B[i] создадим список индексов i, где B[i] = val
    # - Для запроса:
    #   - Переберём все B[i] ≤ x и посчитаем количество i < pos
    #
    # Но перебор всех B[i] ≤ x дорог.
    #
    # Альтернативный подход:
    # Построим Fenwick tree по i, где в позиции i лежит 1.
    # Для каждого запроса:
    # - Посчитаем количество i < pos
    # - Посчитаем количество i < pos с B[i] > x
    #
    # Для подсчёта количества i < pos с B[i] > x:
    # - Построим массив B_sorted = sorted(set(B))
    # - Для каждого B[i], i, создадим событие "добавить" в Fenwick tree по B[i]
    # - Для запроса:
    #   - fenwicksum(pos, max_B) - fenwicksum(pos, x)
    #
    # Но Fenwick tree по двум параметрам сложно.
    #
    # Итог:
    # Используем offline обработку запросов:
    #
    # 1) Сжимаем B
    # 2) Создаем события:
    #    - Для каждого i: событие "add" (i, B[i])
    #    - Для каждого запроса:
    #      - Для count_1: событие "query1" (pos1, C, D, idx)
    #      - Для count_2: событие "query2" (pos2, pos3, D, idx)
    #
    # 3) Обрабатываем события по возрастанию pos
    #
    # Для count_1:
    # - fenwicksum(pos1, D-1) - fenwicksum(pos1, C)
    #
    # Для count_2:
    # - (pos3 - pos2) - (fenwicksum(pos3, D) - fenwicksum(pos2, D))
    #
    # Для fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
    #
    # Построим Fenwick tree по B[i], где индексы - позиции i.
    #
    # Для этого:
    # - Отсортируем отрезки по i (уже отсортированы)
    # - Для каждого i добавим 1 в Fenwick tree в позиции сжатого B[i]
    #
    # Для fenwicksum(pos, x):
    # - Посчитаем количество i < pos с B[i] ≤ x
    #
    # Для этого:
    # - Для каждого B[i], i, создадим событие "add" (i, B[i])
    # - Для каждого запроса "query" (pos, x)
    #
    # Обработаем события по возрастанию pos:
    # - При "add" обновим Fenwick tree по B[i]
    # - При "query" посчитаем fenwicksum по B[i] ≤ x
    #
    # Реализация ниже.

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.fw = [0]*(n+1)
    def update(self, i, v):
        i += 1
        while i <= self.n:
            self.fw[i] += v
            i += i & (-i)
    def query(self, i):
        s = 0
        i += 1
        while i > 0:
            s += self.fw[i]
            i -= i & (-i)
        return s
    def range_query(self, l, r):
        return self.query(r) - self.query(l-1)

# Сжимаем B
B_vals = list(set(R))
B_vals.sort()
def compress(x):
    return bisect.bisect_left(B_vals, x)

B_comp = [compress(x) for x in R]

# События для offline обработки:
# Событие: (pos, type, data)
# type = 0 - add (i, B_comp[i])
# type = 1 - query1 (pos1, C, D, idx)
# type = 2 - query2 (pos2, pos3, D, idx)

Q = int(input())
queries = []
for i in range(Q):
    C, D = map(int, input().split())
    if C > D:
        C, D = D, C
    queries.append((C, D, i))

# Для каждого запроса нужно:
# count_1 = fenwicksum(pos1, D-1) - fenwicksum(pos1, C)
# count_2 = (pos3 - pos2) - (fenwicksum(pos3, D) - fenwicksum(pos2, D))

# Для fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
# Создадим события:
# - add: (i, B_comp[i])
# - query1: (pos1, C, D, idx)
# - query2: (pos3, D, +1, idx)
# - query2: (pos2, D, -1, idx)

events = []

for i, b in enumerate(B_comp):
    events.append((i, 0, b))  # add

# Для запросов подготовим события
# Для fenwicksum(pos, x) нужно искать B[i] ≤ x
# Но C и D - не обязательно есть в B_vals, поэтому сжимаем C и D тоже
def compress_val(x):
    return bisect.bisect_right(B_vals, x) - 1  # индекс максимального B_vals ≤ x, или -1 если нет

answers = [0]*Q

query_events = []

for C, D, idx in queries:
    pos1 = bisect.bisect_left(L, C)
    pos2 = bisect.bisect_left(L, C+1)
    pos3 = bisect.bisect_left(L, D)

    # Для count_1:
    # fenwicksum(pos1, D-1) - fenwicksum(pos1, C)
    # fenwicksum(pos, x) - количество i < pos с B[i] ≤ x
    d1 = bisect.bisect_right(B_vals, D-1) - 1
    c1 = bisect.bisect_right(B_vals, C) - 1

    if d1 < 0:
        d1 = -1
    if c1 < 0:
        c1 = -1

    # Добавим запросы для count_1
    # fenwicksum(pos1, d1)
    query_events.append((pos1, 1, d1, idx, +1))
    # fenwicksum(pos1, c1)
    query_events.append((pos1, 1, c1, idx, -1))

    # Для count_2:
    # (pos3 - pos2) - (fenwicksum(pos3, D) - fenwicksum(pos2, D))
    d2 = bisect.bisect_right(B_vals, D) - 1
    if d2 < 0:
        d2 = -1

    # fenwicksum(pos3, d2)
    query_events.append((pos3, 1, d2, idx, -1))
    # fenwicksum(pos2, d2)
    query_events.append((pos2, 1, d2, idx, +1))

    # Сохраним (pos3 - pos2) для count_2
    answers[idx] += (pos3 - pos2)

# Объединим события и отсортируем по pos
# События add: (pos, 0, b)
# События query: (pos, 1, b, idx, sign)
events += query_events
events.sort(key=lambda x: (x[0], x[1]))

fenw = Fenwick(len(B_vals))

for e in events:
    if e[1] == 0:
        # add
        _, _, b = e
        fenw.update(b, 1)
    else:
        # query
        pos, _, b, idx, sign = e
        if b < 0:
            val = 0
        else:
            val = fenw.query(b)
        answers[idx] += sign * val

for ans in answers:
    print(ans)