import sys
input = sys.stdin.readline

MOD = 998244353

# Для плитки типа A (четыре варианта):
# 0: верх-право (UR)
# 1: прав-низ (RD)
# 2: низ-лево (DL)
# 3: лево-верх (LU)
# Для плитки типа B (два варианта):
# 0: верх-низ (UD)
# 1: лево-право (LR)

# Для каждой ячейки мы должны выбрать вариант так, чтобы для каждой границы
# между соседними ячейками (по горизонтали и вертикали) либо обе стороны
# имеют отрезок, либо обе не имеют.

# Условие тупиков означает, что для каждой границы (ребра) между ячейками
# либо обе стороны соединены отрезками, либо обе не соединены.

# Рассмотрим граф, где вершины - стороны ячеек (середины сторон),
# а ребра - отрезки на плитках.
# Условие тупиков означает, что ребра между ячейками согласованы.

# Анализ:
# Горизонтальные ребра: между (i,j) справа и (i,j+1) слева
# Вертикальные ребра: между (i,j) снизу и (i+1,j) сверху
# Все индексы по модулю H и W (тор).

# Для каждой ячейки (i,j) мы выбираем вариант отрезка.
# Для типа A - 4 варианта, для типа B - 2 варианта.

# Задача сводится к подсчету количества раскрасок клеток в варианты,
# при которых для каждой границы согласованность.

# Рассмотрим отдельно горизонтальные и вертикальные ребра.

# Горизонтальные ребра:
# Для ячейки (i,j) вариант определяет, есть ли отрезок на правой стороне.
# Для ячейки (i,(j+1)%W) вариант определяет, есть ли отрезок на левой стороне.
# Они должны совпадать (оба есть или оба нет).

# Аналогично для вертикальных ребер.

# Значит, для каждой строки (фиксированное i) горизонтальные ребра
# накладывают ограничения на варианты соседних ячеек по горизонтали.

# Для каждой колонки (фиксированное j) вертикальные ребра
# накладывают ограничения на варианты соседних ячеек по вертикали.

# Таким образом, у нас есть двумерная сетка с ограничениями по горизонтали и вертикали.

# Рассмотрим отдельно горизонтальные и вертикальные ограничения.

# Для горизонтальных ребер:
# Для каждой строки i, варианты соседних ячеек (j и j+1) должны иметь
# одинаковое значение "есть ли отрезок справа у (i,j)" и "есть ли отрезок слева у (i,j+1)".

# Аналогично для вертикальных ребер:
# Для каждой колонки j, варианты соседних ячеек (i и i+1) должны иметь
# одинаковое значение "есть ли отрезок снизу у (i,j)" и "есть ли отрезок сверху у (i+1,j)".

# Значит, для каждой ячейки (i,j) мы можем представить вариант как пару бит:
# (h, v) - h=1 если есть отрезок справа, v=1 если есть отрезок снизу.

# Для типа A варианты (4):
# 0: UR => h=1 (право), v=0 (низ)
# 1: RD => h=1 (право), v=1 (низ)
# 2: DL => h=0 (право), v=1 (низ)
# 3: LU => h=0 (право), v=0 (низ)

# Для типа B варианты (2):
# 0: UD => h=0 (право), v=1 (низ)
# 1: LR => h=1 (право), v=0 (низ)

# Проверим соответствие:
# A: 0(UR): h=1, v=0
#    1(RD): h=1, v=1
#    2(DL): h=0, v=1
#    3(LU): h=0, v=0
# B: 0(UD): h=0, v=1
#    1(LR): h=1, v=0

# Теперь условие согласованности:
# Для горизонтальных ребер (i,j) и (i,j+1):
# h(i,j) == h(i,j+1) (т.к. h(i,j) - отрезок справа у (i,j),
# а у (i,j+1) слева отрезок есть, если h(i,j+1) == 1)
# Но слева у (i,j+1) отрезок есть, если h(i,j+1) == 1 (т.к. h - отрезок справа)
# Но слева у (i,j+1) - это отрезок справа у (i,j), значит h(i,j) == h(i,j+1)

# Аналогично для вертикальных ребер:
# v(i,j) == v(i+1,j)

# Значит, для каждой строки i, h(i,j) одинаково для всех j (т.к. h(i,j) == h(i,j+1) по модулю W)
# Для каждой колонки j, v(i,j) одинаково для всех i (т.к. v(i,j) == v(i+1,j) по модулю H)

# Итого:
# Для каждой строки i существует бит h_i (0 или 1), одинаковый для всех j
# Для каждой колонки j существует бит v_j (0 или 1), одинаковый для всех i

# Теперь для каждой ячейки (i,j) вариант определяется битами h_i и v_j.

# Но не все комбинации (h_i, v_j) допустимы для типа плитки в (i,j).

# Для типа A допустимы варианты:
# (h,v) = (1,0), (1,1), (0,1), (0,0) - все 4 варианта

# Для типа B допустимы варианты:
# (0,1) и (1,0) только

# Значит:
# Для A: любые (h,v)
# Для B: только (0,1) или (1,0)

# Теперь задача сводится к выбору битов h_i для каждой строки и v_j для каждой колонки,
# таких что для каждой ячейки (i,j) (h_i, v_j) допустимы.

# Для A - нет ограничений
# Для B - (h_i, v_j) ∈ {(0,1), (1,0)}

# Рассмотрим B ячейки:
# Для каждой B ячейки (i,j) (h_i, v_j) ∈ {(0,1), (1,0)} => h_i != v_j

# Значит для B ячеек h_i != v_j
# Для A ячеек нет ограничений

# Теперь задача:
# Найти количество пар (h, v), где h - битовый вектор длины H, v - битовый вектор длины W,
# таких что для всех B ячеек (i,j) h_i != v_j.

# Аналогично, для A ячеек нет ограничений.

# Решение:
# Рассмотрим граф с вершинами: строки (h_i) и столбцы (v_j).
# Рёбра между i и j, если (i,j) - B ячейка.
# Требование: для ребра (i,j) h_i != v_j.

# Значит, граф двудольный (строки и столбцы), и на рёбрах требуется раскраска в 2 цвета,
# где вершины строк и столбцов - две доли, и ребра требуют разного цвета.

# Значит, для каждой компоненты связности графа B:
# h_i и v_j должны быть раскрашены в 2 цвета, где вершины строк и столбцов - разные доли.

# Если граф B не двудольный - решения нет (но он по определению двудольный, т.к. вершины двух типов).

# Но есть дополнительное условие: для каждой компоненты связности
# мы можем выбрать цвет для одной доли (например, h_i=0 для строк в компоненте),
# тогда цвета для столбцов определятся (v_j=1), и наоборот.

# Значит, для каждой компоненты связности графа B есть 2 варианта раскраски (выбор цвета для строк).

# Теперь рассмотрим строки и столбцы, которые не связаны с B ячейками:
# Для строк без рёбер B, h_i может быть 0 или 1 (2 варианта)
# Для столбцов без рёбер B, v_j может быть 0 или 1 (2 варианта)

# Итого:
# - Для каждой компоненты связности графа B: 2 варианта
# - Для каждой строки без рёбер B: 2 варианта
# - Для каждой колонки без рёбер B: 2 варианта

# Теперь посчитаем общее количество вариантов (h,v) = 2^(число компонент B) * 2^(число строк без B) * 2^(число столбцов без B)
# = 2^(число компонент B + число строк без B + число столбцов без B)

# Но это количество вариантов (h,v).

# Теперь для каждого (h,v) мы должны подсчитать количество вариантов выбора конкретных вариантов плиток.

# Для каждой ячейки:
# - Если A: 4 варианта (все (h,v) допустимы)
# - Если B: 2 варианта (только (0,1) и (1,0))

# Но мы уже зафиксировали (h_i, v_j), значит для A ячейки 1 вариант (т.к. (h_i,v_j) фиксированы),
# но у A 4 варианта, значит для A ячейки с фиксированным (h_i,v_j) количество вариантов равно
# количеству вариантов плитки, дающих этот (h,v).

# Для A:
# (h,v) может быть любой из 4 вариантов, значит для A ячейки с (h,v) фиксированным,
# количество вариантов равно числу вариантов плитки A, дающих (h,v).

# Аналогично для B:
# (h,v) ∈ {(0,1),(1,0)} - 2 варианта, значит для B ячейки с (h,v) фиксированным,
# количество вариантов равно 1 (т.к. только один вариант плитки соответствует (h,v)).

# Подсчитаем для A:
# Варианты A:
# 0: (1,0)
# 1: (1,1)
# 2: (0,1)
# 3: (0,0)

# Для каждого (h,v) у A количество вариантов плиток:
# (0,0): 1 (вариант 3)
# (0,1): 1 (вариант 2)
# (1,0): 1 (вариант 0)
# (1,1): 1 (вариант 1)

# Значит для A ячейки с фиксированным (h,v) ровно 1 вариант.

# Для B:
# (0,1) и (1,0) - по 1 варианту
# Значит для B ячейки с фиксированным (h,v) ровно 1 вариант.

# Но в условии сказано, что для A плиток 4 варианта вращения, для B - 2 варианта вращения.
# Но мы уже зафиксировали (h,v), то есть конкретный вариант отрезка.

# Значит, для каждого (h,v) ровно 1 вариант плитки соответствует.

# Итого, для каждого (h,v) фиксированного, количество вариантов выбора плиток = 1.

# Значит, общее количество вариантов = количество вариантов (h,v).

# Но в условии сказано, что общее количество вариантов = 4^a * 2^b,
# где a - количество A, b - количество B.

# Мы нашли, что количество вариантов, удовлетворяющих условию тупиков, равно
# 2^(число компонент B + число строк без B + число столбцов без B).

# Но это количество вариантов (h,v).

# Теперь надо учесть, что для каждого (h,v) фиксированного, количество вариантов выбора плиток равно 1.

# Значит, итоговый ответ = 2^(число компонент B + число строк без B + число столбцов без B).

# Проверим на примерах из условия.

# Реализация:

sys.setrecursionlimit(10**7)

T = int(input())
total_cells = 0

for _ in range(T):
    H, W = map(int, input().split())
    S = [input().strip() for __ in range(H)]
    total_cells += H*W

# Проверка ограничения
assert total_cells <= 10**6

# Теперь реализуем решение:

def solve(H, W, S):
    # Построим граф B: вершины - строки (0..H-1) и столбцы (H..H+W-1)
    # Ребро между i (строка) и H+j (столбец), если S[i][j] == 'B'
    # Требование: h_i != v_j

    # Для подсчёта компонент связности используем DFS

    adj = [[] for _ in range(H+W)]
    row_has_B = [False]*H
    col_has_B = [False]*W

    for i in range(H):
        for j in range(W):
            if S[i][j] == 'B':
                adj[i].append(H+j)
                adj[H+j].append(i)
                row_has_B[i] = True
                col_has_B[j] = True

    visited = [False]*(H+W)

    def dfs(u):
        stack = [u]
        comp = []
        while stack:
            x = stack.pop()
            if visited[x]:
                continue
            visited[x] = True
            comp.append(x)
            for y in adj[x]:
                if not visited[y]:
                    stack.append(y)
        return comp

    # Подсчитаем число компонент связности в графе B
    comp_count = 0
    for i in range(H+W):
        if not visited[i] and (i < H and row_has_B[i] or i >= H and col_has_B[i - H]):
            dfs(i)
            comp_count += 1

    # Количество строк без B
    row_no_B = sum(1 for i in range(H) if not row_has_B[i])
    # Количество столбцов без B
    col_no_B = sum(1 for j in range(W) if not col_has_B[j])

    # Итоговое количество вариантов:
    # 2^(comp_count + row_no_B + col_no_B) mod MOD
    exp = comp_count + row_no_B + col_no_B
    return pow(2, exp, MOD)

for _ in range(T):
    H, W = map(int, input().split())
    S = [input().strip() for __ in range(H)]
    print(solve(H, W, S))