import sys
input = sys.stdin.readline

N, X = map(int, input().split())
U = [0]*N
D = [0]*N
for i in range(N):
    u, d = map(int, input().split())
    U[i] = u
    D[i] = d

S = [U[i] + D[i] for i in range(N)]

# Нам нужно найти H и конечные U_i', D_i' такие, что:
# 1) U_i' + D_i' = H для всех i
# 2) |U_i' - U_{i+1}'| ≤ X для i=1..N-1
# 3) U_i' ≤ U_i, D_i' ≤ D_i (т.к. можно только уменьшать)
# 4) Стоимость = сумма (U_i - U_i') + (D_i - D_i') минимальна

# Перепишем:
# U_i' = H - D_i'
# Но D_i' ≤ D_i, U_i' ≤ U_i
# Значит: D_i' ≥ H - U_i и D_i' ≤ D_i
# Для каждого i: D_i' ∈ [max(0, H - U_i), D_i]

# Аналогично для U_i':
# U_i' = H - D_i' ≤ U_i => D_i' ≥ H - U_i
# D_i' ≤ D_i

# Условие на разницу U_i':
# |U_i' - U_{i+1}'| ≤ X
# => |(H - D_i') - (H - D_{i+1}')| ≤ X
# => |D_{i+1}' - D_i'| ≤ X

# Значит D_i' должны удовлетворять:
# D_i' ∈ [L_i, R_i], где L_i = max(0, H - U_i), R_i = D_i
# и |D_{i+1}' - D_i'| ≤ X

# Задача сводится к:
# Для заданного H найти D_i' в [L_i, R_i], с ограничением на разницу соседних элементов ≤ X,
# минимизирующих сумму (D_i - D_i') + (U_i - U_i') = sum(U_i + D_i - H) + sum(|D_i' - D_i|)
# Но sum(U_i + D_i - H) = sum(S) - N*H - константа для данного H
# Минимизируем sum(|D_i' - D_i|)

# Для фиксированного H минимизируем sum(|D_i' - D_i|) при ограничениях:
# D_i' ∈ [L_i, R_i]
# |D_{i+1}' - D_i'| ≤ X

# Это задача о нахождении последовательности D_i' с ограничениями на диапазон и разницу соседних элементов,
# минимизирующей сумму абсолютных отклонений от D_i.

# Решение для фиксированного H:
# 1) Сначала сдвигаем интервалы с учетом ограничения на разницу соседних элементов:
#    - Проход слева направо: D_{i+1}' ≥ D_i' - X => R_{i+1} = min(R_{i+1}, R_i + X)
#    - Проход справа налево: D_i' ≥ D_{i+1}' - X => L_i = max(L_i, L_{i+1} - X)
# 2) После этого интервалы [L_i, R_i] гарантируют, что существует последовательность с разницей ≤ X.
# 3) Теперь выбираем D_i' в этих интервалах, минимизируя sum |D_i' - D_i|.
#    Оптимально выбрать D_i' = D_i, если D_i ∈ [L_i, R_i], иначе ближайшую границу.

# Теперь остается подобрать H, чтобы минимизировать общую стоимость:
# cost(H) = sum(S) - N*H + sum(|D_i' - D_i|)

# H может быть в диапазоне [H_min, H_max], где:
# H_min = max(S) - т.к. H ≥ S_i для возможности D_i' ≥ 0
# H_max = min(U_i + D_i) (но это может быть очень большим)
# Но на самом деле H может быть от min(S) до max(S), т.к. мы можем уменьшать зубы.

# Однако, H не может быть больше min(S), иначе придется увеличивать зубы (нельзя).
# H не может быть меньше max(S), иначе D_i' < 0 для некоторых i.

# Значит H ∈ [max(S), min(S)] - пустой интервал, если max(S) > min(S)
# Но S_i = U_i + D_i, они фиксированы, значит max(S) = min(S) = H
# Но в условии можно уменьшать зубы, значит H ≤ min(S), H ≥ max(S)
# Значит H ∈ [max(S), min(S)] (возможно max(S) ≤ min(S))

# Если max(S) > min(S), то нет решения без увеличения зубов (нельзя)
# Но в условии можно уменьшать зубы, значит H ≤ min(S)
# Но H ≥ max(S) (т.к. U_i' + D_i' = H, а U_i' ≤ U_i, D_i' ≤ D_i, значит H ≤ S_i)
# Значит H ≤ min(S), H ≥ max(S)
# Если max(S) > min(S), решения нет.

# Проверим:
maxS = max(S)
minS = min(S)
if maxS > minS:
    # Нет решения, т.к. H не может быть одновременно ≥ maxS и ≤ minS
    # Но в условии не сказано, что решения нет, значит minS ≥ maxS
    # Если нет решения, ответ будет 0 (или невозможно)
    # Но по условию всегда можно уменьшать зубы, значит minS ≥ maxS
    pass

# Переберем H в диапазоне [maxS, minS]
# Но minS ≥ maxS, значит H = maxS..minS (возможно один или несколько значений)
# Но диапазон может быть очень большой (до 2*10^9), перебор невозможен.

# Функция cost(H) выпуклая, т.к. сумма абсолютных отклонений от D_i' - выпуклая по H
# Можно применить ternary search по H.

def calc_cost(H):
    L = [0]*N
    R = [0]*N
    for i in range(N):
        L[i] = max(0, H - U[i])
        R[i] = D[i]
        if L[i] > R[i]:
            return 10**20  # Невозможно

    # Ограничения на разницу соседних D_i':
    # Проход слева направо
    for i in range(N-1):
        if R[i+1] > R[i] + X:
            R[i+1] = R[i] + X
            if R[i+1] < L[i+1]:
                return 10**20
    # Проход справа налево
    for i in range(N-1, 0, -1):
        if L[i-1] < L[i] - X:
            L[i-1] = L[i] - X
            if L[i-1] > R[i-1]:
                return 10**20

    # Теперь выбираем D_i' минимизирующие |D_i' - D_i| в [L_i, R_i]
    cost = 0
    for i in range(N):
        if D[i] < L[i]:
            cost += L[i] - D[i]
        elif D[i] > R[i]:
            cost += D[i] - R[i]
        else:
            cost += 0

    # Общая стоимость:
    # sum(S) - N*H + cost
    return sum(S) - N*H + cost

# ternary search по H в [maxS, minS]
left = maxS
right = minS

# Если maxS == minS, ответ сразу
if left == right:
    print(calc_cost(left))
    sys.exit()

for _ in range(60):
    m1 = left + (right - left) / 3
    m2 = right - (right - left) / 3
    c1 = calc_cost(m1)
    c2 = calc_cost(m2)
    if c1 > c2:
        left = m1
    else:
        right = m2

# Проверим целые значения около left и right
ans = 10**20
for H in range(int(left)-2, int(right)+3):
    if maxS <= H <= minS:
        c = calc_cost(H)
        if c < ans:
            ans = c

print(ans)