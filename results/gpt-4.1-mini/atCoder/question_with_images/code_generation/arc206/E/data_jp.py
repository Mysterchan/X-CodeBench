import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N = int(input())
    U = list(map(int, input().split()))
    D = list(map(int, input().split()))
    L = list(map(int, input().split()))
    R = list(map(int, input().split()))

    # 良いマスは盤面の外周のうち角を除いた部分
    # 操作は良いマス2つを選び、その矩形内を黒く塗る
    # すべてのマスを黒くするには、内側のマスも含めて全体を覆う必要がある

    # 盤面の全マスを黒くするためには、内側のマスも含めて
    # 操作で覆う矩形の集合が盤面全体を覆う必要がある

    # 操作のコストは選んだ2つの良いマスの値の和
    # 目的は全マスを黒くするための操作のコストの総和の最小化

    # 考察:
    # 盤面の良いマスは4辺のうち角を除いた部分で、各辺にN-2個ずつある
    # 操作は良いマス2つを選び、その矩形内を黒く塗る
    # 盤面の内側のマスは (2..N-1, 2..N-1)
    # これらの内側マスを覆うには、少なくとも上下の辺の良いマスから1つずつ選び、
    # 左右の辺の良いマスから1つずつ選ぶ必要がある

    # つまり、全体を覆うには、上下の良いマスのうち1つずつと左右の良いマスのうち1つずつを選び、
    # それらの4点で囲まれた矩形で覆う必要がある

    # しかし操作は2点ずつしか選べないので、複数回の操作で全体を覆う必要がある

    # しかし、問題のサンプル解説から、
    # 操作は良いマス2つを選び、その矩形内を黒く塗る
    # これを複数回行い、すべてのマスを黒くする

    # 重要なことは、良いマスは4辺に分かれているので、
    # それぞれの辺の良いマスは独立にペアを作って操作に使われる

    # 盤面の内側のマスは、上下の辺の良いマスのペアで覆うことができる
    # 同様に左右の辺の良いマスのペアで覆うことができる

    # つまり、上下の辺の良いマスのペアで横方向の内側を覆い、
    # 左右の辺の良いマスのペアで縦方向の内側を覆う

    # さらに、4隅のマスは白色で初期状態なので、
    # それらは良いマスではないため操作で覆う必要はない

    # したがって、操作は上下の辺の良いマスのペアと左右の辺の良いマスのペアに分けて考えられる

    # 操作は良いマス2つを選ぶが、同じ良いマスは1回しか使えない
    # よって、各辺の良いマスはペアを作って操作に使う必要がある

    # つまり、UとDはそれぞれN-2個の良いマスの値
    # LとRも同様

    # これらの良いマスはそれぞれペアを作って操作に使う
    # それぞれの辺の良いマスはペアを作って操作に使うので、
    # それぞれの辺の良いマスの値の合計はペアの和の合計になる

    # しかし、ペアの組み方によってコストが変わる
    # 目的はコストの総和を最小化すること

    # ここで重要なことは、操作で覆う矩形は2点の良いマスで決まる
    # 盤面の内側のマスは、上下の辺の良いマスのペアで覆うことができる
    # 同様に左右の辺の良いマスのペアで覆うことができる

    # つまり、上下の辺の良いマスのペアで横方向の内側を覆い、
    # 左右の辺の良いマスのペアで縦方向の内側を覆う

    # したがって、上下の辺の良いマスのペアの和の最小値と、
    # 左右の辺の良いマスのペアの和の最小値の合計が答えになる

    # ここで、上下の辺の良いマスはUとD
    # 左右の辺の良いマスはLとR

    # それぞれの辺の良いマスはN-2個ずつある
    # それらをペアに分けて操作に使う

    # しかし、操作は良いマス2つを選ぶが、同じ良いマスは1回しか使えない
    # つまり、Uの良いマスは1回だけ使える
    # Dの良いマスも1回だけ使える
    # Lの良いマスも1回だけ使える
    # Rの良いマスも1回だけ使える

    # しかし、UとDは別の辺なので、Uの良いマスとDの良いマスをペアにして操作に使うことができる
    # 同様にLとRもペアにできる

    # つまり、UとDの良いマスを1対1でペアにして操作に使い、
    # LとRの良いマスを1対1でペアにして操作に使う

    # これらのペアの和の合計が答えになる

    # したがって、UとDの良いマスのペアの和の最小値は、
    # UとDのそれぞれの要素をソートして対応する要素同士を足した和の合計
    # 同様にLとRも同様にする

    U.sort()
    D.sort()
    L.sort()
    R.sort()

    ans = 0
    for i in range(N-2):
        ans += U[i] + D[i]
        ans += L[i] + R[i]

    print(ans)