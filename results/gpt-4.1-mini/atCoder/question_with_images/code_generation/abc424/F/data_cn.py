import sys
input = sys.stdin.readline

N, Q = map(int, input().split())
queries = [tuple(map(int, input().split())) for _ in range(Q)]

# 题意简化：
# 圆上点按顺时针编号1..N，线段连接A_i和B_i (A_i < B_i)
# 线段相交的条件是：
# 对已画线段 (a,b) 和新线段 (c,d)，若 a < c < b < d 或 c < a < d < b，则相交。
# 由于所有端点互不相同，且A_i < B_i，且点编号是顺时针排列，
# 线段相交等价于区间交叉但不包含的情况。

# 观察：
# 线段 (A,B) 可以看作区间 [A,B]，线段相交等价于区间交叉但不包含。
# 由于所有端点互不相同，且A_i < B_i，且所有端点两两不同，
# 线段不相交等价于这些区间两两不交叉。

# 这就是经典的“区间不相交”问题。
# 维护已画线段的区间集合，判断新区间是否与已有区间交叉。

# 由于Q最大3*10^5，N最大10^6，使用平衡树或线段树较复杂。
# 但这里可以用一个栈模拟：
# 按查询顺序处理线段，维护一个栈，栈中存储已画线段的右端点，且这些线段的左端点严格递增。
# 规则：
# - 新线段 (A,B) 若A > 栈顶线段的左端点且B < 栈顶线段的右端点，则相交，拒绝。
# - 否则，弹出所有右端点小于B的线段，保证栈中线段右端点递增。
# - 然后将新线段入栈。

# 证明：
# 这种方法保证栈中线段互不相交，且新线段与栈中线段不相交。

stack = []  # 存储已画线段的右端点，左端点隐含递增
# 由于我们需要左端点和右端点都存储，存成 (A,B)

for A, B in queries:
    # 检查是否与栈顶线段相交
    # 若栈顶线段为 (a,b)，相交条件是 a < A < b < B 或 A < a < B < b
    # 由于栈中线段左端点递增，且右端点递增
    # 只需判断是否存在栈顶线段满足 a < A < b < B
    # 若满足，则相交，输出 No
    # 否则，弹出所有右端点 < B 的线段，入栈 (A,B)
    if stack and stack[-1][0] < A < stack[-1][1] < B:
        print("No")
        continue
    # 弹出所有右端点小于B的线段
    while stack and stack[-1][1] < B:
        stack.pop()
    stack.append((A, B))
    print("Yes")