import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

T = int(input())

# Идея решения:
# Условие "u не является предком v" означает, что пары (u,v) нельзя брать из одной цепочки предков.
# Значит, пары можно брать только из разных ветвей дерева.
# Максимальное количество операций — максимальное количество пар вершин, которые можно выбрать,
# при этом пары не должны быть в отношениях предок-потомок.
#
# Рассмотрим дерево. Если мы выберем вершины из разных поддеревьев, они не будут в отношениях предок-потомок.
# Значит, задача сводится к максимальному паросочетанию между вершинами, принадлежащими разным поддеревьям.
#
# Рассмотрим корень 1 и его детей. Пусть у корня k детей, и размеры их поддеревьев s_1, s_2, ..., s_k.
# Все вершины в поддеревьях детей корня не связаны отношением предок-потомок между собой.
# Значит, пары можно формировать только между вершинами из разных поддеревьев.
#
# Максимальное количество пар — максимальное количество пар, которые можно составить из всех вершин,
# при условии, что пары берутся из разных поддеревьев.
#
# Это классическая задача: максимальное количество пар, где пары берутся из разных множеств.
# Максимальное количество пар = (общий размер - максимальный размер поддерева) // 2
#
# Почему?
# - Максимальное количество пар — это максимальное количество пар, которые можно составить,
#   не беря две вершины из одного поддерева.
# - Если мы возьмем все вершины кроме самого большого поддерева, то они могут быть попарно соединены
#   с вершинами из этого самого большого поддерева.
# - Максимальное количество пар — это минимальное из:
#   - половина от общего количества вершин (т.к. пары по 2 вершины)
#   - сумма размеров всех поддеревьев кроме самого большого (т.к. пары должны быть между разными поддеревьями)
#
# Но в нашем случае, поскольку пары берутся из разных поддеревьев, максимальное количество пар равно
# минимальному из:
# - сумма размеров всех поддеревьев кроме самого большого (т.к. каждая вершина из меньших поддеревьев
#   может быть соединена с вершиной из большого поддерева)
# - половина от общего количества вершин (т.к. пары по 2 вершины)
#
# В итоге ответ = min((N // 2), N - max_subtree_size)

for _ in range(T):
    N = int(input())
    if N == 2:
        # Единственный ребенок, нельзя выбрать пару (u,v) с u не предком v, т.к. 1 - корень и 2 - ребенок
        # 1 является предком 2, значит нельзя выбрать пару (1,2)
        print(0)
        input()  # прочитать p_2
        continue

    p = list(map(int, input().split()))
    # Строим дерево
    children = [[] for __ in range(N+1)]
    for i in range(2, N+1):
        children[p[i-2]].append(i)

    # Вычислим размеры поддеревьев детей корня
    def dfs_size(u):
        sz = 1
        for c in children[u]:
            sz += dfs_size(c)
        return sz

    max_subtree = 0
    for c in children[1]:
        s = dfs_size(c)
        if s > max_subtree:
            max_subtree = s

    # Ответ
    ans = min(N // 2, N - max_subtree)
    print(ans)