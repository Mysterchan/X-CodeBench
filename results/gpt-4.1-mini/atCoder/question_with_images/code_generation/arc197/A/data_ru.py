import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    H, W = map(int, input().split())
    S = input().strip()

    # Количество D и R в S
    count_D = S.count('D')
    count_R = S.count('R')

    # Остаток D и R, которые можно использовать для замены '?'
    rem_D = (H - 1) - count_D
    rem_R = (W - 1) - count_R

    # Пройдем по S слева направо, заменяя '?' на D или R, чтобы получить минимальный путь
    # Минимальный путь: заменяем '?' на D, пока можем, иначе на R
    # Это путь, который будет "сдвигать" вниз как можно раньше
    # Запишем этот путь в массив left_path
    left_path = []
    d_used = count_D
    r_used = count_R
    for c in S:
        if c == '?':
            if rem_D > 0:
                left_path.append('D')
                rem_D -= 1
                d_used += 1
            else:
                left_path.append('R')
                rem_R -= 1
                r_used += 1
        else:
            left_path.append(c)

    # Аналогично, пройдем по S справа налево, заменяя '?' на R, пока можем, иначе на D
    # Это путь, который будет "сдвигать" вправо как можно раньше
    rem_D = (H - 1) - count_D
    rem_R = (W - 1) - count_R
    right_path = []
    d_used = count_D
    r_used = count_R
    for c in reversed(S):
        if c == '?':
            if rem_R > 0:
                right_path.append('R')
                rem_R -= 1
                r_used += 1
            else:
                right_path.append('D')
                rem_D -= 1
                d_used += 1
        else:
            right_path.append(c)
    right_path.reverse()

    # Теперь у нас есть два пути:
    # left_path - минимальный по вертикали (сдвигаемся вниз как можно раньше)
    # right_path - минимальный по горизонтали (сдвигаемся вправо как можно раньше)

    # Посчитаем для каждого префикса left_path количество D и R
    prefix_D = [0]
    prefix_R = [0]
    for c in left_path:
        prefix_D.append(prefix_D[-1] + (c == 'D'))
        prefix_R.append(prefix_R[-1] + (c == 'R'))

    # Аналогично для right_path, но считаем суффиксы
    suffix_D = [0]*(len(S)+1)
    suffix_R = [0]*(len(S)+1)
    for i in range(len(S)-1, -1, -1):
        suffix_D[i] = suffix_D[i+1] + (right_path[i] == 'D')
        suffix_R[i] = suffix_R[i+1] + (right_path[i] == 'R')

    # Идея: мы можем выполнить операции с разными путями X.
    # Максимальное количество закрашенных клеток - это объединение клеток, посещенных всеми выбранными путями.
    # Чтобы максимизировать количество, нужно объединить пути, которые покрывают разные клетки.
    # Рассмотрим разбиение S на две части в позиции i:
    # - первая операция: путь left_path[0:i]
    # - вторая операция: путь right_path[i:]
    # Тогда объединение клеток будет:
    # (i+1) + (H+W-1 - i) - 1 = H+W-1 (т.к. начальная клетка считается один раз)
    # Но мы можем получить больше, если пути различаются.

    # Однако, в условии операции можно выполнять любое количество раз,
    # и каждый раз выбирать любой путь X, удовлетворяющий условиям.
    # Максимальное количество закрашенных клеток - это количество клеток,
    # которые покрываются объединением всех таких путей.

    # Рассмотрим, что максимальное покрытие - это сумма:
    # (количество строк, которые можно достичь) + (количество столбцов, которые можно достичь) - 1
    # Но нужно учесть ограничения S.

    # В задаче из editorial (известная задача AtCoder ARC 033 D),
    # ответ равен сумме:
    # (количество строк, которые можно достичь) + (количество столбцов, которые можно достичь) - 1
    # где количество строк = минимальное количество D в любом пути,
    # количество столбцов = минимальное количество R в любом пути.

    # Но в нашем случае, чтобы получить максимальное количество закрашенных клеток,
    # нужно посчитать сумму:
    # (количество D в left_path) + (количество R в right_path) + 1

    # Но это не совсем так, нужно посчитать максимальное значение:
    # max_{0 ≤ i ≤ len(S)} (prefix_D[i] + suffix_R[i] + 1)
    # или
    # max_{0 ≤ i ≤ len(S)} (prefix_R[i] + suffix_D[i] + 1)
    # в зависимости от того, как мы комбинируем пути.

    # Попробуем оба варианта и возьмем максимум.

    max_cells = 0
    n = len(S)
    for i in range(n+1):
        # вариант 1: prefix_D[i] + suffix_R[i] + 1
        val1 = prefix_D[i] + suffix_R[i] + 1
        # вариант 2: prefix_R[i] + suffix_D[i] + 1
        val2 = prefix_R[i] + suffix_D[i] + 1
        if val1 > max_cells:
            max_cells = val1
        if val2 > max_cells:
            max_cells = val2

    print(max_cells)