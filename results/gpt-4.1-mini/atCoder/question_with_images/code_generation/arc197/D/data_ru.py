import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

MOD = 998244353

T = int(input())

# По условию:
# A[i,j] = 1 тогда и только тогда, когда j на пути от 1 до i или i на пути от 1 до j.
# Это означает, что множество вершин, для которых A[i,j]=1, задаёт структуру дерева с корнем в 1,
# где A[i,j]=1 <=> j и i лежат на пути друг к другу через корень 1.
#
# Из этого следует, что для i != j:
# A[i,j] = 1 <=> j предок i или i предок j (в дереве с корнем 1).
#
# Вершина 1 - корень, A[i,i]=1, A симметрична.
#
# Задача: посчитать количество деревьев G на N вершинах с корнем 1,
# для которых матрица A совпадает с матрицей предков (по определению).
#
# Анализ:
# Для i != 1 множество {j | A[i,j] = 1} - это путь от 1 до i (включая 1 и i).
# Значит, для каждой вершины i, множество предков - это путь от 1 до i.
#
# Следовательно, для каждой вершины i множество предков - цепочка, содержащая 1 и i.
#
# Из этого следует, что множество предков i включено в множество предков j или наоборот,
# если i и j лежат на одной ветке.
#
# Таким образом, множество предков задаёт частично упорядоченное множество (по включению),
# которое должно быть деревом путей от корня 1.
#
# В итоге, A задаёт частично упорядоченное множество предков, которое должно быть деревом путей.
#
# Задача сводится к подсчёту количества деревьев с корнем 1, для которых множества предков совпадают с A.
#
# Ключевая идея решения:
# Рассмотрим граф G', где ребро (u,v) есть тогда и только тогда, когда A[u,v] = 1 и
# множество предков u и v отличаются ровно на одну вершину (т.е. они соседние в дереве).
#
# Для построения дерева G нам нужно:
# - Проверить, что A задаёт частично упорядоченное множество предков, которое является деревом путей.
# - Подсчитать количество таких деревьев.
#
# Из условия и примеров видно, что:
# - A[i,j] = 1 <=> j на пути от 1 до i или i на пути от 1 до j.
# - Значит, для i != j, A[i,j] = 1 означает, что i и j лежат на одной цепочке от корня.
#
# Следовательно, множество вершин можно разбить на поддеревья, где каждая вершина i имеет уникального родителя p(i),
# такой что множество предков i = множество предков p(i) + {i}.
#
# Алгоритм:
# 1) Для каждой вершины i != 1 определим множество предков P_i = {j | A[i,j] = 1}.
# 2) Проверим, что P_i содержит 1 и i.
# 3) Для каждой вершины i != 1 найдём родителя p(i) - вершину из P_i, для которой P_p(i) = P_i \ {i}.
#    Если такого родителя нет или он не единственный, ответ 0.
# 4) Построим дерево по найденным родителям.
# 5) Проверим, что для всех i,j A[i,j] = 1 тогда и только тогда, когда j на пути от 1 до i или i на пути от 1 до j.
#    Если не совпадает, ответ 0.
# 6) Подсчитаем количество деревьев, удовлетворяющих условию.
#
# Но в условии сказано "найти количество деревьев G", удовлетворяющих условию.
# Из анализа и примеров видно, что таких деревьев может быть несколько.
#
# Как посчитать количество?
#
# Рассмотрим вершину 1 - корень.
# Для каждой вершины i != 1 множество предков P_i - цепочка от 1 до i.
# Родитель i - вершина p(i), для которой P_p(i) = P_i \ {i}.
#
# Если для i существует несколько кандидатов p(i), то количество вариантов увеличивается.
#
# Значит, для каждой вершины i != 1 количество вариантов выбора родителя равно количеству вершин p,
# для которых P_p = P_i \ {i}.
#
# Тогда общее количество деревьев равно произведению по i != 1 количества таких родителей.
#
# Проверим на примерах:
# - В первом примере из условия ответ 1.
# - Во втором примере ответ 2.
#
# Таким образом, алгоритм:
# - Для каждой вершины i != 1 найдём множество предков P_i.
# - Для каждого i != 1 найдём количество вершин p, для которых P_p = P_i \ {i}.
# - Если количество равно 0, ответ 0.
# - Иначе перемножим все количества по модулю.
#
# Проверка корректности:
# - Проверим, что A[i,i] = 1 и A симметрична.
# - Проверим, что для i != j A[i,j] = 1 => либо P_i включено в P_j, либо P_j включено в P_i.
#   Иначе ответ 0.
#
# Сложность:
# - N <= 400, T до 10^5, но сумма N^2 по всем тестам <= 400^2.
# - Можно реализовать эффективно.
#
# Реализация:
# - Для каждого теста считать A.
# - Для каждой вершины i построить множество предков P_i (битовая маска).
# - Проверить условия.
# - Для i != 1 найти количество p с P_p = P_i \ {i}.
# - Перемножить.
# - Вывести результат.

def solve_case(N, A):
    # Проверка A[i,i] = 1 и симметричности
    for i in range(N):
        if A[i][i] != 1:
            return 0
    for i in range(N):
        for j in range(i+1, N):
            if A[i][j] != A[j][i]:
                return 0

    # Построим множества предков P_i в виде битмасок
    # P_i = { j | A[i][j] = 1 }
    P = [0]*N
    for i in range(N):
        mask = 0
        for j in range(N):
            if A[i][j] == 1:
                mask |= 1 << j
        P[i] = mask

    # Проверка, что для i != 0 (вершина 1 - индекс 0) P_i содержит 1 и i
    # 1 - вершина с индексом 0
    one_bit = 1 << 0
    for i in range(N):
        if (P[i] & one_bit) == 0:
            return 0
        if (P[i] & (1 << i)) == 0:
            return 0

    # Проверка, что для i != j, если A[i][j] = 1, то P_i включено в P_j или P_j включено в P_i
    # Иначе ответ 0
    for i in range(N):
        for j in range(i+1, N):
            if A[i][j] == 1:
                pi = P[i]
                pj = P[j]
                if not ( (pi & pj) == pi or (pi & pj) == pj ):
                    return 0
            else:
                # Если A[i][j] = 0, то P_i и P_j не должны быть включены друг в друга
                # Иначе путь между i и j содержит j или i, что противоречит A[i][j]=0
                pi = P[i]
                pj = P[j]
                if ( (pi & pj) == pi or (pi & pj) == pj ):
                    return 0

    # Для i != 0 найдём количество p, для которых P_p = P_i \ {i}
    # P_i \ {i} = P_i & ~(1 << i)
    # Для i=0 (корень) пропускаем
    count_parents = [0]*N
    # Создадим словарь: mask -> список вершин с таким P
    from collections import defaultdict
    mask_to_vertices = defaultdict(list)
    for v in range(N):
        mask_to_vertices[P[v]].append(v)

    for i in range(1, N):
        parent_mask = P[i] & ~(1 << i)
        # Количество родителей - количество вершин с P = parent_mask
        c = len(mask_to_vertices.get(parent_mask, []))
        if c == 0:
            return 0
        count_parents[i] = c

    # Ответ - произведение count_parents[i] по i=1..N-1
    ans = 1
    for i in range(1, N):
        ans = (ans * count_parents[i]) % MOD

    return ans

for _ in range(T):
    N = int(input())
    A = [list(map(int, input().split())) for __ in range(N)]
    print(solve_case(N, A))