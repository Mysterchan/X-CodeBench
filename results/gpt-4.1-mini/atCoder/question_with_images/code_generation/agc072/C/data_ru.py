N, K = map(int, input().split())

# На каждом шаге (всего 2N-2 шагов) мы выбираем D или R.
# Правила выбора:
# - Если можно пойти вниз и вправо,
#   выбираем направление, в котором целевая клетка была посещена меньше раз в предыдущих упражнениях.
# - Если посещения равны, выбираем вниз.
#
# Начинаем с (1,1), заканчиваем в (N,N).
#
# Анализ:
# Каждое упражнение — путь из (1,1) в (N,N) с ровно N-1 шагом вниз и N-1 шагом вправо.
# Всего таких путей C(2N-2, N-1).
#
# Порядок выбора на каждом шаге определяется количеством предыдущих упражнений,
# которые посетили соответствующую целевую клетку.
#
# Ключ:
# - На i-м шаге (0-based) мы находим текущую позицию (r,c).
# - Возможны два хода: вниз (r+1,c) и вправо (r,c+1).
# - Кол-во путей из каждой из этих клеток до (N,N) — это количество упражнений,
#   которые в будущем могут пойти через эту клетку.
#
# Таким образом, количество упражнений, которые выбрали ход вниз на i-м шаге,
# равно количеству путей из (r+1,c) до (N,N).
#
# Если K <= количество путей вниз, выбираем D,
# иначе выбираем R и уменьшаем K на количество путей вниз.
#
# Предварительно вычислим количество путей из каждой клетки до (N,N) с помощью DP.

from math import comb

# dp[r][c] = количество путей из (r,c) до (N,N)
dp = [[0]*(N+2) for _ in range(N+2)]
dp[N][N] = 1
for r in range(N, 0, -1):
    for c in range(N, 0, -1):
        if r == N and c == N:
            continue
        dp[r][c] = 0
        if r+1 <= N:
            dp[r][c] += dp[r+1][c]
        if c+1 <= N:
            dp[r][c] += dp[r][c+1]

r, c = 1, 1
res = []
for _ in range(2*N - 2):
    # Если можем пойти вниз и вправо
    if r < N and c < N:
        down_paths = dp[r+1][c]
        if K <= down_paths:
            res.append('D')
            r += 1
        else:
            K -= down_paths
            res.append('R')
            c += 1
    elif r < N:
        # Можно только вниз
        res.append('D')
        r += 1
    else:
        # Можно только вправо
        res.append('R')
        c += 1

print(''.join(res))