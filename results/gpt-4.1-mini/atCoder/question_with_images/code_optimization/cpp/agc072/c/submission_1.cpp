#include <iostream>
#include <string>
using namespace std;

int main() {
    int N;
    long long K;
    cin >> N >> K;

    // The path length is 2N-2 moves.
    // Each path corresponds to a sequence of moves with exactly N-1 'D's and N-1 'R's.
    // The problem defines a tie-breaking rule and a visitation count based ordering.
    //
    // The key insight:
    // The order of paths generated by the problem's rule is exactly the lex order of all paths
    // with N-1 'D's and N-1 'R's, where 'D' < 'R' (because when counts are equal, choose 'D').
    //
    // So the K-th exercise path is the K-th lexicographically smallest path with N-1 'D's and N-1 'R's.
    //
    // We can generate the K-th path using combinatorics:
    // At each step, if we have d_down moves left and r_right moves left,
    // the number of paths starting with 'D' is C(d_down + r_right -1, d_down -1).
    // If K <= that number, choose 'D', else choose 'R' and subtract that number from K.
    //
    // We precompute combinations using Pascal's triangle with 64-bit integers.
    // Since N <= 100, combinations fit in 64-bit integer.

    int total_moves = 2 * (N - 1);
    int d_left = N - 1;
    int r_left = N - 1;

    // Precompute combinations C[n][k] for n,k <= 200 (safe margin)
    static unsigned long long C[201][201] = {0};
    C[0][0] = 1;
    for (int i = 1; i <= 200; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            unsigned long long val = C[i-1][j-1] + C[i-1][j];
            // Cap at 1e18+1 to avoid overflow and unnecessary large values
            C[i][j] = (val > 1000000000000000000ULL) ? 1000000000000000000ULL : val;
        }
    }

    string result;
    for (int step = 0; step < total_moves; step++) {
        if (d_left == 0) {
            // Must go right
            result += 'R';
            r_left--;
        } else if (r_left == 0) {
            // Must go down
            result += 'D';
            d_left--;
        } else {
            // Number of paths starting with 'D'
            unsigned long long countD = C[d_left + r_left -1][d_left -1];
            if (K <= countD) {
                result += 'D';
                d_left--;
            } else {
                result += 'R';
                K -= countD;
                r_left--;
            }
        }
    }

    cout << result << "\n";
    return 0;
}