import sys
import math

input = sys.stdin.readline

def min_steps(x, y):
    # Проверим минимальное количество шагов n, при котором можно достичь (x,y)
    # Шаги идут поочередно: x, y, x, y, ...
    # Длины шагов строго возрастают: a1 < a2 < a3 < ... < an, все a_i - положительные целые.
    #
    # Обозначим n - количество шагов.
    # Кол-во шагов по x: nx = (n+1)//2
    # Кол-во шагов по y: ny = n//2
    #
    # Минимальная сумма nx шагов строго возрастающих положительных целых чисел:
    # 1 + 2 + ... + nx = nx*(nx+1)/2
    # Аналогично для y: ny*(ny+1)/2
    #
    # Чтобы достичь x и y, нужно, чтобы:
    # x >= nx*(nx+1)/2 и y >= ny*(ny+1)/2
    #
    # Но это условие не гарантирует, что можно подобрать строго возрастающие шаги,
    # которые в сумме дадут ровно x и y, при этом длины шагей по x и y чередуются и строго возрастают.
    #
    # Однако, если x < nx*(nx+1)/2 или y < ny*(ny+1)/2, то достижение невозможно.
    #
    # Если условие выполнено, нужно проверить, можно ли подобрать последовательность.
    #
    # Рассмотрим разницу:
    # dx = x - nx*(nx+1)/2
    # dy = y - ny*(ny+1)/2
    #
    # Чтобы получить сумму x, можно увеличить некоторые шаги по x на дополнительные величины,
    # при этом сохраняя строго возрастающий порядок.
    #
    # Аналогично для y.
    #
    # Но нужно проверить, что можно распределить эти дополнительные величины так,
    # чтобы длины шагов строго возрастали и чередовались.
    #
    # Ключевая идея:
    # - Минимальная последовательность шагов по x: 1,2,...,nx
    # - Минимальная последовательность шагов по y: 1,2,...,ny
    #
    # Чтобы увеличить сумму до x и y, можно прибавлять к шагам дополнительные величины,
    # но при этом длины шагов должны строго возрастать по всей последовательности.
    #
    # Проверим, что максимальный шаг по x меньше минимального шага по y (если ny>0),
    # или наоборот, чтобы не нарушать строгое возрастание.
    #
    # Но так как шаги чередуются, и длины строго возрастают по всей последовательности,
    # то для n шагов:
    # a1 < a2 < a3 < ... < an
    # где a1,a3,a5,... - шаги по x
    # a2,a4,a6,... - шаги по y
    #
    # Значит, для всех i:
    # a_i < a_{i+1}
    #
    # Следовательно:
    # a1 < a2 < a3 < a4 < ... < an
    #
    # Минимальная последовательность для n шагов: 1,2,3,...,n
    # Сумма всех шагов: n*(n+1)/2
    #
    # Сумма шагов по x: сумма элементов с нечетными индексами
    # Сумма шагов по y: сумма элементов с четными индексами
    #
    # Проверим, что x и y не меньше соответствующих сумм.
    #
    # Если x < sum_x или y < sum_y, то -1
    #
    # Если x >= sum_x и y >= sum_y, то можно распределить дополнительные величины,
    # увеличивая соответствующие шаги, сохраняя строгое возрастание.
    #
    # Таким образом, алгоритм:
    # Для n от 2 до некоторого максимума (например, 2*10^5, но лучше бинарный поиск):
    #   вычислить sum_x и sum_y для n
    #   если x >= sum_x и y >= sum_y:
    #       вернуть n
    # Если не нашли -1
    #
    # Максимальное n можно оценить:
    # sum_x >= x => nx*(nx+1)/2 >= x
    # nx ~ sqrt(2x)
    # Аналогично для y
    #
    # Максимальное n ~ 2*max(sqrt(2x), sqrt(2y)) + 2
    #
    # Реализуем бинарный поиск по n.

    def sum_odd(n):
        # сумма элементов с нечетными индексами от 1 до n
        # количество нечетных индексов: (n+1)//2
        k = (n + 1) // 2
        # сумма первых k нечетных чисел: 1 + 3 + 5 + ... = k^2
        # но у нас индексы 1,3,5,..., а значения 1,2,3,...,n
        # Значения шагов: 1,2,3,...,n
        # Нужно сумма элементов с нечетными индексами:
        # это сумма a_1 + a_3 + a_5 + ... = sum_{i=1 to k} (2i - 1) = k^2
        # Но в нашей последовательности a_i = i
        # Значит сумма элементов с нечетными индексами = sum_{j=1 to k} (2j - 1) = k^2
        return k * k

    def sum_even(n):
        # сумма элементов с четными индексами от 1 до n
        # количество четных индексов: n//2
        k = n // 2
        # сумма элементов с четными индексами = sum_{j=1 to k} 2j = k(k+1)
        return k * (k + 1)

    left, right = 2, 2 * (int(math.sqrt(2 * max(x, y))) + 2)
    ans = -1
    while left <= right:
        mid = (left + right) // 2
        sx = sum_odd(mid)
        sy = sum_even(mid)
        if sx <= x and sy <= y:
            ans = mid
            right = mid - 1
        else:
            left = mid + 1
    return ans

t = int(input())
for _ in range(t):
    x, y = map(int, input().split())
    print(min_steps(x, y))