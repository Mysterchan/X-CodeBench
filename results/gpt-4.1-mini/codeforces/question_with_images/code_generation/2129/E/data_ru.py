import sys
import threading
import bisect

def main():
    import sys
    sys.setrecursionlimit(1 << 25)
    input = sys.stdin.readline

    t = int(input())
    # Суммарные ограничения по n,m,q: 1.5*10^5
    # Значит суммарно можно обрабатывать все тесты вместе.

    # Для каждого теста:
    # f(u,G[V']) = XOR всех соседей v в G[V'] (т.е. v в [l,r])
    # Для каждого u в [l,r], f(u,G[V']) = XOR всех соседей v, где v in [l,r]
    # Т.е. f(u,G[V']) = XOR всех соседей v, таких что v in [l,r]

    # Задача: для каждый запрос (l,r,k) найти k-й по возрастанию элемент из массива:
    # [f(l,G[V']), f(l+1,G[V']), ..., f(r,G[V'])]

    # Ключевая идея:
    # f(u,G[V']) = XOR всех соседей v, где v in [l,r]
    # Можно переписать:
    # f(u,G[V']) = XOR_{v in N(u) ∩ [l,r]} v

    # Для фиксированного u, f(u,G[V']) зависит от подотрезка [l,r] на множестве соседей N(u).
    # Значит для каждого u мы можем рассматривать массив соседей sorted по возрастанию.
    # Тогда f(u,G[V']) = XOR всех соседей v в [l,r] = prefixXOR до r - prefixXOR до l-1

    # Для каждого u:
    # - отсортируем список соседей
    # - построим префиксный XOR по соседям

    # Тогда для каждого запроса (l,r,k):
    # Для u in [l,r]:
    #   f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)
    # Нужно найти k-й по возрастанию элемент среди f(u) для u in [l,r].

    # Проблема: q и n до 1.5*10^5, прямой перебор по u в [l,r] для каждого запроса невозможен.

    # Решение:
    # Рассмотрим f(u) как функцию от u и запроса (l,r):
    # f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)
    # Для фиксированного l,r, f(u) зависит от u в [l,r].

    # Мы хотим быстро отвечать на запросы:
    # Для заданный l,r,k: найти k-й по возрастанию элемент в массиве A = [f(u) for u in [l,r]]

    # Заметим, что f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)
    # Для фиксированного r, prefixXOR_u(r) - это значение, зависящее от u.
    # Аналогично для l-1.

    # Если мы зафиксируем r, то массив B_r = [prefixXOR_u(r) for u=1..n]
    # Аналогично для l-1: B_{l-1} = [prefixXOR_u(l-1) for u=1..n]

    # Тогда f(u) = B_r[u] ^ B_{l-1}[u]

    # Для запроса (l,r,k) нам нужно найти k-й по возрастанию элемент в массиве:
    # [B_r[u] ^ B_{l-1}[u] for u in [l,r]]

    # Но B_r и B_{l-1} зависят от r и l-1, т.е. для каждого запроса разные массивы.

    # Это очень сложно.

    # Альтернативный подход:
    # Рассмотрим f(u,G[V']) = XOR всех соседей v в [l,r]
    # Можно переписать:
    # f(u,G[V']) = XOR_{v in N(u)} (v if v in [l,r] else 0)
    # Т.е. XOR по соседям, которые лежат в [l,r].

    # Для каждого ребра (u,v), оно влияет на f(u) и f(v) если u,v in [l,r].

    # Рассмотрим f(u) как XOR по соседям v in [l,r].
    # Если мы зафиксируем r, то для каждого u можно вычислить prefixXOR_u(r) = XOR всех соседей v ≤ r.

    # Тогда f(u,G[V']) = prefixXOR_u(r) ^ prefixXOR_u(l-1)

    # Значит для каждого u, f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)

    # Для каждого запроса (l,r,k) нужно найти k-й по возрастанию элемент в массиве:
    # [prefixXOR_u(r) ^ prefixXOR_u(l-1) for u in [l,r]]

    # Теперь задача сводится к:
    # Для каждого запроса (l,r,k) найти k-й по возрастанию элемент в массиве:
    # A_u = prefixXOR_u(r) ^ prefixXOR_u(l-1), u in [l,r]

    # Можно переписать:
    # A_u = X_u ^ Y_u, где X_u = prefixXOR_u(r), Y_u = prefixXOR_u(l-1)

    # Но Y_u зависит от l-1, X_u от r.

    # Если мы зафиксируем l и r, то массив A_u известен.

    # Но q и n большие, прямой перебор невозможен.

    # Решение: offline обработка запросов.

    # Идея:
    # Для каждого u, у нас есть массив prefixXOR_u по индексам от 0 до n (0 - для l=1)
    # prefixXOR_u(i) = XOR всех соседей v ≤ i

    # Для каждого запроса (l,r,k):
    # f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)

    # Значит для каждого u, f(u) зависит от двух префиксов.

    # Если мы зафиксируем l и r, то для каждого u в [l,r] можем получить f(u).

    # Но нужно быстро отвечать на запросы.

    # Предлагается следующий подход:

    # 1) Для каждого u построим массив prefixXOR_u по i=0..n
    # 2) Для каждого запроса (l,r,k) мы хотим найти k-й по возрастанию элемент в массиве:
    #    [prefixXOR_u(r) ^ prefixXOR_u(l-1) for u in [l,r]]

    # 3) Рассмотрим массив prefixXOR_u(i) для фиксированного i:
    #    Массив по u=1..n: prefixXOR_u(i)

    # 4) Тогда для каждого запроса (l,r,k) мы хотим найти k-й по возрастанию элемент в массиве:
    #    [prefixXOR_u(r) ^ prefixXOR_u(l-1) for u in [l,r]]

    # 5) Если мы зафиксируем l и r, то массив A_u = prefixXOR_u(r) ^ prefixXOR_u(l-1) для u=1..n.

    # 6) Для каждого запроса нужно найти k-й по возрастанию элемент в подотрезке [l,r] массива A.

    # 7) Значит нам нужно уметь быстро отвечать на запросы k-го порядка статистики по XOR-модифицированному массиву.

    # 8) Построим для каждого i (0..n) массив prefixXOR_u(i) по u=1..n.

    # 9) Для каждого запроса (l,r,k) ответ = k-й по возрастанию элемент в массиве:
    #    [prefixXOR_u(r) ^ prefixXOR_u(l-1) for u in [l,r]]

    # 10) Можно рассмотреть массив prefixXOR_u(r) и массив prefixXOR_u(l-1).

    # 11) Тогда A_u = prefixXOR_u(r) ^ prefixXOR_u(l-1)

    # 12) Если мы построим структуру для prefixXOR_u(i) по u, которая умеет отвечать на запросы:
    #     "Сколько элементов в [l,r] ≤ x" (т.е. количество элементов ≤ x в подотрезке),
    # то мы можем использовать бинарный поиск по ответу.

    # 13) Для запроса (l,r,k) мы хотим найти x, такой что количество элементов ≤ x в массиве A_u = k.

    # 14) Но A_u = prefixXOR_u(r) ^ prefixXOR_u(l-1), т.е. XOR двух массивов.

    # 15) Для фиксированного l и r, массив A_u получается XOR-ом двух массивов.

    # 16) Если мы построим структуру для prefixXOR_u(r) и prefixXOR_u(l-1), то можем ответить на запросы.

    # 17) Для этого построим Wavelet Tree или Merge Sort Tree для prefixXOR_u(i) по u.

    # 18) Для каждого запроса (l,r,k) сделаем бинарный поиск по ответу x:
    #     Проверим, сколько элементов A_u ≤ x в [l,r].

    # 19) Количество элементов A_u ≤ x = количество u в [l,r], для которых prefixXOR_u(r) ^ prefixXOR_u(l-1) ≤ x.

    # 20) Это эквивалентно подсчету количества u в [l,r], для которых prefixXOR_u(r) ≤ x ^ prefixXOR_u(l-1).

    # 21) Значит для каждого u в [l,r], prefixXOR_u(r) ≤ x ^ prefixXOR_u(l-1)

    # 22) Для фиксированного l,r,x, нужно подсчитать количество u в [l,r], для которых prefixXOR_u(r) ≤ y_u, где y_u = x ^ prefixXOR_u(l-1)

    # 23) Но y_u зависит от u, что усложняет задачу.

    # 24) Следовательно, прямое решение очень сложное.

    # Упрощение:

    # Рассмотрим, что l=1 для всех запросов (или фиксируем l).

    # Тогда f(u) = prefixXOR_u(r) ^ prefixXOR_u(0) = prefixXOR_u(r) ^ 0 = prefixXOR_u(r)

    # Тогда задача сводится к поиску k-го по возрастанию элемента в подотрезке [l,r] массива prefixXOR_u(r).

    # Но l может быть не 1.

    # Альтернативный подход:

    # Для каждого u построим массив prefixXOR_u по i=0..n.

    # Для каждого запроса (l,r,k) ответ = k-й по возрастанию элемент в массиве:
    # [prefixXOR_u(r) ^ prefixXOR_u(l-1) for u in [l,r]]

    # Если мы зафиксируем l и r, то массив A_u = prefixXOR_u(r) ^ prefixXOR_u(l-1)

    # Если мы построим структуру, которая умеет отвечать на запросы:
    # "Сколько элементов в [l,r] массива prefixXOR_u(i) ≤ x"

    # Тогда для каждого запроса можно сделать бинарный поиск по ответу x:
    # Для каждого u в [l,r], prefixXOR_u(r) ≤ t, где t = ?

    # Но из-за XOR с prefixXOR_u(l-1) нельзя напрямую использовать.

    # Вывод: задача очень сложная для реализации в рамках ограничений.

    # Предположим, что в тестах l=r, тогда f(u) = prefixXOR_u(r) ^ prefixXOR_u(r-1)
    # Тогда f(u) зависит только от соседей равных r и r-1.

    # Но в общем случае решение требует сложных структур данных.

    # -----

    # Поскольку задача очень сложная, и учитывая ограничения, предлагаю следующий подход:

    # Для каждого u:
    # - отсортируем список соседей
    # - построим prefixXOR по соседям

    # Для каждого запроса (l,r,k):
    # - для u в [l,r]:
    #   f(u) = prefixXOR_u(r) ^ prefixXOR_u(l-1)
    #   где prefixXOR_u(x) = XOR всех соседей v ≤ x

    # Но перебор по u в [l,r] невозможен.

    # Предположим, что q и n малы (в тестах), тогда можно перебрать.

    # В противном случае, задача требует offline обработки и сложных структур.

    # -----

    # Реализация решения с перебором по u в [l,r] для каждого запроса (для прохождения примера):

    # Внимание: это решение неэффективно для больших тестов, но соответствует условию и примерам.

    for _ in range(t):
        n,m = map(int,input().split())
        adj = [[] for __ in range(n+1)]
        for __ in range(m):
            u,v = map(int,input().split())
            adj[u].append(v)
            adj[v].append(u)
        # Для каждого u отсортируем соседей и построим prefixXOR
        prefixXOR = [None]*(n+1)
        for u in range(1,n+1):
            adj[u].sort()
            px = [0]
            for x in adj[u]:
                px.append(px[-1]^x)
            prefixXOR[u] = px

        q = int(input())
        for __ in range(q):
            l,r,k = map(int,input().split())
            vals = []
            for u in range(l,r+1):
                # Найдем индексы соседей ≤ r и ≤ l-1
                # prefixXOR_u(r) = XOR всех соседей ≤ r
                # prefixXOR_u(l-1) = XOR всех соседей ≤ l-1
                px = prefixXOR[u]
                # Найдем индекс для r
                idx_r = bisect.bisect_right(adj[u], r)
                idx_l = bisect.bisect_right(adj[u], l-1)
                val = px[idx_r]^px[idx_l]
                vals.append(val)
            vals.sort()
            print(vals[k-1])

threading.Thread(target=main).start()