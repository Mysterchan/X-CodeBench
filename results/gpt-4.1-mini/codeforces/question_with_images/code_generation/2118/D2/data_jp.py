import sys
import bisect
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    d = list(map(int, input().split()))
    q = int(input())
    a = list(map(int, input().split()))

    # 赤信号の位置と遅延を辞書に
    delay_map = dict(zip(p, d))

    # 赤信号の位置リスト
    signals = p

    # 方向転換が起こる位置は、t mod k == d_i で赤信号
    # 1秒ごとに、現在位置に赤信号があれば方向転換し、向いている方向に1移動
    # 初期向きは右(+1)
    # 10^100秒以内にストリップを離れるか判定

    # 重要な観察:
    # 方向転換は赤信号の位置でのみ起こる。
    # 赤信号は周期kで赤になる時間が決まっている。
    # 位置xで赤信号が赤になる時間は t ≡ d_i (mod k)
    # つまり、位置xで赤信号が赤になる時間は {d_i, d_i + k, d_i + 2k, ...}

    # 動きのルール:
    # t秒目に位置xにいるとき、
    # もしt mod k == d_i (赤信号の遅延)なら方向転換
    # その後、向いている方向に1移動

    # これを考えると、位置xにいる時間tは初期位置aからの移動時間である。
    # 方向転換の回数は、位置xにいる時間tが赤信号の赤の時間と一致するかどうかで決まる。

    # しかし、tは大きいのでシミュレーションは不可能。
    # そこで、以下の考察を行う。

    # 1. 方向転換は赤信号の位置でのみ起こる。
    # 2. 方向転換のタイミングは t mod k == d_i
    # 3. 初期向きは右(+1)
    # 4. 1秒ごとに移動するので、位置xにいる時間tは初期位置aからの移動距離の合計に等しい。

    # つまり、位置xにいる時間tは、初期位置aからの移動距離の合計。
    # 方向転換は、位置xにいる時間tが赤信号の赤の時間と一致するかどうかで決まる。

    # これを利用して、以下のように判定する。

    # 位置xにいる時間tは、初期位置aからの移動距離の合計。
    # 方向転換は赤信号の位置でのみ起こる。
    # 方向転換が起こると向きが反転する。

    # 方向転換の回数が偶数なら最終的に右向き、奇数なら左向き。

    # 10^100秒以内にストリップを離れるとは、
    # どちらかの端（左端は0未満、右端は > 10^15 など）に向かって無限に進めることを意味する。

    # つまり、無限に左に進めるか、無限に右に進めるか判定。

    # 方向転換が起こる信号の位置は有限個なので、
    # 方向転換のパターンは有限であり、最終的にどちらかの方向に進むかは
    # 方向転換の回数のパリティと信号の配置で決まる。

    # 具体的には、以下のように考える。

    # 1. 右端の信号の右側に出れば脱出可能（右に進み続ける）
    # 2. 左端の信号の左側に出れば脱出可能（左に進み続ける）
    # 3. 信号の間に閉じ込められている場合は脱出不可能

    # 方向転換の影響で、閉じ込められる区間ができる。

    # そこで、信号の位置と遅延から、どの区間で閉じ込められるかを判定する。

    # 方向転換の条件は t mod k == d_i
    # tは移動距離の合計なので、t = |x - a| + (方向転換による移動の影響)
    # しかし、方向転換の影響は複雑なので、以下の方法をとる。

    # 方向転換が起こる位置は有限個なので、
    # それらの信号の位置を境に区間を分割し、
    # 各区間での動きを考える。

    # 方向転換が起こる信号の位置は p_i であり、
    # それぞれの信号は t mod k == d_i で赤になる。

    # ここで、tは移動距離の合計なので、
    # 位置xにいる時間tは、初期位置aからの移動距離の合計。

    # 方向転換が起こるかどうかは、t mod k == d_i かどうか。

    # つまり、位置xにいる時間tが d_i mod k と一致するかどうか。

    # 位置xにいる時間tは、初期位置aからの移動距離の合計。

    # 方向転換が起こる信号の位置p_iでの時間tは、
    # t = |p_i - a| + (方向転換による移動の影響)

    # しかし、方向転換の影響は複雑なので、
    # ここでは、方向転換が起こる信号の位置p_iでの時間tは、
    # t ≡ |p_i - a| mod k と近似できる。

    # これを利用して、方向転換が起こるかどうかを判定。

    # 方向転換が起こる信号p_iで、
    # (|p_i - a|) mod k == d_i なら方向転換が起こる。

    # 方向転換が起こる信号の個数のパリティで最終的な向きが決まる。

    # 最終的に向きが右なら右端に向かい脱出可能、
    # 左なら左端に向かい脱出可能。

    # ただし、信号の位置の範囲外に初期位置がある場合は即脱出可能。

    # 以上を踏まえ、実装する。

    # まず、信号の位置の範囲外なら即YES
    leftmost = signals[0]
    rightmost = signals[-1]

    # d_iを配列にしておく
    # 方向転換が起こるかどうかは (|p_i - a|) mod k == d_i

    # クエリごとに判定
    for start in a:
        if start < leftmost or start > rightmost:
            print("YES")
            continue

        # startが信号の位置にあるかどうか
        idx = bisect.bisect_left(signals, start)

        # 方向転換回数カウント
        turn_count = 0

        # 信号の位置を全てチェックするのは遅いので、
        # 方向転換が起こる信号だけを効率的に判定する必要がある。

        # しかし、n,qの合計が2*10^5なので、
        # クエリごとに全信号をチェックするとO(nq)で間に合わない。

        # そこで、d_iを mod k でグループ化し、
        # (p_i mod k) と d_i の関係を利用する。

        # 方向転換が起こる条件は (|p_i - start|) mod k == d_i

        # |p_i - start| mod k == d_i
        # これを変形すると、
        # (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが最大10^15でmod kでの配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p_i - start| mod k == d_i
        # => (p_i - start) mod k == d_i or (start - p_i) mod k == d_i

        # つまり、p_i mod k == (start + d_i) mod k or p_i mod k == (start - d_i) mod k

        # これを利用して、p_i mod k の値ごとに信号を分類し、
        # クエリごとに該当する信号の個数を高速に求める。

        # しかし、kが大きいので配列は作れない。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # 方向転換が起こる信号は、p_i mod k == (start + d_i) mod k または (start - d_i) mod k

        # これを利用して、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # しかし、p_i mod k は n個の信号でしかないので、
        # 信号ごとに p_i mod k を計算し、d_i とセットで辞書に格納。

        # クエリごとに start mod k を計算し、
        # (start + d_i) mod k と (start - d_i) mod k を計算し、
        # それらに該当する信号の個数を数える。

        # しかし、d_i は信号ごとに異なるので、
        # すべての信号を調べる必要がある。

        # これもO(nq)で間に合わない。

        # したがって、別のアプローチをとる。

        # 方向転換が起こる信号は、t mod k == d_i で赤信号。
        # tは移動距離の合計。

        # 方向転換が起こる信号の位置p_iで、
        # t = |p_i - start| + (方向転換による移動の影響)

        # 方向転換の影響を無視すると、
        # t mod k == |p_i - start| mod k

        # 方向転換が起こる条件は t mod k == d_i
        # よって、方向転換が起こる信号は |p_i - start| mod k == d_i

        # これを利用して、信号ごとに |p_i - start| mod k == d_i か判定。

        # しかし、クエリごとに全信号を調べるのは遅い。

        # そこで、p_i mod k と d_i の組み合わせを辞書にまとめる。

        # |p