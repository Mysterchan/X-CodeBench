import sys
import bisect

input = sys.stdin.readline

t = int(input())
INF = 10**100

for _ in range(t):
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    d = list(map(int, input().split()))
    q = int(input())
    a = list(map(int, input().split()))

    # Светофоры заданы строго возрастающими позициями p[i]
    # Направление движения: +1 или -1
    # На каждом шаге:
    # 1) Если текущая ячейка содержит красный светофор, разворачиваемся
    # 2) Двигаемся на 1 в текущем направлении

    # Красный свет на светофоре i в моменты времени t, когда t % k == d[i]

    # Цель: для каждой начальной позиции определить, покинет ли отрезок [1, 10^15]
    # в течение 10^100 секунд (фактически бесконечность).

    # Анализ:
    # Отрезок [1, 10^15], светофоры в позициях p[i].
    # Если начальная позиция вне [p[0], p[-1]], то движение в сторону выхода гарантировано.
    # Если внутри, движение может быть ограничено светофорами.

    # Ключевая идея:
    # При движении вправо:
    # - На светофоре в позиции p[i] мы можем быть остановлены (разворот) если
    #   время прихода t на p[i] таково, что t % k == d[i].
    # Аналогично для движения влево.

    # Время прихода на пози x при движении вправо:
    # t = x - start_pos (т.к. движение +1 в секунду)
    # При движении влево:
    # t = start_pos - x

    # Если на пути есть светофор, который заставит развернуться,
    # то движение может быть ограничено.

    # Мы хотим понять, есть ли путь выхода вправо или влево без бесконечных разворотов.

    # Решение:
    # Для каждого светофора i:
    # - Рассчитаем "запретные" моменты времени t, когда t % k == d[i].
    # - При движении вправо, если (p[i] - start_pos) % k == d[i], то на светофоре будет красный свет,
    #   и мы развернемся.
    # Аналогично для движения влево.

    # Значит, для движения вправо:
    # - Если существует светофор p[i] >= start_pos, такой что (p[i] - start_pos) % k == d[i],
    #   то на этом светофоре будет красный свет при прибытии, и мы развернемся.
    # Аналогично для движения влево:
    # - Если существует светофор p[i] <= start_pos, такой что (start_pos - p[i]) % k == d[i],
    #   то будет разворот.

    # Если при движении вправо мы не встретим таких светофоров, то выйдем вправо.
    # Если при движении влево мы не встретим таких светофоров, то выйдем влево.

    # Если оба направления заблокированы, то мы зациклимся.

    # Для эффективного поиска:
    # - Для движения вправо: ищем минимальный p[i] >= start_pos с условием (p[i] - start_pos) % k == d[i]
    # - Для движения влево: ищем максимальный p[i] <= start_pos с условием (start_pos - p[i]) % k == d[i]

    # Предобработка:
    # Для каждого остатка r = 0..k-1 (но k может быть до 10^15, слишком много)
    # Нельзя перебрать все остатки.

    # Но можно сгруппировать светофоры по d[i]:
    # Для каждого d_i, храним позиции p[i] в отсортированном виде.

    # При запросе:
    # Для движения вправо:
    # Для каждого d_i:
    #   Нужно проверить, есть ли p[i] >= start_pos, такой что (p[i] - start_pos) % k == d_i
    #   => (p[i] - start_pos) % k == d_i
    #   => p[i] % k == (start_pos + d_i) % k

    # Аналогично для движения влево:
    #   (start_pos - p[i]) % k == d_i
    #   => p[i] % k == (start_pos - d_i) % k

    # Значит, для каждого остатка r = 0..k-1, храним отсортированный список позиций p[i] с p[i] % k == r.

    # Но k может быть до 10^15, нельзя хранить массивы для всех остатков.

    # Решение:
    # Используем словарь: для каждого остатка r = p[i] % k, храним отсортированный список позиций p[i].

    # Для каждого запроса:
    # - Для движения вправо:
    #   r = (start_pos + d_i) % k
    #   Проверяем в списке p_mod[r], есть ли элемент >= start_pos
    #   Если есть, то на этом светофоре будет красный свет => разворот.

    # - Для движения влево:
    #   r = (start_pos - d_i) % k
    #   Проверяем в списке p_mod[r], есть ли элемент <= start_pos
    #   Если есть, то разворот.

    # Если для движения вправо нет светофоров с красным светом, то ответ YES
    # Иначе если для движения влево нет светофоров с красным светом, то ответ YES
    # Иначе NO

    # Но d_i разный для каждого светофора, значит для каждого светофора у нас d_i и p[i].
    # Для каждого остатка r = p[i] % k, храним пары (p[i], d[i]).

    # При запросе:
    # Для движения вправо:
    #   Для каждого остатка r:
    #     Нужно проверить, есть ли p[i] >= start_pos и (p[i] - start_pos) % k == d[i]
    #     Но d[i] зависит от светофора, значит нужно проверить для светофоров с p[i] % k == r,
    #     есть ли p[i] >= start_pos и (p[i] - start_pos) % k == d[i]

    # Но (p[i] - start_pos) % k == d[i] => (p[i] % k - start_pos % k) % k == d[i]
    # => (r - start_pos % k) % k == d[i]

    # Значит для светофоров с остатком r, d[i] == (r - start_pos_mod) % k

    # Аналогично для движения влево.

    # Итог:
    # Для каждого остатка r, храним отсортированный список светофоров с p[i] % k == r,
    # и для каждого светофора d[i].

    # При запросе:
    # start_pos_mod = start_pos % k

    # Для движения вправо:
    #   Нужно проверить, есть ли светофор с p[i] >= start_pos, p[i] % k == r,
    #   и d[i] == (r - start_pos_mod) % k

    # Для движения влево:
    #   Нужно проверить, есть ли светофор с p[i] <= start_pos, p[i] % k == r,
    #   и d[i] == (start_pos_mod - r) % k

    # Реализация:
    # Для каждого остатка r:
    #   Храним два массива:
    #     positions_r: отсортированные позиции p[i] с p[i] % k == r
    #     delays_r: соответствующие d[i]

    # Для запроса:
    #   start_pos_mod = start_pos % k

    # Движение вправо:
    #   target_d = (r - start_pos_mod) % k
    #   Для каждого r в keys:
    #     Если target_d == delays_r[j] для некоторого j, и positions_r[j] >= start_pos,
    #     то разворот.

    # Но перебор всех r для каждого запроса слишком дорог.

    # Оптимизация:
    # Для каждого остатка r:
    #   Создаем словарь delays_to_positions: для каждого d, список позиций с p[i]%k==r и d[i]==d

    # При запросе:
    #   Для движения вправо:
    #     r = (start_pos_mod + d) % k
    #     Для d в [0..k-1] (но перебор невозможен)
    #     Но d зависит от светофора, а мы не знаем d заранее.

    # Альтернативный подход:
    # Для каждого светофора i:
    #   p[i], d[i], r = p[i] % k
    #   Для запроса start_pos:
    #     При движении вправо:
    #       условие разворота: (p[i] - start_pos) % k == d[i]
    #       => (r - start_pos_mod) % k == d[i]
    #       => d[i] == (r - start_pos_mod) % k

    # Значит, для светофора i, при запросе start_pos, разворот будет, если d[i] == (r - start_pos_mod) % k и p[i] >= start_pos

    # Для фиксированного start_pos_mod, для каждого r, вычисляем target_d = (r - start_pos_mod) % k

    # Для каждого r, у нас есть список светофоров с p[i]%k == r, и для каждого d[i] есть позиции.

    # Для каждого r, для target_d, проверяем есть ли p[i] >= start_pos с d[i] == target_d

    # Аналогично для движения влево.

    # Реализация:
    # Для каждого остатка r:
    #   Создаем словарь d_to_positions: d -> отсортированный список позиций p[i] с p[i]%k==r и d[i]==d

    # При запросе:
    #   start_pos_mod = start_pos % k

    # Движение вправо:
    #   Для каждого r в keys:
    #     target_d = (r - start_pos_mod) % k
    #     Если target_d в d_to_positions[r]:
    #       Проверяем, есть ли позиция >= start_pos в d_to_positions[r][target_d]
    #       Если есть, разворот вправо

    # Аналогично для движения влево:
    #   target_d = (start_pos_mod - r) % k
    #   Проверяем, есть ли позиция <= start_pos в d_to_positions[r][target_d]

    # Но перебор всех r для каждого запроса дорог.

    # Оптимизация:
    # Для каждого запроса:
    #   start_pos_mod = start_pos % k

    # Для движения вправо:
    #   Для r в keys:
    #     target_d = (r - start_pos_mod) % k
    #     Проверяем d_to_positions[r][target_d]

    # Но keys может быть до n (до 2*10^5), перебор для каждого запроса (до 2*10^5) невозможен.

    # Вывод:
    # Нужно инвертировать логику.

    # Для каждого светофора i:
    #   p[i], d[i], r = p[i] % k

    # Для запроса start_pos:
    #   start_pos_mod = start_pos % k

    # Условие разворота вправо для светофора i:
    #   d[i] == (r - start_pos_mod) % k
    #   и p[i] >= start_pos

    # Значит, для светофора i, при запросе start_pos, разворот вправо если:
    #   start_pos_mod == (r - d[i]) % k
    #   и p[i] >= start_pos

    # Аналогично для движения влево:
    #   d[i] == (start_pos_mod - r) % k
    #   и p[i] <= start_pos

    # Значит, для каждого светофора i, мы можем вычислить "ключи" start_pos_mod, при которых он вызывает разворот.

    # Для светофора i:
    #   Для движения вправо:
    #     start_pos_mod == (r - d[i]) % k
    #   Для движения влево:
    #     start_pos_mod == (d[i] + r) % k  (т.к. (start_pos_mod - r) % k == d[i] => start_pos_mod == (d[i] + r) % k)

    # Таким образом, для каждого светофора i, мы знаем start_pos_mod, при котором он вызывает разворот вправо и влево.

    # Идея:
    # Для каждого остатка m = 0..k-1 (но k очень большой), храним:
    #   - Для движения вправо: список светофоров i с start_pos_mod == m (т.е. (r - d[i]) % k == m)
    #   - Для движения влево: список светофоров i с start_pos_mod == m (т.е. (d[i] + r) % k == m)

    # Для каждого запроса:
    #   start_pos_mod = start_pos % k
    #   Проверяем для движения вправо:
    #     Есть ли светофор i с start_pos_mod == m = start_pos_mod, и p[i] >= start_pos
    #   Аналогично для движения влево:
    #     Есть ли светофор i с start_pos_mod == m = start_pos_mod, и p[i] <= start_pos

    # Но k может быть очень большим, нельзя хранить массивы для всех m.

    # Решение:
    # Используем словари:
    #   right_map: m -> отсортированный список позиций p[i] для светофоров, вызывающих разворот вправо при start_pos_mod == m
    #   left_map: m -> отсортированный список позиций p[i] для светофоров, вызывающих разворот влево при start_pos_mod == m

    # При запросе:
    #   start_pos_mod = start_pos % k
    #   Для движения вправо:
    #     Проверяем в right_map[start_pos_mod], есть ли p[i] >= start_pos
    #   Для движения влево:
    #     Проверяем в left_map[start_pos_mod], есть ли p[i] <= start_pos

    # Если в right_map[start_pos_mod] нет p[i] >= start_pos => движение вправо свободно => YES
    # Иначе если в left_map[start_pos_mod] нет p[i] <= start_pos => движение влево свободно => YES
    # Иначе NO

    # Если start_pos < p[0], то сразу YES (движение влево выходит за пределы)
    # Если start_pos > p[-1], то сразу YES (движение вправо выходит за пределы)

    # Иначе проверяем по светофорам.

    right_map = dict()
    left_map = dict()

    for i in range(n):
        r = p[i] % k
        di = d[i]
        m_right = (r - di) % k
        m_left = (di + r) % k

        if m_right not in right_map:
            right_map[m_right] = []
        right_map[m_right].append(p[i])

        if m_left not in left_map:
            left_map[m_left] = []
        left_map[m_left].append(p[i])

    # Отсортируем списки позиций для бинарного поиска
    for m in right_map:
        right_map[m].sort()
    for m in left_map:
        left_map[m].sort()

    left_bound = 1
    right_bound = 10**15

    out = []
    for start_pos in a:
        if start_pos < left_bound or start_pos > right_bound:
            # Уже вне отрезка
            out.append("YES")
            continue

        start_pos_mod = start_pos % k

        # Проверяем движение вправо
        can_go_right = True
        if start_pos_mod in right_map:
            arr = right_map[start_pos_mod]
            idx = bisect.bisect_left(arr, start_pos)
            if idx < len(arr):
                # Есть светофор p[i] >= start_pos, разворот вправо
                can_go_right = False

        # Проверяем движение влево
        can_go_left = True
        if start_pos_mod in left_map:
            arr = left_map[start_pos_mod]
            idx = bisect.bisect_right(arr, start_pos) - 1
            if idx >= 0:
                # Есть светофор p[i] <= start_pos, разворот влево
                can_go_left = False

        # Если можем уйти вправо или влево, ответ YES
        if can_go_right or can_go_left:
            out.append("YES")
        else:
            out.append("NO")

    print("\n".join(out))