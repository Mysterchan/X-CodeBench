t = int(input())
for _ in range(t):
    n, a, b = map(int, input().split())
    # Рассмотрим условие симметрии итоговой раскраски.
    # Красный интервал: [x, x+a-1]
    # Синий интервал: [y, y+b-1]
    #
    # Итоговый цвет ячейки i:
    # - синий, если i в синем интервале
    # - красный, если i в красном, но не в синем
    # - белый, иначе
    #
    # Симметрия: цвет i == цвет n+1 - i для всех i.
    #
    # Анализ:
    # Синий перекрывает красный, поэтому синий интервал должен быть симметричен сам себе.
    # Красный интервал может быть несимметричен, но итоговая раскраска должна быть симметрична.
    #
    # Рассмотрим отражение индексов: i -> n+1 - i
    #
    # Пусть синий интервал [y, y+b-1] симметричен относительно центра:
    # Тогда y + (b-1) = n+1 - y  =>  2y + b -1 = n+1  =>  2y = n - b + 2
    # y = (n - b + 2)/2
    #
    # Для y целого, (n - b + 2) должно быть четным.
    #
    # Аналогично для красного интервала:
    # x + (a-1) = n+1 - x  =>  2x + a -1 = n+1  =>  2x = n - a + 2
    # x = (n - a + 2)/2
    #
    # Если x и y целые и лежат в допустимых диапазонах, то можно расположить интервалы симметрично.
    #
    # Проверим, что x и y целые и удовлетворяют ограничениям:
    # 1 ≤ x ≤ n - a + 1
    # 1 ≤ y ≤ n - b + 1
    #
    # Если оба условия выполняются, ответ YES, иначе NO.
    
    def can_place(length, seg_len):
        val = n - seg_len + 2
        if val % 2 != 0:
            return False
        pos = val // 2
        return 1 <= pos <= n - seg_len + 1
    
    if can_place(n, a) and can_place(n, b):
        print("YES")
    else:
        print("NO")