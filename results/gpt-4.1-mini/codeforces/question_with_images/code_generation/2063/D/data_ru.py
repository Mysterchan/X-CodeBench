import sys
import threading

def main():
    import sys
    input = sys.stdin.readline

    t = int(input())
    # Суммарные n и m по всем тестам не превышают 2*10^5, значит можно обрабатывать по очереди.

    for _ in range(t):
        n, m = map(int, input().split())
        a = list(map(int, input().split()))
        b = list(map(int, input().split()))

        # Максимальное количество операций:
        k_max = min(n // 2, m // 1)  # Каждая операция требует 3 точки: 2 с y=0 и 1 с y=2 или наоборот
        # Но по условию точки на y=0 и y=2, чтобы не лежали на одной прямой, нужно брать 2 точки с одной линии и 1 с другой.
        # Т.к. точки на одной линии, чтобы не были коллинеарны, нужно брать 2 с одной линии и 1 с другой.
        # Значит, операция требует 2 точки с одной линии и 1 с другой.
        # Можно делать операции либо (2 снизу + 1 сверху) либо (1 снизу + 2 сверху).
        # Но в условии все точки на y=0 и y=2, значит треугольник с 3 точками на одной линии невозможен.
        # Значит, операция требует 2 точки с одной линии и 1 с другой.
        # Максимум операций - это максимальное количество таких троек, то есть:
        # max k = min(n//2, m) + min(n, m//2)
        # Но мы можем использовать только один из вариантов, т.к. точки удаляются.
        # Нужно выбрать вариант, который даст максим k.

        # Рассмотрим оба варианта:
        k1 = min(n // 2, m)  # 2 снизу + 1 сверху
        k2 = min(n, m // 2)  # 1 снизу + 2 сверху
        k_max = max(k1, k2)

        if k_max == 0:
            print(0)
            continue

        # Теперь нужно найти f(k) для k=1..k_max
        # f(k) - максимальный суммарный счет после ровно k операций.

        # Площадь треугольника с точками (x1,0), (x2,0), (x3,2):
        # Если 2 точки на y=0: (x1,0), (x2,0), и 1 точка на y=2: (x3,2)
        # Площадь = |x3 - x1| * 2 / 2 = |x3 - x1| (если x2 между x1 и x3, то площадь меньше)
        # Но нужно брать 2 точки снизу и 1 сверху, чтобы не были коллинеарны.
        # Точки на одной линии y=0 коллинеарны, но с точкой сверху образуют треугольник.
        # Площадь = |x3 - x1| * 2 / 2 = |x3 - x1|, где x1 и x2 - точки снизу, x3 - сверху.
        # Но 2 точки снизу, чтобы не были коллинеарны с точкой сверху, должны быть разными.
        # Площадь треугольника = |x3 - x1| * 2 / 2 = |x3 - x1|, где x1 и x2 - точки снизу, x3 - сверху.
        # Аналогично для 1 точка снизу и 2 сверху.

        # Для варианта 2 снизу + 1 сверху:
        # Выбираем пары точек снизу (a[i], a[j]) и точку сверху b[k].
        # Площадь = |b[k] - a[i]| * 2 / 2 = |b[k] - a[i]|, но нужно учитывать вторую точку снизу.
        # Но площадь треугольника с точками (a[i],0), (a[j],0), (b[k],2) равна:
        # 0.5 * |(a[j]-a[i]) * (2 - 0) - (b[k]-a[i]) * (0 - 0)| = 0.5 * |(a[j]-a[i]) * 2| = |a[j]-a[i]|
        # То есть площадь зависит только от расстояния между двумя точками на одной линии (y=0 или y=2).
        # Третья точка на другой линии с y=2 просто задает высоту 2, площадь = base * height / 2 = |a[j]-a[i]| * 2 / 2 = |a[j]-a[i]|.
        # Аналогично для 1 снизу + 2 сверху, площадь = |b[j]-b[i]|.

        # Значит, площадь треугольника = расстояние между двумя точками на одной линии (y=0 или y=2).

        # Следовательно, чтобы максимизировать сумму площадей, нужно:
        # - Для варианта 2 снизу + 1 сверху: выбрать пары точек снизу с максимальными расстояниями.
        # - Для варианта 1 снизу + 2 сверху: выбрать пары точек сверху с максимальными расстояниями.

        # И потом суммировать эти максимальные расстояния для k операций.

        # Алгоритм:
        # 1) Отсортировать a и b.
        # 2) Найти все расстояния между соседними точками в a (на y=0) и в b (на y=2).
        # 3) Максимальная площадь треугольника для пары точек на одной линии = расстояние между этими точками.
        # 4) Для варианта 2 снизу + 1 сверху: максимальные площади - это максимальные расстояния между точками a.
        #    Для варианта 1 снизу + 2 сверху: максимальные площади - это максимальные расстояния между точками b.
        # 5) Для k операций нужно выбрать k максимальных расстояний из соответствующего массива.
        # 6) Выбрать вариант (2 снизу + 1 сверху) или (1 снизу + 2 сверху), который даст максимальную сумму для каждого k.

        a.sort()
        b.sort()

        # Расстояния между соседними точками в a
        dist_a = [a[i+1] - a[i] for i in range(n-1)]
        dist_b = [b[i+1] - b[i] for i in range(m-1)]

        dist_a.sort(reverse=True)
        dist_b.sort(reverse=True)

        # Для варианта 2 снизу + 1 сверху:
        # Можно сделать не более min(n//2, m) операций.
        max_k1 = min(n // 2, m)
        prefix_a = [0]
        for i in range(max_k1):
            prefix_a.append(prefix_a[-1] + dist_a[i])

        # Для варианта 1 снизу + 2 сверху:
        # Можно сделать не более min(n, m//2) операций.
        max_k2 = min(n, m // 2)
        prefix_b = [0]
        for i in range(max_k2):
            prefix_b.append(prefix_b[-1] + dist_b[i])

        # Теперь для k=1..k_max нужно выбрать максимум из двух вариантов:
        # k_max = max_k1 или max_k2
        # Но k_max уже выбран как max(k1,k2)
        # Для k > max_k1 или k > max_k2, соответствующий вариант не доступен.

        # Выведем k_max и f(k) для k=1..k_max
        # f(k) = max(prefix_a[k] if k <= max_k1 else -inf, prefix_b[k] if k <= max_k2 else -inf)

        print(k_max)
        res = []
        for k in range(1, k_max + 1):
            val_a = prefix_a[k] if k <= max_k1 else -1
            val_b = prefix_b[k] if k <= max_k2 else -1
            res.append(str(max(val_a, val_b)))
        print(' '.join(res))


threading.Thread(target=main).start()