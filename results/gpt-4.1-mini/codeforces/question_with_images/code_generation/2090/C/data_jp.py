import sys
input = sys.stdin.readline

q = int(input())
for _ in range(q):
    n = int(input())
    t = list(map(int, input().split()))

    # テーブルは (3x+1, 3y+1), (3x+1, 3y+2), (3x+2, 3y+1), (3x+2, 3y+2)
    # x,yは非負整数
    # 距離は (3x+1) + (3y+1) - 2 = 3x + 3y で、(0,0)からの距離は (3x+1-0)+(3y+1-0) = 3x+3y+2
    # ただし、距離は最小ステップ数で、通路セルのみを通る。
    # 通路はテーブルセル以外のセルで、(0,0)は通路セル。
    # 通路セルは (3x, y), (x, 3y), (3x+0, 3y+0) などテーブルセル以外のセル。
    #
    # t_i=1 の客は「最も近い空いているテーブルセル」へ
    # t_i=0 の客は「完全に空いているテーブル（4セルすべて空いている）」の中で最も近いテーブルセルへ
    #
    # 距離が同じなら、x座標が小さいもの、さらに同じならy座標が小さいものを選ぶ。
    #
    # 重要な点：
    # - t_i=0 の客は、同じテーブルの他のセルは後の客も使える（占有しない）
    # - t_i=1 の客は、選んだセルを占有し、他の客はそこに行けない
    #
    # つまり、
    # t_i=0 の客は「テーブル単位」で管理し、テーブルが空いているかどうかだけを気にする
    # t_i=1 の客は「セル単位」で管理し、空いているセルを選ぶ
    #
    # 距離はテーブルの座標 (x,y) によって決まる。
    # テーブルの4セルは (3x+1,3y+1), (3x+1,3y+2), (3x+2,3y+1), (3x+2,3y+2)
    #
    # 距離は (3x+1)+(3y+1) - 0 = 3x+3y+2 で一定なので、距離はテーブル単位で同じ。
    #
    # したがって、距離順にテーブルを並べておき、t_i=0 の客は空いているテーブルの中で最も距離が近いものを選び、
    # t_i=1 の客は空いているセルの中で最も距離が近いものを選ぶ。
    #
    # 距離が同じ場合は x が小さい順、さらに y が小さい順。
    #
    # これを実装するには、テーブルを距離順に列挙し、t_i=0 の客はテーブル単位で管理し、
    # t_i=1 の客はセル単位で管理する。
    #
    # しかし、無限のテーブルがあるため、必要な分だけ生成する必要がある。
    #
    # ここで、距離 = 3x + 3y + 2
    # x,y >= 0
    #
    # 距離が小さい順にテーブルを列挙すると、
    # d = 3(x+y) + 2
    # x+y = k (k >= 0)
    #
    # k=0: (0,0)
    # k=1: (0,1), (1,0)
    # k=2: (0,2), (1,1), (2,0)
    # ...
    #
    # つまり、k = (distance - 2) / 3
    #
    # 各kについて、x=0..k, y=k-x の順にテーブルが並ぶ。
    #
    # これを利用して、t_i=0 の客はテーブル単位で、t_i=1 の客はセル単位で管理する。
    #
    # t_i=0 の客は、空いているテーブルの中で最も距離が近いものを選ぶ。
    # t_i=1 の客は、空いているセルの中で最も距離が近いものを選ぶ。
    #
    # t_i=0 の客はテーブル単位で管理し、t_i=1 の客はセル単位で管理するため、
    # t_i=1 の客は、空いているセルを優先度付きキューで管理する。
    #
    # これを実装するために、テーブル単位のキューとセル単位のキューを用意し、
    # 必要に応じて新しいテーブルを追加していく。
    #
    # 具体的には、
    # - t_i=0 の客はテーブルキューから先頭を取り出し、そのテーブルの (3x+1, 3y+1) のセルを割り当てる（距離は同じなのでどのセルでも良いが、問題文の条件から最小のセルを選ぶ）
    # - t_i=1 の客はセルキューから先頭を取り出し、そのセルを割り当てる
    #
    # ただし、t_i=0 の客はテーブルを占有しないので、同じテーブルは何度でも使える。
    # しかし、t_i=1 の客はセルを占有するので、そのセルは使えなくなる。
    #
    # したがって、t_i=0 の客はテーブルキューからテーブルを取り出すだけでよい。
    # t_i=1 の客はセルキューからセルを取り出すが、取り出したセルは使えなくなるので、次のセルを追加する必要がある。
    #
    # しかし、t_i=0 の客はテーブルを占有しないので、同じテーブルは何度でも使えるため、テーブルキューは無限に使える。
    #
    # これを踏まえた実装を行う。

from collections import deque

MAX_N = 50000

# テーブルの距離は 3(x+y)+2
# k = x+y
# k=0..∞ の順にテーブルを列挙
# 各kについて、x=0..k, y=k-x の順にテーブルを列挙
# これを必要な分だけ生成する

# t_i=0 の客用テーブルキュー（テーブル単位）
# t_i=1 の客用セルキュー（セル単位）

# それぞれのキューは距離順、x,y順に並ぶ

# 事前に十分な数のテーブルを生成する
# nの合計は最大50000なので、最大50000人分のテーブルを生成すれば十分

# ただし、t_i=1 の客はセル単位で管理するため、セル数は4倍必要

# 生成方法：
# k=0から順にテーブルを生成し、テーブルキューに追加
# 同時にセルキューに4つのセルを追加

# ただし、t_i=1 の客は空いているセルを使うため、セルキューから取り出すだけでよい
# t_i=0 の客はテーブルキューから取り出すだけでよい

# これで問題の条件を満たす

# ただし、t_i=0 の客は「完全に空いているテーブル」の中で最も近いテーブルセルを選ぶ
# つまり、t_i=0 の客はテーブル単位で管理し、同じテーブルは何度でも使える

# t_i=1 の客はセル単位で管理し、使ったセルは占有されるので使えなくなる

# したがって、t_i=0 の客はテーブルキューから取り出すだけでよい
# t_i=1 の客はセルキューから取り出すだけでよい

# ただし、t_i=1 の客がセルを使うと、そのセルは使えなくなるので、セルキューから取り出したセルはもう使えない

# これで実装可能

# ただし、t_i=0 の客はテーブル単位で管理し、同じテーブルは何度でも使えるので、
# テーブルキューは単なる順番待ちでよい

# まとめると、
# - t_i=0 の客はテーブルキューから先頭のテーブルを取り出し、そのテーブルの (3x+1, 3y+1) のセルを割り当てる
# - t_i=1 の客はセルキューから先頭のセルを取り出し、そのセルを割り当てる

# これで条件を満たす

# ただし、t_i=1 の客はセルキューから取り出したセルを占有するので、同じセルは使えない

# これで問題の条件を満たす

# 実装開始

table_queue = deque()
cell_queue = deque()

# 事前に十分なテーブルとセルを生成
# 最大50000人なので、kの最大値はおおよそ50000 // (k+1)程度
# 安全にk=0..50000まで生成する

# ただし、k=0..MAX_Kまで生成
MAX_K = 50000

for k in range(MAX_K+1):
    for x in range(k+1):
        y = k - x
        # テーブル座標 (x,y)
        # テーブルセル4つ
        # 距離は同じなので、x,y順に並べることで条件を満たす
        # t_i=0 の客用テーブルキューには (x,y) を入れる
        table_queue.append((x, y))
        # t_i=1 の客用セルキューには4つのセルを入れる
        # セルは (3x+1, 3y+1), (3x+1, 3y+2), (3x+2, 3y+1), (3x+2, 3y+2)
        cell_queue.append((3*x+1, 3*y+1))
        cell_queue.append((3*x+1, 3*y+2))
        cell_queue.append((3*x+2, 3*y+1))
        cell_queue.append((3*x+2, 3*y+2))

    # 生成したテーブル数が十分ならbreak
    if len(table_queue) > MAX_N and len(cell_queue) > 4*MAX_N:
        break

# ここから各テストケース処理
# 事前生成したtable_queue, cell_queueを使うため、
# 各テストケースごとにキューの先頭から取り出すだけでよい
# ただし、複数テストケースがあるため、キューの先頭を管理するポインタを用意する

table_idx = 0
cell_idx = 0

# 事前生成したリストに変換
table_list = list(table_queue)
cell_list = list(cell_queue)

for _ in range(q):
    n = int(input())
    t = list(map(int, input().split()))

    res = []
    for ti in t:
        if ti == 0:
            # t_i=0 の客はテーブル単位で最も近いテーブルの (3x+1, 3y+1) を割り当てる
            x, y = table_list[table_idx]
            table_idx += 1
            res.append((3*x+1, 3*y+1))
        else:
            # t_i=1 の客はセル単位で最も近い空いているセルを割り当てる
            x, y = cell_list[cell_idx]
            cell_idx += 1
            res.append((x, y))

    print('\n'.join(f"{x} {y}" for x, y in res))