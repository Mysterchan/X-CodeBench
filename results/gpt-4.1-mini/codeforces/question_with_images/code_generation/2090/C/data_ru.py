import sys
input = sys.stdin.readline

# Каждому столу соответствует 4 клетки:
# (3x+1, 3y+1), (3x+1, 3y+2), (3x+2, 3y+1), (3x+2, 3y+2)
# Расстояние до любой клетки стола: 
# dist = (3x+1) + (3y+1) = 3x + 3y + 2
# Минимальное расстояние до стола определяется x+y.
# Для выбора ближайшего стола по условию:
# 1) минимальное расстояние (x+y)
# 2) при равенстве минимальное x
# 3) при равенстве минимальное y

# Для t_i=1 (гость идет к ближайшей клетке со столом):
# - выбирается ближайшая свободная клетка среди всех столов.
# Для t_i=0 (гость идет к ближайшей клетке стола, который полностью свободен):
# - выбирается ближайший стол, у которого все 4 клетки свободны,
#   и среди них выбирается клетка с минимальным (x,y) по условию.

# Стратегия решения:
# - Будем генерировать столы в порядке возрастания x+y, затем x, затем y.
# - Для каждого стола храним состояние занятости 4 клеток.
# - Для t_i=0 ищем первый стол с 4 свободными клетками.
# - Для t_i=1 ищем ближайшую свободную клетку среди всех столов.
# - Чтобы не генерировать бесконечно, будем генерировать столы по мере необходимости.
# - Максимальное количество гостей 50_000, значит нам нужно не более 50_000 столов.
# - Для t_i=1 может понадобиться занять клетки в уже частично занятых столах.
# - Для t_i=0 нужен полностью свободный стол.

# Для эффективного поиска:
# - Храним очередь столов с полностью свободными клетками (для t_i=0).
# - Храним очередь свободных клеток (для t_i=1).
# - При выделении клетки обновляем состояние стола.
# - Если стол перестал быть полностью свободным, удаляем его из очереди полностью свободных столов.
# - Если стол стал с частично занятыми клетками, клетки добавляем в очередь свободных клеток.

# Для упорядочивания по (x+y, x, y) используем генератор столов по возрастанию суммы координат.

from collections import deque

# Клетки стола в порядке (x,y) для выбора минимальной клетки:
# (3x+1, 3y+1), (3x+1, 3y+2), (3x+2, 3y+1), (3x+2, 3y+2)
# порядок по x,y:
# (3x+1, 3y+1)
# (3x+1, 3y+2)
# (3x+2, 3y+1)
# (3x+2, 3y+2)

cells_order = [(1,1),(1,2),(2,1),(2,2)]

def generate_tables():
    # Генератор столов в порядке возрастания x+y, затем x, затем y
    s = 0
    while True:
        for x in range(s+1):
            y = s - x
            yield (x,y)
        s += 1

def main():
    q = int(input())
    for _ in range(q):
        n = int(input())
        t = list(map(int, input().split()))

        # Состояние столов:
        # key: (x,y), value: list из 4 элементов (False - свободна, True - занята)
        tables = dict()

        # Очередь полностью свободных столов для t_i=0
        # Храним кортеж (x+y, x, y)
        free_tables = deque()

        # Очередь свободных клеток для t_i=1
        # Храним кортеж (dist, x_cell, y_cell, x_table, y_table, cell_index)
        # dist = (3x_table+1)+(3y_table+1) + смещение клетки (0 или 1)
        # Но расстояние до клетки = (3x_table + cell_dx) + (3y_table + cell_dy)
        # Для упорядочивания по условию достаточно сортировать по (dist, x_cell, y_cell)
        # dist = x_cell + y_cell
        free_cells = []

        # Для генерации новых столов по мере необходимости
        gen = generate_tables()

        # Для быстрого поиска следующего стола для t_i=0
        # Используем очередь free_tables, в которую добавляем новые столы при генерации

        # Для t_i=1 будем использовать heapq для свободных клеток
        import heapq

        # Функция добавления нового стола
        def add_table(x,y):
            tables[(x,y)] = [False]*4
            free_tables.append((x+y, x, y))
            # Добавляем все 4 клетки в очередь свободных клеток
            for i, (dx,dy) in enumerate(cells_order):
                x_cell = 3*x + dx
                y_cell = 3*y + dy
                dist = x_cell + y_cell
                heapq.heappush(free_cells, (dist, x_cell, y_cell, x, y, i))

        # Изначально добавим несколько столов, чтобы не генерировать каждый раз
        # Но лучше добавлять по мере необходимости

        # Максимально нужно n столов для t_i=0, но для t_i=1 может понадобиться больше клеток
        # Будем добавлять столы по мере необходимости

        # Для контроля сколько столов добавлено
        tables_added = 0

        # Результат для гостей
        res = []

        # Функция для выделения клетки t_i=1
        def assign_cell_any():
            # Извлекаем из free_cells свободную клетку
            while True:
                if not free_cells:
                    # Добавим новый стол
                    nonlocal tables_added
                    x,y = next(gen)
                    add_table(x,y)
                    tables_added += 1
                    continue
                dist, x_cell, y_cell, x_table, y_table, i_cell = heapq.heappop(free_cells)
                if not tables[(x_table,y_table)][i_cell]:
                    # Клетка свободна, занимаем
                    tables[(x_table,y_table)][i_cell] = True
                    # Если стол был полностью свободен, удаляем его из free_tables
                    # Проверим, если стол был полностью свободен (все False до этого)
                    # Но мы не храним отдельно, поэтому проверим:
                    # Если после установки True количество занятых клеток == 1, значит был полностью свободен
                    # Удалим из free_tables
                    # Но free_tables - deque, удаление из середины дорогое
                    # Решение: при выделении t_i=0 мы берем стол из free_tables слева, 
                    # а при t_i=1 мы можем просто помечать стол как не полностью свободный
                    # и при выделении t_i=0 пропускать такие столы
                    # Для этого заведем множество занятых столов
                    occupied_tables.add((x_table,y_table))
                    return (x_cell, y_cell)

        # Множество занятых столов (не полностью свободных)
        occupied_tables = set()

        # Функция для выделения клетки t_i=0
        def assign_cell_full_free():
            # Извлекаем из free_tables первый полностью свободный стол
            while True:
                if not free_tables:
                    # Добавим новый стол
                    nonlocal tables_added
                    x,y = next(gen)
                    add_table(x,y)
                    tables_added += 1
                    continue
                s, x, y = free_tables[0]
                if (x,y) in occupied_tables:
                    # Стол уже не полностью свободен, удаляем из free_tables
                    free_tables.popleft()
                    continue
                # Стол полностью свободен, выделяем первую клетку по порядку
                # Занимаем клетку (3x+1, 3y+1)
                # Но по условию гость занимает одну клетку стола, не обязательно первую,
                # но выбирает клетку с минимальным (x,y) среди свободных клеток стола.
                # Так как стол полностью свободен, все 4 клетки свободны,
                # выбираем первую клетку из cells_order
                # Занимаем ее
                tables[(x,y)][0] = True
                # Стол теперь не полностью свободен
                occupied_tables.add((x,y))
                # Удаляем стол из free_tables
                free_tables.popleft()
                # Добавляем остальные 3 клетки стола в очередь свободных клеток для t_i=1
                for i in range(1,4):
                    dx, dy = cells_order[i]
                    x_cell = 3*x + dx
                    y_cell = 3*y + dy
                    dist = x_cell + y_cell
                    heapq.heappush(free_cells, (dist, x_cell, y_cell, x, y, i))
                return (3*x + 1, 3*y + 1)

        # Предварительно добавим несколько столов, чтобы не тормозить
        # Добавим 100 столов (можно меньше, но с запасом)
        for _ in range(100):
            x,y = next(gen)
            add_table(x,y)
            tables_added += 1

        for ti in t:
            if ti == 0:
                # Ищем стол с 4 свободными клетками
                cell = assign_cell_full_free()
                res.append(cell)
            else:
                # Ищем ближайшую свободную клетку среди всех
                cell = assign_cell_any()
                res.append(cell)

        # Вывод результата
        for x_cell, y_cell in res:
            print(x_cell, y_cell)

if __name__ == "__main__":
    main()