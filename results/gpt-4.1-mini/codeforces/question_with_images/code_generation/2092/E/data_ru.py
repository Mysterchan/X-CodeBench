import sys
import threading

MOD = 10**9 + 7

def main():
    input = sys.stdin.readline
    t = int(input())
    
    # Рассмотрим доску n x m.
    # Цвет клетки (i,j) можно представить как color(i,j).
    # Даны k клеток с фиксированным цветом (0 или 1).
    #
    # Нужно покрасить остальные (зелёные) клетки в {0,1} так,
    # чтобы количество пар соседних разноцветных клеток было чётным.
    #
    # Анализ:
    # Рассмотрим граф клеток, где ребро между соседними клетками.
    # Количество разноцветных рёбер по модулю 2 — это сумма по всем рёбрам
    # (color(u) XOR color(v)) mod 2.
    #
    # Можно переписать условие:
    # sum over edges (color(u) + color(v)) mod 2 = 0
    # Но проще работать с XOR.
    #
    # Рассмотрим раскраску клеток в чёрно-белую шахматную раскраску по цвету клетки:
    # parity = (i + j) mod 2
    #
    # Если мы выберем цвет клетки (i,j) = parity XOR b, где b ∈ {0,1} — глобальный сдвиг,
    # то все соседние клетки будут иметь противоположный parity,
    # значит все соседние пары будут разноцветными.
    #
    # Количество соседних пар на доске:
    # горизонтальных: n*(m-1)
    # вертикальных: (n-1)*m
    # всего E = n*(m-1) + (n-1)*m = 2nm - n - m
    #
    # Если b=0, то количество разноцветных пар = E (все ребра разноцветные)
    # Если b=1, то количество разноцветных пар = 0 (все ребра одноцветные)
    #
    # Значит, без ограничений, есть ровно 2 раскраски, отличающиеся глобальным сдвигом b.
    #
    # Теперь учтём фиксированные клетки:
    # Для каждой фиксированной клетки (x,y) с цветом c:
    # color(x,y) = parity(x,y) XOR b = c
    # => b = c XOR parity(x,y)
    #
    # Если для разных фиксированных клеток получается разный b, то противоречие,
    # решений нет.
    #
    # Если b однозначно определён, то:
    # - Если b=0, количество разноцветных пар = E, нужно проверить чётность E.
    # - Если b=1, количество разноцветных пар = 0, чётность 0 — всегда чётно.
    #
    # Условие задачи: количество разноцветных пар чётно.
    #
    # Значит:
    # - Если b=0, E должно быть чётным, иначе решений нет.
    # - Если b=1, решений всегда есть.
    #
    # Если нет фиксированных клеток, b может быть 0 или 1, значит 2 варианта.
    #
    # Теперь количество способов покрасить зелёные клетки:
    # Всего клеток: N = n*m
    # Фиксированных: k
    # Осталось красить: N - k
    #
    # Но мы выбрали b, значит цвет каждой клетки однозначно определяется:
    # color(i,j) = parity(i,j) XOR b
    #
    # Значит, если b фиксирован, то все цвета однозначно определены, и вариантов покраски зелёных клеток = 1.
    #
    # Если b не фиксирован (нет фиксированных клеток), то вариантов 2 (b=0 или b=1).
    #
    # Однако в условии сказано, что зелёные клетки можно красить в {0,1} произвольно,
    # но при этом условие чётности должно выполняться.
    #
    # Значит, мы можем менять цвета зелёных клеток, но должны сохранить чётность количества разноцветных пар.
    #
    # Рассмотрим подробнее:
    #
    # Пусть мы выбрали базовую раскраску с b=0 или b=1.
    # Теперь мы можем менять цвет зелёных клеток.
    #
    # Известно, что количество разноцветных пар по модулю 2 — это сумма по рёбрам XOR цветов.
    #
    # Рассмотрим граф клеток как двудольный граф с долями по parity:
    # Все рёбра между клетками с parity=0 и parity=1.
    #
    # Тогда цвет клетки — переменная x_v ∈ {0,1}.
    #
    # Количество разноцветных рёбер по модулю 2 = сумма по рёбрам (x_u XOR x_v).
    #
    # Можно переписать:
    # sum over edges (x_u + x_v) mod 2 = sum over vertices (deg(v)*x_v) mod 2
    #
    # Так как каждое ребро учитывается дважды, сумма XOR по рёбрам равна сумме по вершинам
    # (deg(v)*x_v) mod 2.
    #
    # В двудольном графе степени вершин:
    # - Для клеток с parity=0: deg = количество соседей (2,3 или 4)
    # - Для parity=1 аналогично.
    #
    # Но степени могут быть чётными или нечётными.
    #
    # Рассмотрим степени по модулю 2:
    # - Внутри доски все клетки имеют степень 4 (чётная)
    # - На гранях и углах степень меньше, но чётность степени:
    #   - Углы: 2 (чётная)
    #   - Грани: 3 (нечётная)
    #
    # Значит, степень по модулю 2 равна 1 для граничных клеток с 3 соседями,
    # и 0 для остальных (углы и внутренние клетки).
    #
    # Значит, сумма XOR по рёбрам = сумма x_v по граничным клеткам с нечётной степенью (3).
    #
    # Таким образом, условие чётности количества разноцветных пар сводится к:
    # сумма x_v по граничным клеткам с нечётной степенью ≡ 0 (mod 2)
    #
    # Теперь:
    # - Фиксированные клетки задают значения x_v.
    # - Остальные (зелёные) клетки — переменные.
    #
    # Нужно посчитать количество раскрасок x_v для зелёных клеток, при которых
    # сумма x_v по граничным клеткам с нечётной степенью ≡ 0 (mod 2).
    #
    # Если среди фиксированных клеток есть противоречия по x_v, решений нет.
    #
    # Итого:
    # 1) Определим множество граничных клеток с нечётной степенью (3 соседа).
    #    Это клетки на гранях, но не углы.
    #
    # 2) Рассмотрим сумму x_v по этим клеткам mod 2.
    #
    # 3) Фиксированные клетки задают значения x_v.
    #
    # 4) Остальные клетки — свободные переменные.
    #
    # 5) Условие: сумма x_v по граничным клеткам с нечётной степенью ≡ 0 (mod 2).
    #
    # 6) Если среди фиксированных клеток сумма по этим клеткам ≡ s (mod 2),
    #    то сумма по свободным граничным клеткам должна быть ≡ s (mod 2).
    #
    # 7) Количество свободных клеток: N - k
    #
    # 8) Количество свободных граничных клеток с нечётной степенью, не фиксированных: g
    #
    # 9) Тогда количество решений:
    #    - Если g=0:
    #       - Если s=0, то 2^(N-k) решений (нет ограничения)
    #       - Если s=1, то 0 решений
    #    - Если g>0:
    #       - Количество решений = 2^(N-k-1) (половина вариантов удовлетворяет условию)
    #
    # Но N = n*m может быть очень большим (до 10^18), поэтому вычислять 2^(N-k) напрямую нельзя.
    #
    # Однако, в условии сказано, что зелёные клетки можно красить в {0,1} произвольно,
    # но при этом условие чётности должно выполняться.
    #
    # Значит, количество решений — это количество раскрасок зелёных клеток,
    # удовлетворяющих линейному уравнению mod 2.
    #
    # Уравнение: сумма x_v по граничным клеткам с нечётной степенью ≡ s (mod 2)
    #
    # Если g=0 (нет свободных граничных клеток с нечётной степенью), то:
    # - Если s=0, решений 2^(N-k)
    # - Иначе 0
    #
    # Если g>0, решений 2^(N-k-1)
    #
    # Но N может быть очень большим, поэтому нужно вычислять степень по модулю.
    #
    # Вычислим:
    # total_cells = n*m
    # free_cells = total_cells - k
    #
    # Вычислим g — количество граничных клеток с нечётной степенью, не фиксированных.
    #
    # Для этого:
    # - Определим множество граничных клеток с 3 соседями:
    #   - Верхняя грань (i=1), кроме углов (j=2..m-1)
    #   - Нижняя грань (i=n), кроме углов (j=2..m-1)
    #   - Левая грань (j=1), кроме углов (i=2..n-1)
    #   - Правая грань (j=m), кроме углов (i=2..n-1)
    #
    # Количество таких клеток:
    # top_edge = m-2 if m>=3 else 0
    # bottom_edge = m-2 if m>=3 else 0
    # left_edge = n-2 if n>=3 else 0
    # right_edge = n-2 if n>=3 else 0
    #
    # g_total = top_edge + bottom_edge + left_edge + right_edge
    #
    # Теперь из g_total вычитаем количество фиксированных клеток, которые лежат на этих гранях.
    #
    # Для фиксированных клеток, если они лежат на этих гранях, считаем их количество.
    #
    # Далее вычисляем s = сумма x_v по фиксированным граничным клеткам с нечётной степенью mod 2.
    #
    # x_v для фиксированной клетки:
    # x_v = color(i,j) XOR parity(i,j) XOR b
    #
    # Но b — глобальный сдвиг, который мы можем выбрать.
    #
    # Однако, в условии нет ограничения на b, кроме того, что количество разноцветных пар должно быть чётным.
    #
    # Из анализа выше:
    # - Если b=0, количество разноцветных пар = E (число рёбер)
    # - Если b=1, количество разноцветных пар = 0
    #
    # Нужно, чтобы количество разноцветных пар было чётным.
    #
    # Значит:
    # - Если E чётно, b может быть 0 или 1
    # - Если E нечётно, b должен быть 1
    #
    # Теперь проверим, что фиксированные клетки не противоречат выбору b.
    #
    # Для каждой фиксированной клетки:
    # b = color(i,j) XOR parity(i,j)
    #
    # Если для разных фиксированных клеток b разный — решений нет.
    #
    # Итого алгоритм:
    #
    # 1) Вычислить E = 2*n*m - n - m
    # 2) Для каждой фиксированной клетки вычислить b_i = c_i XOR parity(i,j)
    # 3) Проверить, что все b_i равны (если k>0), иначе 0 решений
    # 4) Если k=0, b может быть 0 или 1
    # 5) Проверить чётность E:
    #    - Если b=0 и E нечётно => 0 решений
    #    - Иначе решения есть
    # 6) Вычислить g_total — количество граничных клеток с нечётной степенью
    # 7) Вычислить s = сумма x_v по фиксированным граничным клеткам с нечётной степенью mod 2
    #    где x_v = c_i XOR parity(i,j) XOR b
    # 8) Вычислить g = g_total - количество фиксированных граничных клеток с нечётной степенью
    # 9) free_cells = n*m - k
    # 10) Если g=0:
    #       - Если s=0: ответ = 2^free_cells mod MOD
    #       - Иначе 0
    #     Иначе:
    #       ответ = 2^(free_cells - 1) mod MOD
    #
    # Если k=0 (нет фиксированных клеток), то b может быть 0 или 1.
    # Тогда ответ = сумма ответов для b=0 и b=1.
    #
    # Реализуем.

    def mod_pow(base, exp, mod):
        result = 1
        cur = base % mod
        e = exp
        while e > 0:
            if e & 1:
                result = (result * cur) % mod
            cur = (cur * cur) % mod
            e >>= 1
        return result

    for _ in range(t):
        n,m,k = map(int,input().split())
        fixed = []
        b_values = set()
        parity = lambda x,y: (x+y)&1
        E = 2*n*m - n - m  # количество рёбер

        # Граничные клетки с 3 соседями:
        # верхняя грань (i=1, j=2..m-1)
        # нижняя грань (i=n, j=2..m-1)
        # левая грань (j=1, i=2..n-1)
        # правая грань (j=m, i=2..n-1)
        top_edge = max(0, m-2)
        bottom_edge = max(0, m-2)
        left_edge = max(0, n-2)
        right_edge = max(0, n-2)
        g_total = top_edge + bottom_edge + left_edge + right_edge

        fixed_set = set()
        fixed_on_g = []
        for __ in range(k):
            x,y,c = map(int,input().split())
            fixed.append((x,y,c))
            fixed_set.add((x,y))

        # Определим b из фиксированных клеток
        b_val = None
        for (x,y,c) in fixed:
            cur_b = c ^ parity(x,y)
            if b_val is None:
                b_val = cur_b
            elif b_val != cur_b:
                # Противоречие
                b_val = -1
                break

        if b_val == -1:
            # Нет решений
            print(0)
            continue

        # Если нет фиксированных клеток, b может быть 0 или 1
        b_candidates = [b_val] if b_val is not None else [0,1]

        ans = 0
        total_cells = n*m
        free_cells = total_cells - k

        # Для быстрого поиска фиксированных клеток на гранях с 3 соседями
        fixed_g_cells = []
        fixed_g_count = 0

        # Функция проверки, лежит ли клетка на грани с 3 соседями
        def is_g_cell(x,y):
            if x == 1 and 2 <= y <= m-1:
                return True
            if x == n and 2 <= y <= m-1:
                return True
            if y == 1 and 2 <= x <= n-1:
                return True
            if y == m and 2 <= x <= n-1:
                return True
            return False

        # Для каждого b_candidate считаем ответ
        for b in b_candidates:
            # Проверка чётности E при b=0
            if b == 0 and (E & 1) == 1:
                # Нет решений
                continue

            # Считаем s = сумма x_v по фиксированным граничным клеткам с 3 соседями mod 2
            s = 0
            fixed_g_count = 0
            for (x,y,c) in fixed:
                if is_g_cell(x,y):
                    fixed_g_count += 1
                    xv = c ^ parity(x,y) ^ b
                    s ^= xv

            g = g_total - fixed_g_count
            if g == 0:
                # Нет свободных граничных клеток с нечётной степенью
                if s == 0:
                    # Все варианты свободных клеток подходят
                    ans = (ans + mod_pow(2, free_cells, MOD)) % MOD
                else:
                    # Нет решений
                    ans = (ans + 0) % MOD
            else:
                # Есть свободные граничные клетки с нечётной степенью
                # Половина вариантов подходит
                if free_cells == 0:
                    # Если нет свободных клеток, то s должен быть 0, иначе 0
                    ans = (ans + (1 if s == 0 else 0)) % MOD
                else:
                    ans = (ans + mod_pow(2, free_cells - 1, MOD)) % MOD

        print(ans % MOD)

threading.Thread(target=main).start()