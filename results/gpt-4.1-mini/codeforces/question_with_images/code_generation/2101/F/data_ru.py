import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

MOD = 998244353

# Быстрое возведение в степень по модулю
def mod_pow(base, exp, mod):
    result = 1
    cur = base % mod
    while exp > 0:
        if exp & 1:
            result = (result * cur) % mod
        cur = (cur * cur) % mod
        exp >>= 1
    return result

t = int(input())
for _ in range(t):
    n = int(input())
    edges = [[] for __ in range(n)]
    for __ in range(n-1):
        u,v = map(int,input().split())
        u -= 1
        v -= 1
        edges[u].append(v)
        edges[v].append(u)

    # Предварительно считаем степени 3^k и 2^k для k=0..n
    pow3 = [1]*(n+1)
    pow2 = [1]*(n+1)
    for i in range(1,n+1):
        pow3[i] = (pow3[i-1]*3) % MOD
        pow2[i] = (pow2[i-1]*2) % MOD

    # Для каждого ребра (u,v) считаем размер поддерева при удалении ребра
    # Чтобы это сделать, сделаем dfs из 0, считаем size поддеревьев
    size = [0]*n
    parent = [-1]*n
    def dfs_size(u):
        size[u] = 1
        for w in edges[u]:
            if w == parent[u]:
                continue
            parent[w] = u
            dfs_size(w)
            size[u] += size[w]
    parent[0] = -1
    dfs_size(0)

    # Теперь для каждого ребра (u,v) определим размер одной из частей при удалении ребра
    # Если parent[v] == u, то size[v] - размер поддерева v
    # Иначе size[u] - размер поддерева u
    # Обозначим s = min(size_of_part, n - size_of_part)
    # Тогда количество раскрасок, где красная вершина в одной части, синяя в другой:
    # (3^n - 2*2^n + 1) - (3^s - 2*2^s + 1) - (3^{n-s} - 2*2^{n-s} + 1)
    # Но нам нужна сумма крутостей по всем раскраскам.
    # Рассмотрим формулу из editorial:
    # Сумма крутостей = sum по всем ребрам (кол-во раскрасок, где максимальное расстояние между красной и синей вершиной >= длины ребра)
    # Так как расстояния в дереве - целые, и максимальное расстояние между красной и синей вершиной >= k
    # можно посчитать по ребрам, что вклад ребра равен длине ребра (1) умноженной на количество раскрасок,
    # где красная и синяя вершины лежат в разных компонентах при удалении этого ребра.

    # Кол-во раскрасок, где красная и синяя вершины лежат в разных компонентах при удалении ребра:
    # = (3^n - 2*2^n + 1) - (3^s - 2*2^s + 1) - (3^{n-s} - 2*2^{n-s} + 1)
    # = 3^n - 2*2^n + 1 - 3^s + 2*2^s - 1 - 3^{n-s} + 2*2^{n-s} - 1
    # = 3^n - 3^s - 3^{n-s} - 2*2^n + 2*2^s + 2*2^{n-s} - 1

    # Но в условии крутость - максимальное расстояние между красной и синей вершиной,
    # а ребро длины 1, значит вклад ребра равен 1 * количество раскрасок с красной и синей вершинами в разных частях.
    # Для ребер длины > 1 (в дереве все ребра длины 1), поэтому просто суммируем по ребрам.

    # Итог: сумма крутостей = sum по ребрам (1 * количество раскрасок с красной и синей вершинами в разных частях)
    # = sum по ребрам [3^n - 3^s - 3^{n-s} - 2*2^n + 2*2^s + 2*2^{n-s} - 1]

    # Вычислим сумму по ребрам
    ans = 0
    for u in range(n):
        for v in edges[u]:
            if u < v:
                # Определим s - размер меньшей части при удалении ребра u-v
                if parent[v] == u:
                    s = size[v]
                elif parent[u] == v:
                    s = size[u]
                else:
                    # Ребро не в дереве dfs, значит надо определить s по размеру поддеревьев
                    # Но в дереве ребро всегда между родителем и ребенком
                    # Если не так, то сделаем dfs из u, чтобы определить
                    # Но по построению parent, ребро всегда между родителем и ребенком
                    # Поэтому сюда не попадем
                    s = min(size[u], size[v])
                n_s = n - s

                val = (pow3[n] - pow3[s] - pow3[n_s]) % MOD
                val -= (2 * pow2[n] - 2 * pow2[s] - 2 * pow2[n_s]) % MOD
                val -= 1
                val %= MOD
                ans += val
                ans %= MOD

    print(ans % MOD)