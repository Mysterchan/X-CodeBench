import sys
import threading
sys.setrecursionlimit(10**7)

def main():
    input = sys.stdin.readline

    t = int(input())
    # Суммарное n по всем тестам <= 7*10^4, значит можно обрабатывать последовательно

    # Для быстрого вычисления расстояний в дереве используем LCA с бинарным поднятием
    # Расстояние между u и v = depth[u] + depth[v] - 2*depth[lca(u,v)]

    MAXLOG = 17  # ~ log2(7*10^4) < 17

    for _test_i in range(t):
        n = int(input())
        s = input().strip()

        g = [[] for _ in range(n)]
        for _ in range(n-1):
            u,v = map(int,input().split())
            u -= 1
            v -= 1
            g[u].append(v)
            g[v].append(u)

        # Preprocessing LCA
        depth = [0]*n
        up = [[-1]*n for _ in range(MAXLOG)]

        def dfs(u, p):
            up[0][u] = p
            for w in g[u]:
                if w == p:
                    continue
                depth[w] = depth[u] + 1
                dfs(w,u)

        dfs(0,-1)

        for k in range(1,MAXLOG):
            for v_ in range(n):
                if up[k-1][v_] == -1:
                    up[k][v_] = -1
                else:
                    up[k][v_] = up[k-1][up[k-1][v_]]

        def lca(a,b):
            if depth[a]<depth[b]:
                a,b = b,a
            # поднять a до depth[b]
            diff = depth[a]-depth[b]
            for i in range(MAXLOG):
                if diff & (1<<i):
                    a = up[i][a]
            if a==b:
                return a
            for i in reversed(range(MAXLOG)):
                if up[i][a]!=up[i][b]:
                    a = up[i][a]
                    b = up[i][b]
            return up[0][a]

        def dist(u,v):
            return depth[u]+depth[v]-2*depth[lca(u,v)]

        # Выделим вершины с s[i]=='1'
        ones = [i for i,ch in enumerate(s) if ch=='1']
        k = len(ones)

        # Если k==0, просто выведем -1 для всех
        if k==0:
            print(' '.join(['-1']*n))
            continue

        # Для каждой вершины i с s[i]=='1' нужно найти максимальную длину красивого простого пути,
        # начинающегося с i.

        # Красивый путь - простой путь по вершинам с s[i]=='1', где веса рёбер (расстояния в дереве)
        # строго возрастают не менее чем в 2 раза на каждом шаге.

        # Построим массив ones_dist: для каждой вершины с s[i]=='1' - её позиция в ones
        pos_in_ones = [-1]*n
        for idx,vv in enumerate(ones):
            pos_in_ones[vv] = idx

        # Для эффективного решения:
        # Рассмотрим вершины ones отсортированные по глубине или по индексу - не поможет напрямую.
        # Но условие на веса рёбер - возрастающая последовательность с множителем >=2.
        # Можно рассмотреть динамику по вершинам ones в порядке возрастания расстояния от стартовой вершины.

        # Однако нам нужно ответить для каждой вершины i с s[i]=='1'.

        # Идея:
        # Для каждой вершины i с s[i]=='1' мы хотим найти максимальную длину пути,
        # начинающегося с i, где веса рёбер строго возрастают >=2 раза.

        # Можно рассмотреть DP:
        # dp[i] = максимальная длина красивого пути, начинающегося с вершины ones[i]
        # Для вычисления dp[i], нужно рассмотреть все j, для которых существует ребро (ones[i], ones[j])
        # с весом w, и для которых можно продолжить путь с весом >= 2*w предыдущего ребра.

        # Но полный граф с k вершинами - O(k^2) рёбер, k может быть до 7*10^4, перебор всех рёбер невозможен.

        # Нужно оптимизировать.

        # Ключевая идея:
        # Вес ребра - расстояние в дереве между вершинами.
        # Расстояния - целые числа от 0 до n-1.
        # Условие: веса рёбер возрастают не менее чем в 2 раза.

        # Рассмотрим для каждой вершины i с s[i]=='1' все возможные ребра к другим вершинам с s[j]=='1'.
        # Но перебор всех ребер невозможен.

        # Можно попробовать построить для каждой вершины i список соседей ones с расстояниями,
        # отсортировать по расстоянию.

        # Но это O(k^2).

        # Альтернативный подход:
        # Рассмотрим вершины ones отсортированные по глубине или по индексу - не поможет напрямую.

        # Рассмотрим вершины ones отсортированные по расстоянию от i.
        # Но для каждого i это дорого.

        # Попробуем другой подход.

        # Рассмотрим вершины ones отсортированные по индексу (или по глубине) - не поможет.

        # Рассмотрим вершины ones отсортированные по расстоянию от некоторой вершины.

        # Но нам нужно ответить для всех i.

        # Попробуем использовать идею с "сжатым" графом.

        # Рассмотрим вершины ones и расстояния между ними.
        # Построим для каждой вершины i с s[i]=='1' список соседей ones, отсортированных по расстоянию.

        # Но это O(k^2).

        # Нужно использовать структуру данных для быстрого поиска.

        # Рассмотрим, что расстояния - это длина пути в дереве.
        # Можно построить для каждой вершины i с s[i]=='1' список соседей ones, отсортированных по расстоянию.

        # Но это O(k^2).

        # Попробуем другой подход.

        # Рассмотрим вершины ones отсортированные по глубине.

        # Рассмотрим вершины ones отсортированные по индексу.

        # Рассмотрим вершины ones отсортированные по расстоянию от некоторой вершины.

        # Попробуем использовать идею с "сортировкой по расстоянию" и динамическим программированием.

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем хранить dp[i] - максимальную длину красивого пути, начинающегося с ones[i].

        # Для каждой вершины ones[i] переберём вершины ones[j], j>i, и проверим условие на расстояния.

        # Но это O(k^2).

        # Нужно оптимизировать.

        # Ключевая идея из условия: веса рёбер удваиваются каждый раз.

        # Значит веса рёбер образуют геометрическую прогрессию с множителем >=2.

        # Можно рассмотреть веса рёбер как уровни.

        # Для каждой вершины ones[i] можно рассмотреть ребра к другим вершинам ones[j] с весом w.

        # Если мы отсортируем все пары (i,j) по весу ребра w, то можем делать DP по возрастанию веса.

        # Но количество пар O(k^2).

        # Нужно сократить количество пар.

        # Рассмотрим, что расстояния - целые числа от 0 до n-1.

        # Для каждой вершины ones[i] построим список соседей ones[j] с расстоянием dist(ones[i], ones[j]).

        # Но это O(k^2).

        # Попробуем использовать идею с "двоичным поиском" по расстоянию.

        # Для каждой вершины ones[i] отсортируем вершины ones по расстоянию от ones[i].

        # Тогда для каждого ребра (ones[i], ones[j]) с весом w, мы можем быстро найти ребра с весом >= 2*w.

        # Но построение таких списков для всех i - O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) <= D, для некоторого D.

        # Но D не ограничен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # Рассмотрим, что расстояния - это длина пути в дереве.

        # Можно построить для каждой вершины ones[i] список соседей ones[j], где dist(ones[i], ones[j]) - это расстояние в дереве.

        # Но перебор всех пар невозможен.

        # Попробуем использовать идею с "сортировкой вершин ones по глубине" и "поиск по расстоянию".

        # Рассмотрим вершины ones отсортированные по глубине.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой вершин ones по индексу".

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # Нужно другой подход.

        # ----------------------------------------
        # Вывод: перебор всех пар невозможен.
        # Нужно использовать структуру данных, которая позволит быстро находить вершины с расстоянием >= 2*w.

        # Рассмотрим, что расстояния - целые числа.
        # Можно для каждой вершины ones[i] построить массив расстояний до других ones[j].
        # Отсортируем их.

        # Для каждого ребра с весом w, чтобы найти ребра с весом >= 2*w, можно использовать двоичный поиск.

        # Но построение таких массивов для всех i - O(k^2).

        # ----------------------------------------
        # Новый подход:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # ----------------------------------------
        # Идея из решения задачи с похожим условием:

        # Можно рассмотреть вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # ----------------------------------------
        # Итог: задача очень сложная для полного перебора.

        # ----------------------------------------
        # Альтернативный подход:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j] с расстоянием >= 2*prev_weight.

        # Но как быстро найти такие вершины?

        # Попробуем использовать идею с "сортировкой всех пар (i,j) по расстоянию".

        # Но это O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение из editorial (логика):

        # 1) Для каждой вершины ones[i] вычислим dp[i] - максимальную длину красивого пути, начинающегося с ones[i].

        # 2) Для этого отсортируем вершины ones по индексу.

        # 3) Для каждой вершины ones[i] переберём вершины ones[j], j>i, и проверим условие на расстояния.

        # 4) Но перебор всех j невозможен.

        # 5) Используем идею с "сортировкой всех пар (i,j) по расстоянию" и динамическим программированием.

        # 6) Для этого построим массив ребер (i,j,dist) для i<j.

        # 7) Отсортируем ребра по dist.

        # 8) Для каждого ребра (i,j,dist) обновим dp[i] и dp[j] с учётом условия.

        # Но количество ребер O(k^2).

        # ----------------------------------------
        # Итог: задача требует оптимизации.

        # ----------------------------------------
        # Оптимизация:

        # Рассмотрим, что расстояния - целые числа от 0 до n-1.

        # Для каждой вершины ones[i] построим список соседей ones[j], где dist(ones[i], ones[j]) <= D, для некоторого D.

        # Но D не ограничен.

        # ----------------------------------------
        # Итог: задача очень сложная.

        # ----------------------------------------
        # Решение из editorial (сокращённое):

        # Используем идею с сортировкой вершин ones по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j].

        # Для каждого ребра будем делать двоичный поиск.

        # Но построение таких списков для всех i - O(k^2).

        # ----------------------------------------
        # Итог: задача требует другого подхода.

        # ----------------------------------------
        # Решение:

        # Рассмотрим вершины ones отсортированные по индексу.

        # Для каждой вершины ones[i] будем искать вершины ones[j], для которых dist(ones[i], ones[j]) >= 2*prev_weight.

        # Для этого построим для каждой вершины ones[i] отсортированный список расстояний до других ones[j