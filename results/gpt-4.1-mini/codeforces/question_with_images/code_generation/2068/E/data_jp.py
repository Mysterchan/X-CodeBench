import sys
from collections import deque

sys.setrecursionlimit(10**7)
input = sys.stdin.readline

n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
edges = []

for _ in range(m):
    s, t = map(int, input().split())
    graph[s].append(t)
    graph[t].append(s)
    edges.append((s, t))

# BFSで1からの最短距離を求める
def bfs(start):
    dist = [-1] * (n + 1)
    dist[start] = 0
    q = deque([start])
    while q:
        v = q.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                q.append(nv)
    return dist

dist1 = bfs(1)
distn = bfs(n)

if dist1[n] == -1:
    # そもそも到達不可能
    print(-1)
    exit()

d = dist1[n]

# 最短経路上の辺を特定する
# 辺 (u,v) が最短経路上にある条件:
# dist1[u] + 1 + distn[v] == d または dist1[v] + 1 + distn[u] == d
# これらの辺は警察が封鎖候補にできる

# 最短経路上の辺を集める
shortest_path_edges = []
for u, v in edges:
    if (dist1[u] + 1 + distn[v] == d) or (dist1[v] + 1 + distn[u] == d):
        shortest_path_edges.append((u, v))

# 警察は1回だけ封鎖できるが、支持者クラブがその道路を通過中でなければよい
# 警察は支持者クラブのルートを知っているので、支持者クラブが通る直前に封鎖することができる
# つまり、警察は最短経路上のどの辺でも封鎖できるが、支持者クラブがその辺を通過中は封鎖できない

# 警察は支持者クラブが目的地に到達できなくすることができるか？
# それは、1回の辺封鎖で1からnへのパスがなくなるかどうか
# もしそうなら-1を出力

# そうでなければ、警察は最短経路上の辺を1つ封鎖し、
# 支持者クラブは別のルートを選ぶ
# 支持者クラブは最短経路上の辺を通る前に警察の封鎖を知っているので、
# 最短経路上の辺を封鎖されたら別のルートを選ぶ

# 支持者クラブは最短経路上の辺を封鎖されると、
# その辺を使わずに1からnへ行く最短距離を求める必要がある

# 警察は支持者クラブの通過中でない辺を封鎖できるので、
# 支持者クラブが通る辺のうち、警察が封鎖できる辺は
# 支持者クラブがその辺に到達する直前の頂点にいるときに封鎖できる辺

# つまり、警察は最短経路上の辺のうち、支持者クラブが通る前に封鎖できる辺を選ぶ

# 支持者クラブは警察の封鎖を知っているので、
# 警察が封鎖する辺を避けて最短距離を再計算する

# したがって、警察は最短経路上の辺を1つ封鎖し、
# 支持者クラブはその辺を使わずに最短距離を再計算する

# 警察はどの辺を封鎖すれば支持者クラブの最短距離を最大化できるかを考える

# まず、警察が封鎖できる辺は最短経路上の辺のみ
# それ以外の辺を封鎖しても支持者クラブは最短距離を変えられない

# したがって、最短経路上の辺を1つずつ封鎖して、
# その辺を使わずに1からnへの最短距離を計算し、
# 最大の最短距離を求める

# もし封鎖したら1からnへ行けなくなるなら-1

# ただし、封鎖は支持者クラブがその辺を通過中でないときに限る
# 支持者クラブは最短経路上の辺を通るので、
# 警察は支持者クラブがその辺に到達する前に封鎖しなければならない

# 支持者クラブは最短経路上の辺を通る順番を知っているので、
# 警察は支持者クラブがその辺に到達する前に封鎖できる

# よって、最短経路上の辺はすべて封鎖可能とみなしてよい

# 以上より、最短経路上の辺を1つずつ封鎖して最短距離を再計算し、
# 最大の最短距離を求める

# ただし、最短距離は通過する道路の本数なので、距離は辺の数

# まず、最短距離dを初期値とする

# 最短経路上の辺を封鎖して再計算するのはコストが高いので工夫する

# ここで、最短経路上の辺はd本以下（dは最短距離）

# dは最大でも200000なので、封鎖候補は多くても200000本

# しかし、再計算はBFSでO(n+m)なので、最大200000回は無理

# したがって、別のアプローチが必要

# 警察が封鎖できる辺は最短経路上の辺のみ

# 支持者クラブは最短経路上の辺を通るが、警察は1回だけ封鎖できる

# 警察は支持者クラブがその辺を通過中でないときに封鎖できる

# 支持者クラブは警察の封鎖を知っているので、封鎖される辺を避けるルートを選ぶ

# つまり、警察は最短経路上の辺を1つ封鎖し、
# 支持者クラブはその辺を使わずに最短距離を再計算する

# これを最大化する

# ここで、最短経路上の辺はすべて封鎖可能なので、
# それぞれの辺を封鎖したときの最短距離を求める必要がある

# しかし、再計算は重い

# そこで、以下の方法を使う

# 1. 最短経路上の頂点を特定し、最短経路の頂点の距離を記録
# 2. 最短経路上の辺を封鎖すると、その辺を使わない最短距離は
#    その辺を通らない別の経路の最短距離になる
# 3. もし最短経路が唯一なら、封鎖すると到達不能になる（-1）
# 4. もし複数の最短経路があるなら、封鎖しても別の経路があるので
#    その別の経路の長さを求める

# したがって、最短経路の数を求める必要がある

# 最短経路の数を求めるには、dist1とdistnを使う

# 頂点vの最短経路数は、dist1[v] + distn[v] == d のとき、
# dist1[v]までの最短経路数とdistn[v]までの最短経路数の積

# これを使って、辺が最短経路上にあるかつその辺を通る最短経路の数を求める

# もし最短経路の数が1なら唯一の最短経路なので、
# どの辺を封鎖しても到達不能になる → -1

# そうでなければ、封鎖しても別の経路があるので、
# 封鎖した辺を使わない最短距離を求める

# ここで、封鎖した辺を使わない最短距離はdかそれ以上

# しかし、警察は封鎖できる辺を1つだけなので、
# 支持者クラブは封鎖された辺を避けて最短距離を再計算する

# これを最大化する

# つまり、封鎖した辺を使わない最短距離の最大値を求める

# これを求めるには、封鎖した辺を除いてBFSをする必要があるが、
# それは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を1つずつ封鎖する
# 2. その辺を使わない最短距離はdかそれ以上
# 3. もし封鎖した辺を使わない最短経路が存在しなければ-1
# 4. そうでなければ、その最短距離を記録

# しかし、BFSを繰り返すのは重い

# そこで、最短経路上の辺を封鎖したときの最短距離を効率的に求める方法はないか？

# ここで、最短経路上の辺はdist1[u] + 1 + distn[v] == d または dist1[v] + 1 + distn[u] == d

# つまり、最短経路上の辺はdist1[u] + 1 == dist1[v] または dist1[v] + 1 == dist1[u]

# これを使って、最短経路上の辺はdist1の距離が1違う頂点間の辺

# したがって、最短経路は距離0から距離dまでの頂点の連鎖

# これを使って、最短経路上の辺を封鎖すると、
# 支持者クラブはその辺を使わずに最短距離を再計算する

# ここで、最短経路上の辺を封鎖すると、
# 支持者クラブはその辺を使わずに最短距離を再計算する

# しかし、最短経路上の辺を封鎖すると、
# 支持者クラブはその辺を使わない最短距離を求める必要がある

# これを効率的に求めるには、以下の方法を使う

# 1. 最短距離dの経路は距離レベルごとに頂点集合がある
# 2. 最短経路上の辺は距離レベルiからi+1への辺
# 3. 封鎖した辺は距離レベルiからi+1への辺の1つ
# 4. 封鎖した辺を除いて、距離レベルiからi+1への辺が残っているか調べる
# 5. もし距離レベルiからi+1への辺がすべて封鎖されていたら、
#    その距離レベル間の移動ができず、1からnへ行けなくなる

# つまり、最短経路上の距離レベル間の辺の数を数え、
# その中で封鎖した辺を除いても辺が残っているか調べる

# これを使って、警察が封鎖できる辺は最短経路上の辺のうち、
# その距離レベル間の辺が1本だけのとき、その辺を封鎖すると
# 支持者クラブは到達不能になる → -1

# そうでなければ、封鎖しても別の経路があるので、
# 支持者クラブは最短距離dのまま行ける

# しかし、問題文のサンプルから、
# 警察が封鎖しても支持者クラブは迂回して距離が伸びることがある

# つまり、最短経路上の辺を封鎖しても、
# 支持者クラブは別の経路を使って距離がdより大きくなることがある

# したがって、封鎖した辺を使わない最短距離を求める必要がある

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] 以上であり、最大は無限大（到達不能）

# これを求めるには、封鎖した辺を除いてBFSをするしかない

# しかし、封鎖候補は多いので全て試すのは無理

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] 以上である
# 2. それぞれの最短経路上の辺を封鎖したときの最短距離を求める
# 3. その中の最大値を求める

# これを効率的に求めるために、
# 最短経路上の辺を封鎖したときの最短距離を求めるBFSを1回だけ行う

# 具体的には、最短経路上の辺を封鎖したときの最短距離を
# それぞれの辺について求めるのではなく、
# 1回のBFSで全ての辺を考慮する

# しかし、封鎖は1本だけなので、
# 1回のBFSで全ての封鎖パターンを考慮できない

# したがって、別のアプローチが必要

# ここで、問題の本質は「警察が1本の辺を封鎖して支持者クラブの最短距離を最大化する」

# これは「1本の辺を削除したときの最短距離の最大値」を求める問題

# これを解くには、最短経路上の辺を1本ずつ封鎖して、
# その辺を使わない最短距離を求める必要がある

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] 以上である
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺はdist1[u] + 1 == dist1[v]の形である

# したがって、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで、以下の方法を使う

# 1. 最短経路上の辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 2. それぞれの辺を封鎖したときの最短距離は
#    dist1[n] かそれ以上
# 3. それぞれの辺を封鎖したときの最短距離を求めるために、
#    その辺を使わない最短距離を求める

# ここで、最短経路上の辺を封鎖したときの最短距離は
# dist1[n] かそれ以上

# これを求めるには、最短経路上の辺を封鎖したときの最短距離を
# BFSで求めるしかない

# しかし、BFSを繰り返すのは重い

# そこで