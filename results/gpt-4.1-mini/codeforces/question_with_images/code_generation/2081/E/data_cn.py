import sys
input = sys.stdin.readline
MOD = 998244353

# 預處理階乘與反階乘，用於計算組合數
MAX = 5000
fact = [1] * (MAX+1)
inv_fact = [1] * (MAX+1)
for i in range(2, MAX+1):
    fact[i] = fact[i-1] * i % MOD
inv_fact[MAX] = pow(fact[MAX], MOD-2, MOD)
for i in range(MAX-1, 0, -1):
    inv_fact[i] = inv_fact[i+1] * (i+1) % MOD

def comb(n, r):
    if r > n or r < 0:
        return 0
    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split()))

    # 根節點為0，邊(0,1)是初始晶片排列位置
    # 每個晶片的移動範圍是從根到d_i的路徑上的邊
    # 由於樹的結構，且p_i < i，且p_1=0，樹是有向且父節點編號小於子節點編號
    # 我們只需考慮晶片的d_i值，因為晶片只能在從0到d_i的路徑上移動
    # 由於晶片最終都要回到邊(0,1)，且只能在其移動範圍內移動
    # 這意味著晶片只能在邊(0,1)上和其移動範圍內的邊上移動
    # 操作允許在相鄰邊間上下移動晶片，且同色晶片可在同一邊上相鄰交換
    # 因此，晶片的相對順序在同色晶片中可任意調整（因為同色晶片可交換）
    # 但不同色晶片間的相對順序受限於移動範圍限制

    # 觀察：
    # 晶片初始在邊(0,1)，標籤升序排列
    # 晶片的移動範圍是從0到d_i的路徑
    # 由於樹的結構，d_i越大，晶片可移動的範圍越大
    # 晶片只能在其移動範圍內移動，且最終都要回到邊(0,1)
    # 這限制了晶片的相對順序改變
    # 但同色晶片可在同一邊上任意交換（相鄰同色晶片可交換多次）
    # 因此，最終排列中同色晶片的相對順序可以任意排列
    # 不同色晶片的相對順序則受限於移動範圍

    # 由於晶片初始排列是標籤升序，且晶片只能在其移動範圍內移動
    # 若晶片i的d_i < 晶片j的d_j，且i < j，晶片j不能移動到晶片i之前
    # 因此，晶片的排列必須保持對d_i的非降序排列
    # 也就是說，晶片的排列必須是d_i的非降序排列的某種重排
    # 但同色晶片可任意交換，故同色晶片的排列不受限制

    # 總結：
    # 晶片的最終排列必須是d_i非降序排列的排列
    # 同色晶片可任意排列
    # 因此，計算最終排列數量 = 
    #   對於每個顏色，計算該顏色晶片的數量
    #   對整體晶片，計算d_i的非降序排列數量
    #   由於d_i是固定的，且晶片標籤唯一，排列必須保持d_i非降序
    #   但同色晶片可任意交換，故同色晶片內部排列自由
    #   因此，最終排列數量 = 
    #       (所有晶片的排列數量) / (每個顏色晶片的排列數量)
    #   其中所有晶片的排列數量 = m!（因為標籤唯一）
    #   每個顏色晶片的排列數量 = color_count!

    # 但題目中晶片標籤唯一，且初始排列是標籤升序
    # 由於同色晶片可任意交換，最終排列中同色晶片的排列是任意的
    # 不同色晶片間的相對順序由d_i限制
    # 但d_i限制意味著晶片只能在d_i非降序排列中排列
    # 因此，最終排列數量 = 
    #   對於每個顏色，計算該顏色晶片的數量，然後計算排列數量為：
    #   m! / (黑色晶片數量! * 白色晶片數量!)

    # 但題目範例中第一個測試案例輸出2，表示排列數量不只是1
    # 需要更精確分析

    # 重新分析：
    # 晶片的移動範圍是從0到d_i的路徑
    # 由於樹的結構，晶片只能在邊(0,1)到邊(d_i-1,d_i)之間移動
    # 晶片最終都要回到邊(0,1)
    # 晶片只能在其移動範圍內移動，且只能上下移動到相鄰邊
    # 同色晶片可在同一邊上相鄰交換
    # 因此，晶片的最終排列必須是對d_i的非降序排列
    # 但同色晶片可任意交換，故同色晶片的排列自由
    # 也就是說，晶片的最終排列是對d_i非降序排列的排列，且同色晶片內部任意排列

    # 由於晶片標籤唯一，且初始排列是標籤升序
    # 我們可以將晶片按d_i分組，d_i越小的晶片必須排在越前面
    # 因此，晶片的排列必須是d_i的非降序排列
    # 同色晶片可任意交換，故同色晶片內部排列自由

    # 因此，計算最終排列數量 = 
    #   對d_i分組，計算每個d_i組內同色晶片的排列數量
    #   對整體，計算d_i非降序排列的排列數量 = 
    #   m! / (每個d_i組內晶片的排列數量)
    #   乘以每個d_i組內同色晶片的排列數量

    # 但d_i是晶片的移動範圍，且晶片標籤唯一
    # d_i非降序排列的排列數量 = 1（因為d_i固定）
    # 因此，最終排列數量 = 
    #   對每個d_i組內同色晶片的排列數量 = 
    #   對每個d_i組，計算黑色晶片數量的階乘 * 白色晶片數量的階乘

    # 但題目範例中第二個測試案例輸出8，表示排列數量是多於1的
    # 需要更精確的計算

    # 由於同色晶片可任意交換，晶片的排列數量 = 
    #   m! / (黑色晶片數量! * 白色晶片數量!)

    # 但晶片的移動範圍限制了晶片的相對順序
    # 由於晶片只能在其移動範圍內移動，晶片的排列必須是d_i非降序排列
    # 因此，晶片的排列數量 = 
    #   對d_i非降序排列的排列數量 * 同色晶片內部排列數量

    # 由於d_i非降序排列的排列數量 = 
    #   對d_i相同的晶片，排列自由
    #   對d_i不同的晶片，必須保持d_i非降序
    # 因此，晶片的排列數量 = 
    #   對d_i分組，計算每組內晶片的排列數量（同色晶片可任意交換）
    #   對整體，排列數量 = 
    #   m! / (每個d_i組內晶片的排列數量)

    # 但這與前面矛盾，需用DP計算

    # 解法：
    # 將晶片按d_i排序（初始即為標籤升序）
    # 對晶片按d_i分組
    # 對每組內，計算同色晶片數量
    # 由於同色晶片可任意交換，組內排列數量 = 組大小的階乘 / (黑色晶片數量! * 白色晶片數量!)
    # 對整體，排列數量 = m! / (每組內排列數量的乘積)

    # 但題目要求計算最終排列數量，且同色晶片可任意交換
    # 因此，最終排列數量 = 
    #   m! / (黑色晶片總數! * 白色晶片總數!) * ∏(每組內黑色晶片數! * 白色晶片數!)

    # 但這與範例不符，範例中第一個測試案例輸出2，表示排列數量是2

    # 重新思考：
    # 由於晶片只能在其移動範圍內移動，且最終都在邊(0,1)
    # 晶片的排列必須是d_i非降序排列
    # 同色晶片可任意交換
    # 因此，晶片的排列數量 = 
    #   對d_i非降序排列的排列數量 * ∏(每組內同色晶片排列數量)

    # d_i非降序排列的排列數量 = 
    #   對d_i分組，計算組間排列數量 = 
    #   m! / ∏(每組大小!)

    # 同色晶片排列數量 = ∏(每組內黑色晶片數! * 白色晶片數!)

    # 因此，最終排列數量 = 
    #   m! / ∏(每組大小!) * ∏(每組內黑色晶片數! * 白色晶片數!)

    # 實作此公式

    from collections import defaultdict

    # 按d_i分組晶片
    groups = defaultdict(list)
    for i in range(m):
        groups[d[i]].append(i)

    res = fact[m]
    for g in groups.values():
        size = len(g)
        res = res * inv_fact[size] % MOD
        black = sum(c[i] == 0 for i in g)
        white = size - black
        res = res * fact[black] % MOD
        res = res * fact[white] % MOD

    print(res % MOD)