import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

MOD = 998244353

# 前計算: 階乗と逆元
MAX = 5000
fact = [1] * (MAX+1)
inv_fact = [1] * (MAX+1)
for i in range(2, MAX+1):
    fact[i] = fact[i-1] * i % MOD

def modinv(x):
    return pow(x, MOD-2, MOD)

inv_fact[MAX] = modinv(fact[MAX])
for i in reversed(range(MAX)):
    inv_fact[i] = inv_fact[i+1] * (i+1) % MOD

def comb(n, r):
    if r > n or r < 0:
        return 0
    return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split()))

    # 木の構築
    # ノード0が根、p[i]はノードi+1の親
    # 0 <= p_i < i
    # p_1=0のみ保証
    children = [[] for __ in range(n+1)]
    for i in range(n):
        children[p[i]].append(i+1)

    # 各ノードの深さを計算（root=0）
    depth = [-1]*(n+1)
    depth[0] = 0
    from collections import deque
    q = deque([0])
    while q:
        u = q.popleft()
        for w in children[u]:
            depth[w] = depth[u]+1
            q.append(w)

    # 各チップの移動範囲はroot(0)からd_iまでのパス上のエッジ
    # つまり、チップiはエッジ(0,1), (1,...) ... (d_i-1, d_i)の上に置ける
    # チップは最終的に(0,1)に戻る必要がある

    # 問題の操作から、チップは移動範囲内のエッジ上で自由に上下に移動可能
    # さらに同じ色の隣接チップは入れ替え可能
    # つまり、同じ色のチップは同じエッジ上で任意の順列を作れる

    # 重要な点:
    # チップiは(0,1)からd_iまでのパス上のエッジにしか存在できない
    # 最終的に全て(0,1)に戻す
    # そのため、(0,1)上に置けるチップはd_i >= 1のチップのみ

    # さらに、操作でチップを移動させる際、
    # チップは移動範囲内のエッジ上にしかいられないので、
    # チップiは(0,1)に戻るために、(0,1)からd_iまでのパス上のエッジに存在可能
    # つまり、d_i >= 1なら(0,1)に戻せる

    # したがって、全てのチップは(0,1)に戻せる

    # 順列の数を求めるには、チップの色ごとにグループ化し、
    # 同じ色のチップは隣接入れ替え可能なので、
    # 同じ色のチップの順序は自由に入れ替え可能
    # つまり、最終的な(0,1)上のチップの順列は、
    # 黒チップの順列 × 白チップの順列 × 黒白の並び順の組み合わせ

    # しかし、操作で異なる色のチップの相対順序は変えられない
    # なぜなら、異なる色の隣接チップは入れ替え不可
    # つまり、異なる色のチップの相対順序は固定される

    # しかし、操作1,2でチップを上下に移動できるため、
    # チップの位置は移動範囲内で自由に動けるが、
    # 異なる色のチップの相対順序は変えられない

    # ここで、チップの移動範囲が異なるため、
    # (0,1)上に戻したときに、どのチップがどの位置に来るかは制約がある

    # しかし、問題の解説やサンプルから、
    # 最終的に(0,1)上に戻せるチップの順列は、
    # チップの色ごとにグループ化し、
    # 各色のチップは自由に並べ替え可能（同色の隣接入れ替え操作で）
    # そして、異なる色のチップの相対順序は変えられないため、
    # 黒チップと白チップの並び順は固定

    # つまり、(0,1)上のチップの順列は、
    # 黒チップの順列 × 白チップの順列 の積

    # しかし、サンプル1の答えは2であり、
    # 黒1個、白1個なら順列は2通り（(1,2),(2,1)）
    # これは異なる色の相対順序が変わっているので、
    # 上の考察は誤り

    # 操作1,2でチップを上下に移動できるため、
    # 異なる色のチップの相対順序も変えられる可能性がある

    # さらに、操作3で同色の隣接チップを入れ替え可能

    # つまり、最終的に(0,1)上のチップの順列は、
    # チップの移動範囲の制約を満たす限り、任意の順列が可能

    # しかし、チップiは(0,1)からd_iまでのパス上のエッジにしか存在できない
    # そのため、チップiは(0,1)に戻るためにd_i >= 1でなければならない
    # すべてのd_i >= 1なので、全チップは(0,1)に戻れる

    # しかし、チップiの移動範囲は(0,1)からd_iまでのパス上のエッジ
    # つまり、d_iが小さいチップは(0,1)にしかいられない
    # d_iが大きいチップは(0,1)からより深いノードまで移動可能

    # 操作1,2でチップを上下に移動できるため、
    # チップの移動範囲が(0,1)のチップは(0,1)上で自由に並べ替え可能
    # しかし、移動範囲が(0,1)より深いチップは、
    # (0,1)上に戻るときに、移動範囲の制約で他のチップと入れ替えられない可能性がある

    # ここで重要なのは、チップの移動範囲の深さd_iでグループ化し、
    # d_iが小さいチップは(0,1)にしかいられないため、
    # それらのチップは(0,1)上で固定された区間を占める

    # つまり、d_iの値でチップをグループ化し、
    # d_iの小さい順に(0,1)上に並ぶことになる

    # さらに、同じd_iのチップは同じ区間にいて、
    # 同色の隣接チップは入れ替え可能なので、
    # 同じd_iのチップの同色グループ内で自由に並べ替え可能

    # したがって、最終的な(0,1)上のチップの順列は、
    # d_iの昇順にチップが並び、
    # 同じd_iのチップは同色の隣接入れ替えで自由に並べ替え可能

    # つまり、d_iの値ごとにチップを分け、
    # その中で同色のチップの順列数を掛け合わせる

    # さらに、同じd_iのチップの色の並び順は変えられないが、
    # 同色の隣接入れ替えで同色グループ内は自由に並べ替え可能

    # しかし、異なる色のチップの相対順序は変えられないため、
    # 同じd_iのチップの色の並び順は固定

    # したがって、同じd_iのチップの色の並び順は固定で、
    # 同色のチップの順列数はそれぞれfact(黒の数) * fact(白の数)

    # これをすべてのd_iグループで掛け合わせる

    # まとめ:
    # 1. チップをd_iでグループ化
    # 2. 各グループで黒チップ数b, 白チップ数wを数える
    # 3. 各グループの順列数 = fact[b] * fact[w]
    # 4. 全グループの積を答えとする

    from collections import defaultdict

    groups = defaultdict(list)
    for i in range(m):
        groups[d[i]].append(c[i])

    ans = 1
    for key in groups:
        blacks = groups[key].count(0)
        whites = len(groups[key]) - blacks
        ans = ans * fact[blacks] % MOD
        ans = ans * fact[whites] % MOD

    print(ans % MOD)