import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

t = int(input())

# Идея решения:
# Пусть L - множество листьев.
# Для каждого листа u имя(u) - последовательность меток от корня до u.
# Нам нужно найти максимальную длину строки S, которая является подпоследовательностью всех name(u), u ∈ L,
# при условии, что суммарно ровно k нулей и n-k единиц распределены по вершинам.
#
# Рассмотрим глубину d - позицию в пути от корня.
# Пусть leaves_count[d][0] - количество листьев, у которых на глубине d можно поставить 0 (т.е. вершина на глубине d входит в путь к листу).
# Аналогично leaves_count[d][1] - количество листьев, у которых на глубине d можно поставить 1.
#
# Чтобы символ на позиции d входил в LCS всех листьев, он должен быть подпоследовательностью всех имен листьев,
# значит, на позиции d в пути к каждому листу должен быть этот символ или он может быть пропущен (т.к. подпоследовательность).
# Но чтобы символ был в LCS, он должен встречаться в именах всех листьев.
# Значит, на позиции d символ должен быть такой, что все листья имеют этот символ на позиции d.
#
# Но в дереве пути к листьям различаются, поэтому на позиции d у разных листьев могут быть разные вершины.
# Чтобы символ на позиции d был в LCS всех листьев, он должен быть одинаковым для всех листьев на позиции d.
# Но если на позиции d у листьев разные вершины, то символ на позиции d должен быть одинаковым для всех этих вершин.
#
# Следовательно, на позиции d символ может быть выбран только если все листья имеют одну и ту же вершину на глубине d.
# Но это возможно только если на глубине d все пути к листьям проходят через одну вершину.
#
# В общем случае, на позиции d LCS может содержать символ, если все листья имеют одинаковую метку на вершинах на глубине d.
#
# Но в дереве пути к листьям различаются, поэтому LCS - это последовательность глубин, на которых все листья имеют одинаковую метку.
#
# Таким образом, задача сводится к:
# - Для каждой глубины d определить, сколько листьев проходят через вершины на глубине d.
# - Если на глубине d листья проходят через несколько вершин, то символ на этой позиции должен быть одинаковым для всех этих вершин.
# - Значит, на глубине d мы должны выбрать один символ (0 или 1), и он должен быть одинаков для всех вершин на глубине d.
#
# Теперь, чтобы максимизировать длину LCS, нужно выбрать максимальное количество глубин d, для которых можно поставить символ,
# при этом суммарно количество нулей и единиц по всем вершинам равно k и n-k.
#
# Для каждой глубины d:
# - Пусть c = количество вершин на глубине d, которые лежат на пути к листьям (т.е. вершины, которые влияют на LCS).
# - Если мы выберем символ 0 на глубине d, то нам нужно использовать c нулей.
# - Если символ 1, то c единиц.
#
# Задача сводится к выбору подмножества глубин, чтобы сумма c по выбранным глубинам с символом 0 равнялась k,
# а сумма c по выбранным глубинам с символом 1 равнялась n-k, и максимизировать количество выбранных глубин.
#
# Но мы можем выбирать символ для каждой глубины независимо.
# Для каждой глубины d у нас есть два варианта:
# - выбрать 0: нужно c нулей
# - выбрать 1: нужно c единиц
#
# Мы хотим максимизировать количество выбранных глубин, при этом суммарно использовать ровно k нулей и n-k единиц.
#
# Это задача о выборе максимального количества глубин, где для каждой глубины выбирается либо 0 (требует c нулей), либо 1 (требует c единиц),
# и суммарно количество нулей равно k.
#
# Решение:
# - Соберём массив c по глубинам.
# - Для каждой глубины d у нас есть пара (c, c) - стоимость 0 и 1 одинаковая.
# - Мы хотим максимизировать количество выбранных глубин, при этом сумма выбранных c для 0 равна k.
#
# Но это невозможно, т.к. сумма c по всем вершинам равна n.
# Мы можем выбрать символ 0 на глубине d, тогда используем c нулей,
# или символ 1, тогда используем c единиц.
#
# Значит, для каждой глубины d мы должны выбрать символ, чтобы суммарно по всем глубинам сумма c для 0 равнялась k.
#
# Это задача о разбиении массива c на две части с суммами k и n-k.
#
# Мы хотим максимизировать количество выбранных глубин, т.е. максимальную длину подмассива, для которого сумма c равна k.
#
# Но мы должны использовать все вершины, значит сумма c по всем глубинам равна n.
#
# Значит, мы должны выбрать все глубины, и для каждой глубины выбрать символ 0 или 1,
# чтобы сумма c по глубинам с символом 0 равнялась k.
#
# Таким образом, задача сводится к проверке, можно ли разбить массив c на две части с суммами k и n-k.
#
# Если да, то ответ - количество глубин.
#
# Если нет, то нужно уменьшать количество глубин.
#
# Но в условии нет ограничений на последовательность глубин, значит мы можем выбрать любую подмножество глубин.
#
# Но чтобы LCS был максимальной длины, нужно выбрать максимальное количество глубин,
# для которых сумма c по выбранным глубинам с символом 0 равна k.
#
# Это задача о разбиении массива c на две части с суммами k и n-k.
#
# Решение:
# - Соберём массив c по глубинам.
# - Попытаемся найти подмножество c, сумма которого равна k.
# - Максимальная длина подмножества с суммой k - это ответ.
#
# Но сумма c равна n, и k ≤ n.
#
# Но c может быть очень большим (до n), и количество глубин может быть до n.
#
# Решение:
# - Используем жадный подход:
#   - Отсортируем c по возрастанию.
#   - Попытаемся набрать сумму k, выбирая c по возрастанию.
#   - Если сумма превысит k, попробуем заменить последний элемент.
#
# Но это не гарантирует решение.
#
# Однако, в задаче глубина - это уровень в дереве.
# Максимальная глубина ≤ n.
#
# Мы можем посчитать для каждой глубины количество вершин на этой глубине, которые лежат на пути к листьям.
#
# Далее, для каждой глубины d, c = количество вершин на глубине d, которые лежат на пути к листьям.
#
# Мы хотим максимизировать количество глубин, для которых можно выбрать символ 0 или 1,
# при этом суммарно количество нулей равно k.
#
# Это задача о разбиении массива c на две части с суммами k и n-k.
#
# Но в условии примеры показывают, что ответ - это максимальная длина LCS,
# которая равна количеству глубин, для которых можно выбрать символ,
# при этом суммарно количество нулей равно k.
#
# Следовательно, ответ - максимальная длина префикса глубин, для которого сумма c ≤ k или сумма c ≤ n-k.
#
# Но это не всегда префикс.
#
# Итоговое решение:
# - Посчитать для каждой глубины d количество листьев, проходящих через вершины на глубине d.
# - Для каждой глубины d получить c = количество вершин на глубине d, которые лежат на пути к листьям.
# - Теперь у нас есть массив c.
# - Мы хотим максимизировать количество глубин, для которых можно выбрать символ 0 или 1,
#   при этом суммарно количество нулей равно k.
#
# Это задача о разбиении массива c на две части с суммами k и n-k.
#
# Мы можем использовать динамическое программирование по сумме:
# dp[s] = максимальное количество глубин, которые можно выбрать с суммой c равной s.
#
# Но сумма c может быть до n, а количество глубин до n, что слишком дорого.
#
# Однако, в задаче сумма n по всем тестам ≤ 2*10^5, и t ≤ 10^4.
#
# Можно использовать битсет для dp.
#
# Но это может быть дорого.
#
# Альтернативный подход:
# - Сумма c равна n.
# - Мы хотим найти подмножество c с суммой k.
# - Если подмножество с суммой k существует, ответ - количество глубин.
# - Иначе ответ меньше.
#
# Но в примерах ответ всегда равен количеству глубин, если можно распределить метки.
#
# Значит, ответ - максимальная длина LCS = количество глубин, для которых можно выбрать символ,
# при условии, что сумма c по глубинам с символом 0 равна k.
#
# Но если мы не можем найти подмножество с суммой k, то ответ меньше.
#
# В задаче, однако, можно заметить, что LCS - это максимальная длина пути от корня до листа,
# для которого можно распределить метки так, чтобы сумма нулей и единиц совпадала.
#
# В итоге, ответ - максимальная глубина d, для которой сумма c по глубинам ≤ d не превышает k или n-k.
#
# Поэтому:
# - Посчитаем количество листьев.
# - Для каждой вершины посчитаем глубину.
# - Для каждой глубины посчитаем количество листьев, проходящих через вершины на этой глубине.
# - Ответ - максимальная длина префикса глубин, для которого можно распределить k нулей и n-k единиц.
#
# Реализация:
# - Построим дерево.
# - Найдём глубину каждой вершины.
# - Найдём листья.
# - Для каждой глубины посчитаем количество листьев, проходящих через вершины на этой глубине.
# - Для каждой глубины посчитаем количество вершин на этой глубине, которые лежат на пути к листьям.
# - Теперь у нас есть массив c.
# - Ответ - максимальная длина префикса массива c, для которого сумма c ≤ k или сумма c ≤ n-k.
#
# Выведем максимальное d, для которого min(sum_c_0, sum_c_1) ≤ k и n-k соответственно.

for _ in range(t):
    n, k = map(int, input().split())
    parents = list(map(int, input().split()))
    g = [[] for __ in range(n+1)]
    for i, p in enumerate(parents, start=2):
        g[p].append(i)

    depth = [0]*(n+1)
    depth[1] = 1
    from collections import deque
    q = deque([1])
    while q:
        u = q.popleft()
        for w in g[u]:
            depth[w] = depth[u] + 1
            q.append(w)

    # Найдём листья
    leaves = [i for i in range(1, n+1) if not g[i]]

    max_depth = max(depth)

    # Для каждой глубины посчитаем количество листьев, у которых путь проходит через вершину на этой глубине
    # Для этого для каждого листа увеличим счетчик для depth[u] по пути от листа к корню
    # Но это дорого (O(n^2))
    # Вместо этого, для каждого листа увеличим счетчик для depth[u] = depth[leaf]
    # Но нам нужно количество листьев, проходящих через вершины на глубине d
    # Путь от корня до листа - это вершины с глубинами от 1 до depth[leaf]
    # Значит, для глубины d количество листьев, у которых depth[leaf] >= d
    # Таким образом, для каждой глубины d количество листьев с depth >= d

    # Посчитаем количество листьев по глубинам
    count_leaves_depth = [0]*(max_depth+2)
    for leaf in leaves:
        count_leaves_depth[depth[leaf]] += 1

    # Префиксные суммы с конца, чтобы посчитать количество листьев с depth >= d
    for d in range(max_depth, 0, -1):
        count_leaves_depth[d] += count_leaves_depth[d+1]

    # Теперь для каждой глубины d количество листьев, проходящих через вершины на глубине d = count_leaves_depth[d]
    c = count_leaves_depth[1:max_depth+1]

    # Теперь нам нужно выбрать символы для каждой глубины d,
    # чтобы сумма c по глубинам с символом 0 равнялась k,
    # а сумма c по глубинам с символом 1 равнялась n-k,
    # и максимизировать количество выбранных глубин (т.е. длину LCS).

    # Попытаемся найти максимальную длину LCS = максимальное количество глубин,
    # для которых можно распределить k нулей и n-k единиц.

    # Для этого попробуем бинарный поиск по длине LCS:
    # Проверим, можно ли выбрать первые mid глубин так, чтобы сумма c по ним была ≤ k или ≤ n-k.

    prefix = [0]
    for x in c:
        prefix.append(prefix[-1] + x)

    left, right = 0, max_depth
    ans = 0
    while left <= right:
        mid = (left + right) // 2
        sum_c = prefix[mid]
        # Проверяем, можно ли распределить метки так, чтобы сумма нулей равнялась k
        # или сумма единиц равнялась n-k
        # Т.е. sum_c ≤ k или sum_c ≤ n-k
        if sum_c <= k or sum_c <= n - k:
            ans = mid
            left = mid + 1
        else:
            right = mid - 1

    print(ans)