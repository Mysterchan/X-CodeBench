import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    l = [0]*n
    r = [0]*n
    for i in range(n):
        li, ri = map(int, input().split())
        l[i], r[i] = li, ri

    # Полимино выпуклое, площадь четная.
    # Нужно проверить, можно ли разбить на два конгруэнтных связных полимино.
    # Конгруэнтность без поворотов и отражений означает, что одна часть - сдвиг другой.
    # Значит, существует сдвиг dx, такой что для каждой строки i:
    # множество клеток первой части + dx = множество клеток второй части.
    # Поскольку полимино выпуклое, в каждой строке от l[i] до r[i] подряд.
    # Разбиение на две части означает, что в каждой строке отрезок [l[i], r[i]] разбивается на две части одинаковой длины.
    # Площадь четная => сумма длин строк четна.
    # Если существует dx, такой что для всех i:
    # [l[i], r[i]] разбивается на две части длины (r[i]-l[i]+1)/2,
    # и вторая часть сдвинута на dx относительно первой.
    #
    # Иными словами, для всех i:
    # [l[i], r[i]] = A_i ∪ B_i, где B_i = A_i + dx, A_i и B_i связные отрезки одинаковой длины,
    # A_i и B_i не пересекаются, A_i ∩ B_i = ∅,
    # A_i и B_i лежат внутри [l[i], r[i]].
    #
    # Тогда:
    # длина каждого A_i = длина каждого B_i = (r[i]-l[i]+1)/2
    #
    # Пусть длина половины строки i: half_len_i = (r[i]-l[i]+1)//2
    #
    # Тогда для каждого i:
    # A_i = [a_i, a_i + half_len_i - 1]
    # B_i = [a_i + dx, a_i + dx + half_len_i - 1]
    #
    # И A_i и B_i должны лежать в [l[i], r[i]]:
    # l[i] ≤ a_i
    # a_i + half_len_i - 1 ≤ r[i]
    # l[i] ≤ a_i + dx
    # a_i + dx + half_len_i - 1 ≤ r[i]
    #
    # Из этого:
    # a_i ≥ l[i]
    # a_i ≤ r[i] - half_len_i + 1
    # a_i ≥ l[i] - dx
    # a_i ≤ r[i] - half_len_i + 1 - dx
    #
    # Значит:
    # a_i ∈ [max(l[i], l[i]-dx), min(r[i]-half_len_i+1, r[i]-half_len_i+1 - dx)]
    #
    # Чтобы такой a_i существовал, интервал должен быть непустым:
    # max(l[i], l[i]-dx) ≤ min(r[i]-half_len_i+1, r[i]-half_len_i+1 - dx)
    #
    # Рассмотрим два варианта разбиения:
    # 1) Разбиение по горизонтали (сдвиг по столбцам)
    # 2) Разбиение по вертикали (сдвиг по строкам)
    #
    # Но в условии сказано, что сдвиг - это перемещение (без поворотов и отражений),
    # значит сдвиг по строкам (вертикальный) невозможен, т.к. строки разные.
    #
    # Значит, сдвиг по столбцам.
    #
    # Попробуем перебрать dx = r[0] - l[0] - half_len_0 + 1 (сдвиг между двумя половинами первой строки)
    # и проверить, подходит ли он для всех строк.
    #
    # Если подходит, ответ YES, иначе NO.
    #
    # Также нужно проверить связность частей.
    # Но так как полимино выпуклое, и части - отрезки в каждой строке,
    # если для всех i разбиение существует с одним dx, то части связны.
    #
    # Проверим это.

    half_len = [(r[i] - l[i] + 1)//2 for i in range(n)]

    # Возможные dx: сдвиг между двумя половинами первой строки
    # Первая половина: [l[0], l[0] + half_len[0] - 1]
    # Вторая половина: [l[0] + dx, l[0] + dx + half_len[0] - 1]
    # Вторая половина должна лежать в [l[0], r[0]], значит:
    # l[0] ≤ l[0] + dx ≤ r[0] - half_len[0] + 1
    # dx ∈ [0, r[0] - half_len[0] + 1 - l[0]]
    #
    # Переберем dx в этом диапазоне и проверим для всех строк.

    # Но перебор всех dx может быть слишком большим (до 10^9).
    # Нужно проверить только два варианта:
    # 1) dx = r[0] - half_len[0] + 1 - l[0] (максимальный сдвиг)
    # 2) dx = 0 (минимальный сдвиг)
    #
    # Почему? Потому что разбиение должно быть конгруэнтным и связным,
    # и сдвиг должен быть одинаковым для всех строк.
    #
    # Проверим оба варианта.

    def can_split(dx):
        for i in range(n):
            left_bound = max(l[i], l[i] - dx)
            right_bound = min(r[i] - half_len[i] + 1, r[i] - half_len[i] + 1 - dx)
            if left_bound > right_bound:
                return False
        return True

    dx_candidates = [0, r[0] - half_len[0] + 1 - l[0]]

    if any(can_split(dx) for dx in dx_candidates):
        print("YES")
    else:
        print("NO")