import sys
input = sys.stdin.readline

# 判斷一個圖是否有歐拉路徑的條件：
# 1. 圖是連通的（題目已保證）
# 2. 頂點中度數為奇數的數量為0或2

# 題目給定：
# - G有歐拉路徑，且不是路徑圖（非所有頂點度數<=2的樹）
# - 要判斷L^k(G)是否有歐拉路徑

# 分析：
# L(G)的頂點是G的邊，L(G)中一個頂點的度數是該邊在G中兩端點的度數之和減2
# deg_L(e) = deg_G(u) + deg_G(v) - 2, e=(u,v)

# L^k(G)的頂點是L^{k-1}(G)的邊，度數計算同理。

# 但題目規模大，無法模擬構造。

# 重要性質與推論：
# 1. G有歐拉路徑，且非路徑圖 => G中至少有一個頂點度數>2
# 2. L(G)的度數分布由G的度數決定，且度數>2的頂點會使L(G)中度數分布更複雜
# 3. L(G)的歐拉路徑存在性取決於奇度數頂點數量是否為0或2

# 觀察樣例與題意：
# - k=1時，L(G)的歐拉路徑存在性不一定與G相同
# - k>=2時，L^k(G)的結構趨於穩定，且題中第一個樣例k=2時L^2(G)同構於G，仍有歐拉路徑
# - 但第二個樣例k=1時L(G)無歐拉路徑
# - 第三個樣例k=3時有歐拉路徑
# - 第四個樣例k=2時無歐拉路徑

# 經典結果（線圖的歐拉路徑性質）：
# - 若G有歐拉路徑且非路徑圖，則L(G)有歐拉路徑當且僅當G不是星形圖（中心點連接所有邊）
# - 但題中無星形圖限制，且k可大於1

# 透過題目與測試，推測：
# - k=1時，L(G)是否有歐拉路徑需計算
# - k>=2時，L^k(G)是否有歐拉路徑與G是否為環圖（所有頂點度數=2）有關
#   因為L(G)的度數會趨向穩定，且環圖的線圖仍是環圖，保持歐拉路徑
#   非環圖經過多次線圖轉換後，奇度數頂點數會超過2，無歐拉路徑

# 但題中G有歐拉路徑且非路徑圖，且G連通，故G不是樹，可能有環。

# 簡化策略：
# 1. 計算G中每個頂點度數
# 2. 判斷G是否為環圖（所有頂點度數=2）
# 3. 若k=1，計算L(G)中奇度數頂點數是否為0或2
#    L(G)中每個頂點對應G中一條邊e=(u,v)，度數為deg(u)+deg(v)-2
#    計算所有邊的度數，統計奇度數頂點數
# 4. 若k>=2：
#    - 若G是環圖，L^k(G)仍是環圖，有歐拉路徑 => YES
#    - 否則 NO

# 複雜度：
# - 總邊數和頂點數和不超過2*10^5，計算度數和判斷奇度數頂點數可行

t = int(input())
for _ in range(t):
    n,m,k = map(int,input().split())
    deg = [0]*(n+1)
    edges = []
    for __ in range(m):
        u,v = map(int,input().split())
        deg[u]+=1
        deg[v]+=1
        edges.append((u,v))
    # 判斷是否為環圖
    # 環圖：所有頂點度數=2且連通（題中保證連通）
    is_cycle = True
    for i in range(1,n+1):
        if deg[i] != 2:
            is_cycle = False
            break
    if k >= 2:
        # k>=2時，只有環圖才有歐拉路徑
        print("YES" if is_cycle else "NO")
    else:
        # k=1時，計算L(G)中奇度數頂點數
        # L(G)頂點為G的邊，度數為deg(u)+deg(v)-2
        odd_count = 0
        for u,v in edges:
            d = deg[u] + deg[v] - 2
            if d % 2 == 1:
                odd_count += 1
        # L(G)有歐拉路徑當且僅當奇度數頂點數為0或2
        print("YES" if odd_count == 0 or odd_count == 2 else "NO")