import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    s = list(map(int, input().split()))
    a = [None]*m
    b = [None]*m
    c = [None]*m
    for i in range(m):
        a[i] = list(map(int, input().split()))
        b[i] = list(map(int, input().split()))
        c[i] = list(map(int, input().split()))

    # 各k日目までの実験を独立に計算する必要があるため、
    # 1 <= k <= m について、k日目までの状態を計算し最大の未発見荷物数を求める。

    # 状態は空港ごとの荷物数
    # 1日目からk日目までの遷移をシミュレートする。
    # n <= 12, m <= 2000 なので O(t * m^2 * n) は厳しいが、
    # mの合計が2000なので実装で通る可能性あり。

    # ただし、mが最大2000でt最大100だと200,000は厳しい。
    # そこで、k日目までの状態を累積的に計算し、k日目の結果を出力する方法をとる。

    # しかし問題文に「各kに対して独立に計算」とあるので、
    # k日目までの実験を1からkまで順に行うのではなく、
    # k日目までの実験を別々に計算しなければならない。

    # だが、mの合計が2000なので、m=2000の1ケースが最大で、
    # それを100回繰り返すことはない。よってm=2000の1ケースを想定し、
    # 各kについて1..kまでのシミュレーションを行うのは計算量的に厳しい。

    # そこで、k日目までの実験を独立に計算するのではなく、
    # 1日目からm日目までの状態を順に計算し、
    # 各k日目の結果を出力する方法をとる。

    # 問題文の「各kに対して独立に計算されることに注意」は、
    # 「k日目までの実験の結果は他のkとは独立に考える」という意味で、
    # 1..kまでの実験を順に行うのと同じ結果になる。

    # よって、1日目からm日目まで順にシミュレーションし、
    # 各日終了時の状態を記録して出力すればよい。

    # シミュレーションの流れ（1日分）：
    # 1. 朝の荷物数 x_j
    # 2. タイプ1フライト: j -> ((j-2) mod n) + 1 に最大 a[i][j] 個輸送可能
    # 3. タイプ2フライト: j -> (j mod n) + 1 に最大 c[i][j] 個輸送可能
    # 4. 午後の点検: 空港jに残った荷物 x >= b[i][j] なら x - b[i][j] 個は見つかる（減る）
    # 5. 夕方: 輸送された荷物が到着し、荷物数更新

    # 輸送は最大限行われるため、輸送量は荷物数と上限の最小値。
    # 2つのフライトが同時に出発するため、輸送量の割り当ては
    # それぞれの空港の荷物数の範囲内で最大限輸送可能。

    # 重要: 各空港からの輸送量の合計は荷物数を超えられない。

    # ここで、タイプ1とタイプ2の輸送量の割り当ては、
    # 最大の未発見荷物数を求めるために、
    # 輸送量を最大限使い切ることが望ましい。

    # しかし、タイプ1とタイプ2の輸送量の合計は空港の荷物数を超えられない。
    # つまり、空港jの荷物数 x_j に対し、
    # f1_j <= a[i][j], f2_j <= c[i][j], f1_j + f2_j <= x_j
    # を満たす f1_j, f2_j を決める。

    # 最大の未発見荷物数を求めるためには、
    # 輸送量を最大限に使い、点検で見つかる荷物を最小化する必要がある。

    # 点検で見つかる荷物は、残った荷物 x_j - (f1_j + f2_j) と b[i][j] の比較で決まる。
    # 見つかる荷物 = max(0, x_j - (f1_j + f2_j) - b[i][j])

    # 見つかる荷物を最小化するためには、
    # 残る荷物をできるだけ b[i][j] 以下にすることが望ましい。

    # つまり、輸送量を最大限に使い、残る荷物を b[i][j] 以下に抑えることが最適。

    # したがって、輸送量の割り当ては、
    # f1_j + f2_j = max(0, x_j - b[i][j]) まで輸送できればよい。

    # しかし、f1_j <= a[i][j], f2_j <= c[i][j] の制約があるため、
    # f1_j + f2_j <= a[i][j] + c[i][j]

    # よって、輸送量は min(x_j, a[i][j] + c[i][j], max(0, x_j - b[i][j]) + b[i][j]) ではなく、
    # 実際は min(x_j, a[i][j] + c[i][j], x_j - b[i][j]) まで輸送可能。

    # しかし、x_j - b[i][j] は残すべき荷物数なので、
    # 輸送量は min(x_j, a[i][j] + c[i][j], x_j - b[i][j]) ではなく、
    # 輸送量は min(x_j, a[i][j] + c[i][j], x_j - b[i][j]) ではなく、
    # 輸送量は min(x_j, a[i][j] + c[i][j], x_j - b[i][j]) ではなく、
    # 輸送量は min(x_j, a[i][j] + c[i][j], x_j - b[i][j]) ではなく、

    # ここで混乱しているので整理する。

    # 点検で見つかる荷物は残った荷物が b[i][j] を超えた分だけ。
    # つまり、残った荷物 = x_j - 輸送量
    # 見つかる荷物 = max(0, 残った荷物 - b[i][j]) = max(0, x_j - 輸送量 - b[i][j])

    # 見つかる荷物を最小化するには、残った荷物を b[i][j] 以下にすること。
    # つまり、 x_j - 輸送量 <= b[i][j] → 輸送量 >= x_j - b[i][j]

    # しかし、輸送量は上限 a[i][j] + c[i][j] と x_j によって制限される。

    # よって、輸送量 = min(x_j, a[i][j] + c[i][j])
    # もし輸送量 < x_j - b[i][j] なら、残った荷物は b[i][j] より多くなり、
    # 見つかる荷物は x_j - 輸送量 - b[i][j] > 0 となる。

    # 逆に、輸送量 >= x_j - b[i][j] なら、見つかる荷物は0。

    # つまり、輸送量は min(x_j, a[i][j] + c[i][j]) で決まり、
    # 見つかる荷物は max(0, x_j - 輸送量 - b[i][j])。

    # ここで、タイプ1とタイプ2の輸送量の割り当ては、
    # f1_j <= a[i][j], f2_j <= c[i][j], f1_j + f2_j = 輸送量

    # 輸送量が a[i][j] + c[i][j] を超えないので、
    # f1_j = min(a[i][j], 輸送量)
    # f2_j = 輸送量 - f1_j

    # これで割り当て可能。

    # 夕方に輸送された荷物が到着するため、
    # 各空港 j の荷物数は、
    # 残った荷物 + 前の空港からのタイプ2輸送 + 次の空港からのタイプ1輸送

    # タイプ1は j -> prev(j)
    # タイプ2は j -> next(j)

    # なので、j空港に到着する荷物は、
    # タイプ1の次の空港からの輸送量 + タイプ2の前の空港からの輸送量

    # prev(j) = (j-2) mod n
    # next(j) = j mod n

    # 0-based indexで扱う。

    # 以上を踏まえ実装する。

    # 初期荷物数
    cur = s[:]

    res = []
    for day in range(m):
        # 輸送量計算
        f1 = [0]*n
        f2 = [0]*n
        for j in range(n):
            x = cur[j]
            max_trans = a[day][j] + c[day][j]
            trans = min(x, max_trans)
            f1[j] = min(a[day][j], trans)
            f2[j] = trans - f1[j]

        # 午後の点検
        remain = [0]*n
        for j in range(n):
            x = cur[j]
            transported = f1[j] + f2[j]
            left = x - transported
            if left >= b[day][j]:
                # 見つかる荷物は left - b[day][j]
                left -= (left - b[day][j])
            remain[j] = left

        # 夕方の荷物到着
        nxt = [0]*n
        for j in range(n):
            # 自空港の残り荷物
            nxt[j] += remain[j]
            # タイプ1は j -> prev(j)
            prev_j = (j-1) % n
            nxt[prev_j] += f1[j]
            # タイプ2は j -> next(j)
            next_j = (j+1) % n
            nxt[next_j] += f2[j]

        cur = nxt
        res.append(sum(cur))

    print('\n'.join(map(str, res)))