import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    s = list(map(int, input().split()))
    a = [None]*m
    b = [None]*m
    c = [None]*m
    for i in range(m):
        a[i] = list(map(int, input().split()))
        b[i] = list(map(int, input().split()))
        c[i] = list(map(int, input().split()))

    # Для каждого k от 1 до m нужно найти максимальное количество потерянных чемоданов,
    # которые могут остаться не найденными после k дней.
    # Задача сводится к решению задачи максимизации x = sum(x_j),
    # где x_j - количество чемоданов в аэропорту j после k дней,
    # с учетом ограничений перевозок и проверок.

    # Рассмотрим динамическое программирование по дням.
    # На каждом дне:
    # - Утром в аэропортах есть s_j чемоданов.
    # - Из аэропорта j вылетают два рейса:
    #   - в предыдущий аэропорт: максимум a[i][j]
    #   - в следующий аэропорт: максимум c[i][j]
    # - После вылета чемоданов в аэропорту j остаётся x_j = s_j - (перевезено в рейсах из j)
    # - Если x_j >= b[i][j], то найдено x_j - b[i][j] чемоданов, и они исчезают.
    #   Значит, после проверки в аэропорту j остаётся min(x_j, b[i][j]) чемоданов.
    # - Вечером чемоданы, перевезённые в рейсах, прибывают в целевые аэропорты.

    # Нам нужно максимизировать сумму чемоданов после k дней.
    # Для каждого k задача решается независимо, то есть мы можем для каждого k
    # решить задачу с исходным s и параметрами первых k дней.

    # Ограничения: n ≤ 12, m ≤ 2000, t ≤ 100, суммарно m ≤ 2000.
    # Решать задачу для каждого k отдельно - слишком дорого.
    # Решим для k=1, затем для k=2, ... наращивая решение.

    # Модель:
    # В каждый день i мы можем выбрать, сколько чемоданов отправить в рейсы из каждого аэропорта,
    # с ограничениями:
    #   0 ≤ x_i_j ≤ s_j (исходное количество в аэропорту j утром)
    #   x_i_j ≤ a[i][j] (максимум в рейс в предыдущий аэропорт)
    #   y_i_j ≤ c[i][j] (максимум в рейс в следующий аэропорт)
    #   x_i_j + y_i_j ≤ s_j
    #
    # После вылета:
    #   остались s_j - (x_i_j + y_i_j)
    # После проверки:
    #   min(осталось, b[i][j]) остаётся
    #
    # Вечером:
    #   чемоданы, отправленные в рейсы, прибывают в целевые аэропорты:
    #   - x_i_j (в рейсе в предыдущий аэропорт) прибудут в ((j-2) mod n)+1
    #   - y_i_j (в рейсе в следующий аэропорт) прибудут в ((j) mod n)+1

    # Таким образом, переход от s к s' задаётся линейной системой с ограничениями.
    # Нам нужно максимизировать sum s' после k дней.

    # Решение:
    # Для каждого дня i мы решаем задачу максимизации sum s' при ограничениях.
    # Но это задача линейного программирования.
    # Однако n ≤ 12, можно перебрать все варианты распределения чемоданов,
    # но это слишком много.

    # Попробуем упростить:
    # Переменные: для каждого j - сколько отправить в предыдущий (x_j) и в следующий (y_j).
    # Ограничения:
    #   0 ≤ x_j ≤ a[i][j]
    #   0 ≤ y_j ≤ c[i][j]
    #   x_j + y_j ≤ s_j (текущие чемоданы в аэропорту j)
    #
    # После вылета:
    #   ост_j = s_j - (x_j + y_j)
    # После проверки:
    #   ост_j = min(ост_j, b[i][j])
    #
    # Вечером:
    #   s'_j = ост_j + sum чемоданов, прибывших из соседних аэропортов:
    #       s'_j = ост_j + x_{j+1} + y_{j-1}
    #       где индексы по модулю n (сдвиги по кругу)
    #
    # Нам нужно максимизировать sum s'_j.

    # Перепишем:
    # sum s'_j = sum ост_j + sum x_{j+1} + sum y_{j-1} = sum ост_j + sum x_j + sum y_j
    # Но sum x_j + sum y_j = sum (x_j + y_j)
    # sum ост_j = sum min(s_j - (x_j + y_j), b[i][j])

    # Значит:
    # sum s'_j = sum min(s_j - (x_j + y_j), b[i][j]) + sum (x_j + y_j)

    # Обозначим z_j = x_j + y_j, 0 ≤ z_j ≤ min(s_j, a[i][j] + c[i][j]) (т.к. x_j ≤ a[i][j], y_j ≤ c[i][j], x_j + y_j ≤ s_j)
    # Но x_j и y_j отдельно ограничены, поэтому z_j ≤ min(s_j, a[i][j] + c[i][j]) и z_j ≤ s_j
    # Но нужно проверить, что z_j можно разбить на x_j и y_j с ограничениями:
    #   0 ≤ x_j ≤ a[i][j]
    #   0 ≤ y_j ≤ c[i][j]
    #   x_j + y_j = z_j
    # Это возможно, если z_j ≤ a[i][j] + c[i][j]

    # Значит, для каждого j:
    #   0 ≤ z_j ≤ min(s_j, a[i][j] + c[i][j])

    # Тогда sum s'_j = sum min(s_j - z_j, b[i][j]) + sum z_j

    # Функция для каждого j:
    # f_j(z_j) = min(s_j - z_j, b[i][j]) + z_j
    # Рассмотрим поведение f_j(z_j):
    # Если s_j - z_j ≤ b[i][j], то min = s_j - z_j, и f_j(z_j) = s_j - z_j + z_j = s_j
    # Если s_j - z_j > b[i][j], то min = b[i][j], и f_j(z_j) = b[i][j] + z_j

    # Порог: s_j - z_j = b[i][j] => z_j = s_j - b[i][j]

    # Для z_j ≤ s_j - b[i][j]:
    #   f_j(z_j) = b[i][j] + z_j (растёт с z_j)
    # Для z_j ≥ s_j - b[i][j]:
    #   f_j(z_j) = s_j (константа)

    # Значит, f_j(z_j) растёт линейно до z_j = s_j - b[i][j], потом становится константой s_j.

    # Максимизируем sum f_j(z_j) при ограничениях:
    # 0 ≤ z_j ≤ min(s_j, a[i][j] + c[i][j])

    # Оптимально брать z_j как можно больше, но не меньше s_j - b[i][j], чтобы получить максимум s_j.
    # Если s_j - b[i][j] ≤ 0, то f_j(z_j) = s_j для любого z_j ≥ 0, значит берем максимальный z_j.
    # Если s_j - b[i][j] > 0, то:
    #   - если max z_j < s_j - b[i][j], то f_j(z_j) = b[i][j] + z_j, максимум при z_j = max z_j
    #   - если max z_j ≥ s_j - b[i][j], то f_j(z_j) = s_j при z_j ≥ s_j - b[i][j]

    # Значит для каждого j:
    # z_j_max = min(s_j, a[i][j] + c[i][j])
    # threshold = s_j - b[i][j]
    # Если threshold ≤ 0:
    #   берем z_j = z_j_max, f_j = s_j
    # Если threshold > 0:
    #   если z_j_max < threshold:
    #       f_j = b[i][j] + z_j_max
    #   иначе:
    #       f_j = s_j

    # sum f_j(z_j) - это максимальное количество чемоданов после дня i.

    # Но нам нужно получить s' для следующего дня:
    # s'_j = ост_j + x_{j+1} + y_{j-1}
    # Мы не знаем отдельно x_j и y_j, но можем распределить z_j между x_j и y_j,
    # чтобы максимизировать s' (т.е. чтобы s' = ост_j + x_{j+1} + y_{j-1}).

    # Чтобы максимизировать s', нужно распределить z_j так, чтобы сумма x_{j+1} + y_{j-1} была максимальна.

    # Но x_j ≤ a[i][j], y_j ≤ c[i][j], x_j + y_j = z_j.

    # Для s'_j = ост_j + x_{j+1} + y_{j-1}:
    # s'_j зависит от x_{j+1} и y_{j-1}.

    # Чтобы максимизировать sum s'_j, нужно максимизировать sum x_j + sum y_j = sum z_j.

    # Но sum s'_j = sum ост_j + sum x_j + sum y_j = sum ост_j + sum z_j = sum f_j(z_j).

    # Значит, максимальное sum s'_j = sum f_j(z_j).

    # Теперь нужно получить s' для следующего дня:
    # s'_j = ост_j + x_{j+1} + y_{j-1}
    # Мы знаем z_j = x_j + y_j, но не знаем x_j и y_j отдельно.

    # Чтобы получить s' для следующего дня, нужно распределить z_j между x_j и y_j так,
    # чтобы s'_j = ост_j + x_{j+1} + y_{j-1} было корректно.

    # Заметим, что s'_j зависит от x_{j+1} и y_{j-1}, то есть от соседних аэропортов.

    # Для каждого j:
    # s'_j = ост_j + x_{j+1} + y_{j-1}

    # Если мы выберем x_j и y_j так, чтобы x_j = min(z_j, a[i][j]) и y_j = z_j - x_j (если возможно),
    # то x_j максимально возможен, а y_j минимален, или наоборот.

    # Чтобы максимизировать s'_j, нужно максимизировать x_{j+1} + y_{j-1}.

    # Для каждого j, чтобы максимизировать s'_j, нужно максимизировать x_{j+1} и y_{j-1}.

    # Но сумма x_j + y_j = z_j фиксирована.

    # Оптимальное распределение z_j между x_j и y_j:
    # - x_j ≤ a[i][j]
    # - y_j ≤ c[i][j]
    # - x_j + y_j = z_j

    # Чтобы максимизировать сумму x_{j+1} + y_{j-1} по j, нужно максимизировать сумму x_j + y_j,
    # что уже сделано.

    # Но для корректного перехода s'_j = ост_j + x_{j+1} + y_{j-1} нужно знать x_j и y_j.

    # Предлагаем следующий подход:
    # Для каждого j:
    #   z_j = выбранное значение (максимально возможное по описанным правилам)
    #   x_j = min(z_j, a[i][j])
    #   y_j = z_j - x_j
    #   (y_j ≤ c[i][j] гарантируется, т.к. z_j ≤ a[i][j] + c[i][j])

    # Тогда s'_j = ост_j + x_{j+1} + y_{j-1}

    # Ост_j = min(s_j - z_j, b[i][j])

    # Реализуем этот переход.

    # Начинаем с s = исходного массива.

    # Для каждого дня i:
    #   для каждого j:
    #       z_j_max = min(s_j, a[i][j] + c[i][j])
    #       threshold = s_j - b[i][j]
    #       если threshold ≤ 0:
    #           z_j = z_j_max
    #       иначе:
    #           если z_j_max < threshold:
    #               z_j = z_j_max
    #           иначе:
    #               z_j = threshold
    #   x_j = min(z_j, a[i][j])
    #   y_j = z_j - x_j
    #   ост_j = min(s_j - z_j, b[i][j])
    #   s'_j = ост_j + x_{j+1} + y_{j-1}

    # Обновляем s = s' и считаем sum s для ответа.

    # Для каждого k от 1 до m выводим sum s после k дней.

    res = []
    cur_s = s[:]
    for day in range(m):
        z = [0]*n
        for j in range(n):
            sj = cur_s[j]
            maxz = min(sj, a[day][j] + c[day][j])
            threshold = sj - b[day][j]
            if threshold <= 0:
                z[j] = maxz
            else:
                if maxz < threshold:
                    z[j] = maxz
                else:
                    z[j] = threshold
        x = [0]*n
        y = [0]*n
        for j in range(n):
            x[j] = min(z[j], a[day][j])
            y[j] = z[j] - x[j]  # гарантированно ≤ c[day][j]
        ost = [0]*n
        for j in range(n):
            ost[j] = min(cur_s[j] - z[j], b[day][j])
        s_new = [0]*n
        for j in range(n):
            # индексы по модулю n
            jp = (j + 1) % n
            jm = (j - 1) % n
            s_new[j] = ost[j] + x[jp] + y[jm]
        cur_s = s_new
        res.append(str(sum(cur_s)))
    print('\n'.join(res))