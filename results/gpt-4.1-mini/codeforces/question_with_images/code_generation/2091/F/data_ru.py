import sys
import math
input = sys.stdin.readline

MOD = 998244353

# Для каждого уровня нам нужно рассчитать количество способов выбрать 1 или 2 зацепки,
# при этом переходы между уровнями должны быть возможны (расстояние <= d).
# Трасса - последовательность уровней, на каждом уровне 1 или 2 зацепки,
# первая на нижнем уровне, последняя на верхнем,
# переходы между уровнями по условию.

# Идея решения:
# 1) Для каждого уровня собрать список зацепок (их позиции).
# 2) Для каждого уровня сформировать все варианты выбора зацепок: 
#    - одиночные зацепки (одна точка)
#    - пары зацепок (две точки)
# 3) Для каждого варианта на уровне i будем хранить количество способов дойти до него.
# 4) Для перехода с уровня i+1 на уровень i (движение вверх):
#    - перебираем все варианты на уровне i+1 и i
#    - проверяем, можно ли перейти из варианта i+1 в вариант i
#      (все точки варианта i должны быть достижимы с точек варианта i+1)
#      (т.е. для каждой точки варианта i существует точка варианта i+1, расстояние <= d)
# 5) Суммируем количество способов.
# 6) Ответ - сумма способов для всех вариантов на верхнем уровне (i=0).

# Оптимизации:
# - n*m суммарно до 4*10^6, но t до 1000, значит средний n*m ~ 4000.
# - На каждом уровне m может быть до 2000, но зацепок может быть меньше.
# - Кол-во вариантов на уровне: одиночные + пары.
#   Максимум ~ (k + k*(k-1)/2), где k - число зацепок на уровне.
#   При k=50 это ~1275 вариантов, что приемлемо.
# - Для проверки перехода между вариантами используем предвычисление расстояний между точками уровней i и i+1.
# - Для каждого варианта i проверяем достижимость каждой точки из варианта i+1.
# - Используем битовые маски или списки для ускорения.

# Реализация:

def main():
    t = int(input())
    for _ in range(t):
        n, m, d = map(int, input().split())
        levels = [input().strip() for __ in range(n)]

        # Собираем зацепки по уровням
        # Уровни идут сверху вниз, индексы 0..n-1
        # Нам удобнее работать снизу вверх, т.к. трасса снижается с n-1 до 0
        holds = []
        for i in range(n):
            row = []
            for j in range(m):
                if levels[i][j] == 'X':
                    row.append(j)
            holds.append(row)

        # Проверка: если на нижнем уровне (n-1) нет зацепок, ответ 0
        if not holds[-1]:
            print(0)
            continue

        # Для каждого уровня сформируем варианты:
        # варианты - список кортежей с индексами зацепок на уровне
        # например (p,), (p,q)
        variants = []
        for row in holds:
            v = []
            k = len(row)
            # одиночные
            for i1 in range(k):
                v.append( (i1,) )
            # пары
            for i1 in range(k):
                for i2 in range(i1+1, k):
                    v.append( (i1,i2) )
            variants.append(v)

        # dp[i][v_idx] - количество способов дойти до варианта v_idx на уровне i
        # i от n-1 (низ) до 0 (верх)
        # Инициализация dp для нижнего уровня:
        dp = [dict() for __ in range(n)]
        for idx in range(len(variants[-1])):
            dp[-1][idx] = 1

        # Предварительно вычислим расстояния между точками уровней i и i-1
        # Для перехода с i+1 на i (снизу вверх)
        # dist[i][p][q] - расстояние между p-й зацепкой уровня i и q-й зацепкой уровня i+1
        # Чтобы не хранить все, будем вычислять на лету.

        # Для ускорения проверок создадим для каждого варианта на уровне i+1 множество точек,
        # для каждого варианта на уровне i проверим, что для каждой точки варианта i
        # существует точка варианта i+1 с расстоянием <= d.

        # Перебираем уровни снизу вверх (i от n-2 до 0)
        for i in range(n-2, -1, -1):
            dp_i = {}
            row_i = holds[i]
            row_i1 = holds[i+1]
            v_i = variants[i]
            v_i1 = variants[i+1]

            # Для ускорения: для каждой точка уровня i, найдем индексы точек уровня i+1,
            # до которых можно дотянуться (расстояние <= d)
            # reachable[i][p] = set of q in level i+1 reachable from p in level i
            reachable = []
            for p in range(len(row_i)):
                reachable_p = []
                x1 = i
                y1 = row_i[p]
                for q in range(len(row_i1)):
                    x2 = i+1
                    y2 = row_i1[q]
                    dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
                    if dist <= d:
                        reachable_p.append(q)
                reachable.append(set(reachable_p))

            # Для каждого варианта на уровне i+1 подготовим множество точек
            # для быстрого доступа
            # v_i1[q] - индексы точек уровня i+1
            # dp[i+1][q] - количество способов
            # Для каждого вариант i+1 - множество точек
            v_i1_points = [set(v_i1[idx]) for idx in range(len(v_i1))]

            # Для каждого вариант i+1 сохраним dp[i+1][idx]
            dp_i1 = dp[i+1]

            # Для каждого вариант i проверим, можно ли перейти из какого-то вариант i+1
            # в вариант i
            # Условие перехода:
            # Для каждой точки p в варианте i существует точка q в варианте i+1,
            # такая что q reachable из p (расстояние <= d)
            # и q принадлежит варианту i+1

            # Чтобы ускорить, для каждого вариант i+1 подготовим множество точек
            # Для вариант i проверим для каждой p, что reachable[p] пересекается с точками вариант i+1

            # Для каждого вариант i
            for idx_i, pts_i in enumerate(v_i):
                # pts_i - tuple индексов точек уровня i
                # Проверяем условие:
                # для каждого p in pts_i:
                #   reachable[p] ∩ pts_i1 != empty
                # где pts_i1 - точки вариант i+1

                # Перебираем вариант i+1
                ways = 0
                for idx_i1, pts_i1 in enumerate(v_i1):
                    # Проверяем для все p in pts_i:
                    # reachable[p] ∩ pts_i1 != empty
                    ok = True
                    for p in pts_i:
                        if reachable[p].isdisjoint(pts_i1):
                            ok = False
                            break
                    if ok:
                        ways += dp_i1.get(idx_i1, 0)
                if ways:
                    dp_i[idx_i] = ways % MOD
            dp[i] = dp_i

            # Если на уровне i нет вариантов с путями, можно сразу прервать
            if not dp[i]:
                break

        # Ответ - сумма dp[0][*]
        ans = sum(dp[0].values()) % MOD if dp[0] else 0
        print(ans)

if __name__ == "__main__":
    main()