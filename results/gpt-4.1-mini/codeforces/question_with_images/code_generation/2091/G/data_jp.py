t = int(input())
for _ in range(t):
    s, k = map(int, input().split())
    # 方向転換はパワーを1減らす（ただし1以下にはならない）
    # 方向転換は連続して2回できず、最初は方向転換できない
    # 方向転換なしで到達できるならパワーはkのまま
    # 方向転換を1回するとパワーはmax(k-1,1)
    # 方向転換を2回するとパワーはmax(k-2,1) ... ただし連続2回転換不可なので2回転換は可能
    # しかし、方向転換はパワーを減らすので、できるだけ少なくしたい
    # 方向転換なしで到達できるかはkでsを進めるかどうか
    # 方向転換なしで到達できるのはk >= s
    # しかし制約でk <= sなのでk == sならパワーはkのまま
    # 方向転換なしで到達できるのはk == sのみ
    # それ以外は方向転換が必要
    # 方向転換1回で到達できるか？
    # 方向転換1回の移動距離は x - (x-1) + (x-1) = x + (x-1) = 2x -1
    # ただしxはパワー減少前の値
    # 方向転換1回で到達できる距離は 2k -1
    # 方向転換2回で到達できる距離は 3k -3 (k + (k-1) + (k-2))
    # 方向転換n回で到達できる距離は (n+1)*k - n*(n+1)//2
    # ただしパワーは1以下にならないので減少はk-1回まで
    # しかしk <= 1000なのでn <= k-1
    # 方向転換の回数nを増やして到達可能か判定し、最大のパワーを求める
    # パワーは k - n (ただし1未満にはならない)
    # 方向転換は0回からk-1回まで試す
    
    max_power = 1
    for n in range(k):
        # 到達距離 = (n+1)*k - n*(n+1)//2
        dist = (n+1)*k - n*(n+1)//2
        if dist >= s:
            power = k - n
            if power < 1:
                power = 1
            if power > max_power:
                max_power = power
    print(max_power)