t = int(input())
for _ in range(t):
    s, k = map(int, input().split())
    # Максимальное количество разворотов n:
    # После n разворотов сила уменьшится на n (если k-n >= 1)
    # Сила после n разворотов: max(k - n, 1)
    # Нужно проверить, можно ли пройти s с n разворотами.
    # При n разворотах путь разбивается на n+1 отрезок.
    # Каждый отрезок длина не более текущей силы (которая уменьшается после каждого разворота).
    # Суммарно длина пути:
    # sum_{i=0}^{n} max(k - i, 1) >= s
    # где max(k - i, 1) - длина i-го отрезка (i-й после i-го разворота)
    # Но сила не может упасть ниже 1, значит после k-1 разворота сила будет 1.
    # Значит для i >= k-1 длина отрезка = 1.
    #
    # Формула суммы:
    # Если n < k-1:
    #   sum = (k + (k - n)) * (n + 1) / 2
    # Если n >= k-1:
    #   sum = sum_{i=0}^{k-2} (k - i) + (n + 1 - (k - 1)) * 1
    #   = (k + 1) * (k - 1) / 2 + (n + 1 - (k - 1))
    #
    # Нужно найти максимальное n, при котором sum >= s.
    #
    # Ограничения: k <= 1000, s <= 10^9, t <= 100, сумма k по тестам <= 2000
    # Можно перебрать n от 0 до s (но s может быть до 10^9, перебор невозможен)
    # Поэтому бинарный поиск по n от 0 до s.
    
    def can(n):
        if n < k - 1:
            # арифметическая прогрессия длиной n+1, первый член k, последний k - n
            length = (k + (k - n)) * (n + 1) // 2
        else:
            # сначала (k-1) членов от k до 1
            length = (k + 1) * (k - 1) // 2
            length += (n + 1 - (k - 1))  # оставшиеся отрезки длины 1
        return length >= s

    left, right = 0, s  # n - количество разворотов
    ans = 0
    while left <= right:
        mid = (left + right) // 2
        if can(mid):
            ans = mid
            right = mid - 1
        else:
            left = mid + 1

    # Сила после ans разворотов:
    res = k - ans
    if res < 1:
        res = 1
    print(res)