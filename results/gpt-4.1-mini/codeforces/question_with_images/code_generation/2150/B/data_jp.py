import sys
input = sys.stdin.readline
MOD = 998244353

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    # 条件の整理:
    # 1) 各行kにa_k個の黒セル
    # 2) 各kについて max(x_i, y_i) = k の黒セルが1つだけ
    # 3) 各kについて max(x_i, n+1 - y_i) = k の黒セルが1つだけ

    # 2),3)の条件から、max(x,y) = k の黒セルが1つ、max(x, n+1 - y) = k の黒セルが1つ
    # つまり、kごとに2つの特別な黒セルがある（ただし重複する場合もある）

    # これらの条件は、黒セルの配置が「max(x,y) = k」と「max(x, n+1 - y) = k」の
    # それぞれ1つずつ存在することを意味し、かつ行ごとの黒セル数がa_kであること。

    # 重要な観察:
    # max(x,y) = k のセルは、x <= k, y <= k かつ max(x,y) = k なので、
    # そのセルは (k, y) または (x, k) の形で、x,y <= k。
    # 同様に max(x, n+1 - y) = k のセルは、x <= k, n+1 - y <= k なので y >= n+1 - k。

    # これらの条件を満たすセルは、kごとに1つずつ存在し、かつ行ごとの黒セル数がa_k。

    # ここで、a_kは行kの黒セル数。
    # max(x,y) = k の黒セルは行kか列kにある。
    # max(x, n+1 - y) = k の黒セルも同様に行kか列kにある。

    # これらの条件を満たすグリッドの数を数える問題。

    # 解法のヒント:
    # 1) max(x,y) = k の黒セルは、行kか列kにある。
    # 2) max(x, n+1 - y) = k の黒セルは、行kか列kにある。
    # 3) それぞれのkで1つずつ黒セルがあるので、合計2n個の黒セルがあるが、
    #    重複する場合は1つ減る。

    # 4) 行kの黒セル数はa_k。
    # 5) 2)と3)の条件から、行kの黒セル数は少なくとも1か2か0かで制約される。

    # ここで、a_kの値とmax条件の黒セルの配置の関係を考える。

    # 重要なポイント:
    # max(x,y) = k の黒セルは行kか列kにある。
    # max(x, n+1 - y) = k の黒セルも行kか列kにある。

    # つまり、各kに対して2つの黒セルがあり、それらは行kか列kにある。

    # 行kの黒セル数a_kは、これら2つの黒セルのうち行kにあるものの数 + 
    # それ以外の黒セル（max条件の黒セル以外）で埋める必要がある。

    # しかし、max条件の黒セルは必ず存在し、かつそれ以外の黒セルは存在しない（問題文より）。

    # よって、a_kは0,1,2のいずれかでなければならない。
    # 0なら行kに黒セルなし → max条件の2つの黒セルは両方とも列kにある。
    # 1なら行kに黒セル1つ → max条件の2つの黒セルのうち1つは行k、もう1つは列kにある。
    # 2なら行kに黒セル2つ → max条件の2つの黒セルは両方とも行kにある。

    # これ以外のa_kは不可能。

    # したがって、a_k ∈ {0,1,2} でなければ解は0。

    # さらに、max条件の黒セルは2n個あるが、重複するセルがある場合は1つ減る。

    # 重複するセルは、max(x,y) = k と max(x, n+1 - y) = k の黒セルが同じセルの場合。

    # そのセルは (k, k) か (k, n+1 - k) のどちらか。

    # しかし、max(x,y) = k の黒セルは (k, y) または (x, k) で、
    # max(x, n+1 - y) = k の黒セルは (k, y) または (x, n+1 - k) である。

    # 重複するのは (k, k) の場合のみ。

    # つまり、2つの黒セルが同じセルになるのは (k, k) の場合。

    # この場合、a_k = 2 なら2つの黒セルは両方行kにある → 両方同じセルは無理 → 重複なし。
    # a_k = 1 なら1つは行k、もう1つは列k → 重複なし。
    # a_k = 0 なら両方列k → 重複なし。

    # よって重複は起きない。

    # したがって、2n個の黒セルはすべて異なる。

    # ここで、a_kの値によってmax条件の黒セルの配置は決まる。

    # a_k = 0 → 両方列kにある → max(x,y)=k の黒セルは列kに、max(x,n+1-y)=k の黒セルも列kにある。
    # a_k = 2 → 両方行kにある → max(x,y)=k の黒セルは行kに、max(x,n+1-y)=k の黒セルも行kにある。
    # a_k = 1 → 1つは行k、1つは列k → どちらが行でどちらが列かは選べる → 2通り。

    # つまり、a_k=1 のときだけ選択肢が2通りある。

    # よって、解は a_k=1 の個数の2のべき乗。

    # ただし、a_kが0,1,2以外なら0。

    # まとめ:
    # - a_k ∈ {0,1,2} でなければ0
    # - 答え = 2^(# of a_k=1) mod 998244353

    # 実装:

    cnt_1 = 0
    possible = True
    for x in a:
        if x not in (0,1,2):
            possible = False
            break
        if x == 1:
            cnt_1 += 1

    if not possible:
        print(0)
        continue

    # 2^(cnt_1) mod MOD
    ans = pow(2, cnt_1, MOD)
    print(ans)