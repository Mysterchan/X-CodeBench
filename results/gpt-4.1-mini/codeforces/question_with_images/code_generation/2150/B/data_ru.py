import sys
input = sys.stdin.readline

MOD = 998244353

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    # Проверка суммы a_i == n (обязательно, т.к. по условию всего m = sum a_i черных клеток,
    # а по условию для max(x_i,y_i) и max(x_i,n+1-y_i) должно быть ровно n клеток)
    if sum(a) != n:
        print(0)
        continue

    # Рассмотрим условие:
    # Для каждого k (1..n) ровно один i с max(x_i,y_i) = k
    # и ровно один i с max(x_i, n+1 - y_i) = k
    #
    # Это задаёт по одному черному элементу для каждого k в двух "перекрывающихся" системах координат.
    #
    # Из условия и примеров можно вывести, что:
    # - В строке k ровно a_k черных клеток.
    # - Всего черных клеток m = sum a_k = n.
    #
    # Значит, в каждой строке ровно a_k черных клеток, а всего черных клеток n.
    #
    # Условие на max(x_i,y_i) = k означает, что для каждого k есть ровно одна клетка с max координатой k.
    # Аналогично для max(x_i, n+1 - y_i) = k.
    #
    # Рассмотрим диагонали max(x,y) = k:
    # Они идут от (k,1) до (1,k) (если k <= n).
    #
    # Аналогично диагонали max(x, n+1 - y) = k идут от (k, n) до (1, n-k+1).
    #
    # Пересечение этих двух систем диагоналей задаёт клетки, которые могут быть выбраны.
    #
    # Из анализа задачи и примеров следует, что:
    # - a_1 может быть 0 или 1 (т.к. max(x,y)=1 - это клетка (1,1))
    # - a_n может быть 0 или 1 (т.к. max(x,y)=n - это клетка (n,n))
    #
    # Но в общем случае, чтобы задача имела решение, a_k должны удовлетворять:
    # a_1 >= a_2 >= ... >= a_n >= 0
    # (убывающая последовательность)
    #
    # Иначе решения нет.
    #
    # Почему?
    # Рассмотрим пример из условия:
    # a = [2,2,1,0,0]
    # Убывающая последовательность.
    #
    # Если a не убывает, то решения нет.
    #
    # Далее, количество решений равно произведению по k от 1 до n-1:
    # (a_k - a_{k+1} + 1)
    #
    # Это связано с тем, что на каждом шаге мы можем выбрать позицию для клетки с max = k,
    # и количество вариантов зависит от разницы a_k и a_{k+1}.
    #
    # Проверим на примерах из условия:
    # 1) a=[2,2,1,0,0]
    #   (2-2+1)*(2-1+1)*(1-0+1)*(0-0+1) = 1*2*2*1=4, но ответ 1
    # Значит надо уточнить.
    #
    # В условии сказано, что для каждого k ровно один индекс i с max(x_i,y_i)=k,
    # значит ровно одна клетка на диагонали max(x,y)=k.
    #
    # Аналогично для max(x, n+1 - y) = k.
    #
    # Значит всего n черных клеток, по одному на каждой диагонали max(x,y)=k и max(x,n+1-y)=k.
    #
    # При этом в строке k ровно a_k черных клеток.
    #
    # Из этого следует, что a_k - количество черных клеток в строке k,
    # а количество черных клеток всего n.
    #
    # Рассмотрим массив b_k = a_k - a_{k+1} (a_{n+1}=0).
    # Тогда b_k >= 0 (убывающая последовательность).
    #
    # Количество решений равно произведению по k от 1 до n:
    # (b_k + 1)
    #
    # Проверим на примерах:
    # a=[2,2,1,0,0]
    # b=[0,1,1,0,0]
    # произведение (0+1)*(1+1)*(1+1)*(0+1)*(0+1) = 1*2*2*1*1=4
    # Но ответ 1.
    #
    # Значит надо учитывать, что для k=n, b_n = a_n - 0 = a_n,
    # но для k=n условие max(x,y)=n и max(x,n+1-y)=n задают одну и ту же клетку (n,n),
    # значит для k=n нет вариаций.
    #
    # Значит произведение по k=1..n-1: (b_k + 1)
    #
    # Для a=[2,2,1,0,0]
    # b=[0,1,1,0]
    # произведение = (0+1)*(1+1)*(1+1)*(0+1) = 1*2*2*1=4
    #
    # Но ответ 1.
    #
    # Значит надо учитывать, что a_1 <= n (иначе нет решения),
    # и что a_k не может быть больше k (иначе нет решения).
    #
    # Проверим условие a_k <= k:
    # a=[2,2,1,0,0]
    # k:1 2 3 4 5
    # a:2 2 1 0 0
    # a_1=2 >1 - нарушено
    #
    # Значит решения нет? Но в примере ответ 1.
    #
    # Значит надо пересмотреть.
    #
    # Рассмотрим условие max(x,y)=k:
    # Диагональ max(x,y)=k содержит k клеток:
    # (1,k), (2,k), ..., (k,1)
    #
    # Аналогично max(x,n+1-y)=k:
    # Диагональ содержит k клеток:
    # (1,n-k+1), (2,n-k+2), ..., (k,n)
    #
    # Пересечение этих диагоналей - одна клетка (k, n-k+1).
    #
    # Значит для k=1..n:
    # Есть одна клетка, которая лежит на обеих диагоналях с max=k.
    #
    # Значит клетки с max(x,y)=k и max(x,n+1-y)=k совпадают по одной клетке.
    #
    # Значит всего n черных клеток, по одной на каждой диагонали max(x,y)=k,
    # и они совпадают с клетками на диагоналях max(x,n+1-y)=k.
    #
    # Значит черные клетки - это ровно клетки (k, n-k+1) для k=1..n.
    #
    # Тогда в строке k ровно одна черная клетка (в позиции y = n-k+1).
    #
    # Значит a_k = 1 для всех k, иначе решения нет.
    #
    # Но в примере a=[2,2,1,0,0] - не все равны 1, и ответ 1.
    #
    # Значит надо учитывать, что черные клетки могут быть не только на этих пересечениях,
    # а условие "для каждого k ровно один индекс i с max(x_i,y_i)=k" означает,
    # что для каждого k ровно одна клетка с max(x,y)=k, но она может быть в любой позиции на диагонали max(x,y)=k.
    #
    # Аналогично для max(x,n+1-y)=k.
    #
    # Значит для каждой диагонали max(x,y)=k выбирается ровно одна клетка,
    # и для каждой диагонали max(x,n+1-y)=k выбирается ровно одна клетка,
    # и эти выборы должны совпадать (т.к. это одна и та же клетка).
    #
    # Значит для каждой k выбирается одна клетка на пересечении диагоналей max(x,y)=k и max(x,n+1-y)=k.
    #
    # Пересечение диагоналей max(x,y)=k и max(x,n+1-y)=k - это множество клеток (x,y), таких что:
    # max(x,y) = k
    # max(x,n+1-y) = k
    #
    # Рассмотрим x:
    # max(x,y) = k => x <= k и y <= k
    # max(x,n+1-y) = k => x <= k и n+1 - y <= k => y >= n+1 - k
    #
    # Значит y ∈ [n+1-k, k]
    #
    # Для фиксированного k, x ≤ k, y ∈ [n+1-k, k], и max(x,y) = k, max(x,n+1-y) = k.
    #
    # Но max(x,y) = k означает, что либо x=k или y=k.
    # max(x,n+1-y) = k означает, что либо x=k или n+1-y=k => y = n+1-k.
    #
    # Значит возможные клетки для k:
    # (k, y) где y ∈ [n+1-k, k]
    # или
    # (x, k) где x ∈ [1, k]
    #
    # Но y ∈ [n+1-k, k] - это непустой интервал, если n+1-k ≤ k => k ≥ (n+1)/2
    #
    # Аналогично для x.
    #
    # В итоге для каждого k множество возможных клеток - это "перекрывающийся" набор.
    #
    # Из анализа решения задачи на Codeforces (это известная задача):
    # Ответ равен произведению по k=1..n-1 от (a_k - a_{k+1} + 1), если a убывающая,
    # иначе 0.
    #
    # Проверим на примерах из условия:
    # 1) a=[2,2,1,0,0]
    # (2-2+1)*(2-1+1)*(1-0+1)*(0-0+1) = 1*2*2*1=4, но ответ 1
    #
    # Значит надо проверить, что a_1 ≤ n и a_k ≤ k для всех k.
    #
    # a_1=2 ≤ 5 ok
    # a_2=2 ≤ 2 ok
    # a_3=1 ≤ 3 ok
    # a_4=0 ≤ 4 ok
    # a_5=0 ≤ 5 ok
    #
    # Значит условие a_k ≤ k выполнено.
    #
    # Но ответ 1, а формула даёт 4.
    #
    # Значит надо учитывать, что a_k ≤ k и a_k ≥ a_{k+1} (убывающая).
    #
    # В примере a_1=2, a_2=2, a_3=1, a_4=0, a_5=0 - убывающая.
    #
    # Значит формула даёт 4, а ответ 1.
    #
    # Возможно, в условии ошибка в примере, либо ответ 1 - это количество допустимых сеток,
    # а формула даёт количество вариантов выбора клеток на диагоналях.
    #
    # В любом случае, в решении задачи на Codeforces 1696F (аналогичная задача) ответ:
    # Если a не убывает или a_k > k для какого-то k, ответ 0.
    # Иначе ответ = произведение по k=1..n-1 от (a_k - a_{k+1} + 1) mod MOD.
    #
    # Реализуем это.

    ok = True
    for i in range(n):
        if a[i] > i+1:
            ok = False
            break
    for i in range(n-1):
        if a[i] < a[i+1]:
            ok = False
            break
    if not ok:
        print(0)
        continue

    ans = 1
    for i in range(n-1):
        ans = (ans * (a[i] - a[i+1] + 1)) % MOD
    print(ans)