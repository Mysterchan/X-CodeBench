import sys
input = sys.stdin.readline
MOD = 998244353

# Предварительно вычислим факториалы и обратные факториалы для вычисления факториала по модулю
MAX = 2 * 10**5 + 10
fact = [1] * (MAX)
for i in range(2, MAX):
    fact[i] = fact[i-1] * i % MOD

def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        p = list(map(int, input().split()))
        c = list(map(int, input().split()))

        # После гравитационной сортировки песок в столбцах "упадет" вниз.
        # Итоговая форма - "ступенчатая" диагональ, где в j-м столбце ровно j блоков.
        # В итоге в j-м столбце будут блоки из тех строк i, для которых p[i] >= j.
        # Значит, для каждого j (1..n) множество строк i с p[i]>=j формирует столбец j.
        # После гравитации цвет в столбце j - это цвета c[i] для i с p[i]>=j,
        # упавшие вниз, то есть цвета упорядочены по возрастанию i (т.к. блоки падают вниз, порядок по строкам сохраняется).
        #
        # Итог: для каждого j цвета в столбце j - это c[i] для i с p[i]>=j, упорядоченные по i.
        #
        # Задача: по конечному расположению песка (т.е. по массиву c и p после гравитации)
        # найти количество пар (p', c'), которые дают тот же результат.
        #
        # Анализ:
        # - p' - перестановка
        # - p' определяет, сколько блоков в каждой строке (p'_i)
        # - после гравитации в j-м столбце идут блоки из строк i с p'_i >= j
        #
        # Рассмотрим p отсортированную по возрастанию p_i:
        # p отсортирована: p_sorted = [p_(i1), p_(i2), ..., p_(in)] = [1,2,...,n] (т.к. перестановка)
        # Тогда в j-м столбце блоки из строк с p_i >= j - это строки с p_i >= j, то есть строки с p_i = j, j+1, ..., n.
        #
        # Значит, столбец j содержит блоки из строк с p_i >= j.
        #
        # После гравитации цвета в столбце j - это c_i для i с p_i >= j, упорядоченные по i.
        #
        # Чтобы получить тот же результат, нужно, чтобы для каждого j множество c_i для i с p'_i >= j совпадало с исходным.
        #
        # Рассмотрим разбиение по p_i:
        # p_i принимает значения от 1 до n, все уникальны.
        #
        # Для j=1: строки с p_i >= 1 - все строки, цвета c_i для всех i.
        # Для j=2: строки с p_i >= 2 - все строки, кроме той, у которой p_i=1.
        # Для j=3: все, кроме p_i=1 и p_i=2, и т.д.
        #
        # Значит, цвета c_i для i с p_i >= j - это suffix множества c_i, упорядоченного по p_i.
        #
        # Иными словами, если отсортировать строки по p_i, то suffix цвета должны совпадать.
        #
        # Теперь, чтобы найти количество пар (p', c'), дающих тот же результат:
        # - p' - перестановка
        # - c' - массив цветов
        # - после гравитации цвета в столбцах совпадают с исходными
        #
        # Рассмотрим разбиение по p_i:
        # p_i - перестановка от 1 до n
        # c_i - цвета
        #
        # После гравитации цвета в столбце j - это c_i для i с p_i >= j, упорядоченные по i.
        #
        # Значит, для каждого j suffix c_i (от позиции, соответствующей p_i=j) фиксирован.
        #
        # Следовательно, если мы отсортируем строки по p_i, то c_i образует массив, у которого suffixы фиксированы.
        #
        # Теперь, чтобы получить тот же результат, p' должен быть перестановкой, а c' - массивом цветов,
        # такой что для каждого j suffix c' совпадает с исходным suffix c.
        #
        # Это возможно, если c' совпадает с c, но строки могут быть переставлены внутри групп с одинаковым p_i.
        #
        # Но p_i уникальны, значит группы по p_i - это отдельные элементы.
        #
        # Значит, единственный способ получить тот же результат - это переставить строки так,
        # чтобы suffixы c' совпадали с исходными suffixами c.
        #
        # Рассмотрим разбиение p по возрастанию:
        # p отсортирована: p_sorted = [p_i1, p_i2, ..., p_in] = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть перестановкой,
        # а c' - массив цветов, такой что suffix c' совпадает с suffix c_sorted.
        #
        # Это возможно, если c' совпадает с c_sorted.
        #
        # Значит, p' должен быть такой, что c' отсортирован по p' так же, как c_sorted по p.
        #
        # Иными словами, p' и c' должны быть такими, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted на блоки по возрастанию p_i:
        # p_i уникальны, значит блоки по p_i - это отдельные элементы.
        #
        # Значит, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Теперь рассмотрим разбиение p по возрастанию p_i:
        # p_i уникальны, значит p_sorted = [1,2,...,n]
        #
        # Значит, p' - любая перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Рассмотрим разбиение p_sorted по возрастанию p_i:
        # p_sorted = [1,2,...,n]
        # c_sorted = c отсортированное по p_i
        #
        # Теперь, чтобы получить тот же результат, p' должен быть такой, что c' отсортирован по p' совпадает с c_sorted.
        #
        # Значит, p' - перестановка, а c' - массив цветов,
        # такой что c' отсортирован по p' совпадает с c_sorted.
        #
        # Теперь, чтобы посчитать количество таких пар (p', c'), нужно посчитать количество перестановок p',
        # для которых c' отсортирован по p' совпадает с c_sorted.
        #
        # Это возможно, если c_sorted разбивается на блоки одинаковых цветов.
        #
        # В каждом блоке одинаковых цветов можно переставлять p' внутри этого блока,
        # не меняя итогового результата.
        #
        # Значит, ответ - произведение факториалов длин блоков одинаковых цветов в c_sorted.
        #
        # Итого алгоритм:
        # 1) Отсортировать индексы по p_i
        # 2) Получить c_sorted = c по отсортированным индексам
        # 3) Разбить c_sorted на блоки одинаковых цветов
        # 4) Ответ = произведение факториалов длин блоков по модулю

        # Сортируем индексы по p_i
        order = sorted(range(n), key=lambda x: p[x])
        c_sorted = [c[i] for i in order]

        ans = 1
        length = 1
        for i in range(1, n):
            if c_sorted[i] == c_sorted[i-1]:
                length += 1
            else:
                ans = (ans * fact[length]) % MOD
                length = 1
        ans = (ans * fact[length]) % MOD

        print(ans % MOD)

if __name__ == "__main__":
    main()