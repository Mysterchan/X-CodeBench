import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    
    # После всех операций итоговый массив неубывающий.
    # Рассмотрим процесс:
    # При "уронении" башни i, a[i] сбрасывается в 0,
    # а следующие a[i] башен увеличиваются на 1.
    #
    # Можно представить итоговую высоту башни i как:
    # h[i] = sum всех прибавок от предыдущих "уронений" + 0 (т.к. башня i сброшена)
    #
    # При этом прибавки идут от башен с индексами < i, и каждая башня добавляет 1 к следующим a[i] башням.
    #
    # Чтобы итоговый массив был неубывающим, h[i] >= h[i-1].
    #
    # Рассмотрим, как максимизировать MEX итогового массива.
    #
    # Идея решения:
    # - Изначально все башни имеют высоты a[i].
    # - При "уронении" башни i, мы добавляем 1 к следующим a[i] башням.
    # - Можно представить это как добавление +1 к диапазону [i+1, i+a[i]].
    #
    # Итоговая высота башни i:
    # h[i] = sum всех прибавок, которые попали на i (т.е. количество башен j < i, для которых i <= j + a[j])
    #
    # Но при этом башня i сбрасывается в 0, так что h[i] = количество прибавок на i.
    #
    # Чтобы итоговый массив был неубывающим, h[i] >= h[i-1].
    #
    # Рассмотрим, что h[i] - h[i-1] >= 0.
    #
    # Можно посчитать h[i] по формуле:
    # h[i] = количество j < i, таких что i <= j + a[j]
    #
    # Для каждого i, h[i] = количество j < i, для которых j + a[j] >= i.
    #
    # Значит, h[i] = количество j < i, у которых j + a[j] >= i.
    #
    # h[0] = 0 (нет j < 0)
    #
    # Чтобы h[i] >= h[i-1], нужно, чтобы количество таких j для i >= количества таких j для i-1.
    #
    # Рассмотрим массив b[i] = i + a[i].
    #
    # Тогда h[i] = количество j < i, для которых b[j] >= i.
    #
    # h[i] = количество j < i, b[j] >= i.
    #
    # h[i-1] = количество j < i-1, b[j] >= i-1.
    #
    # Чтобы h[i] >= h[i-1], нужно, чтобы при переходе от i-1 к i количество таких j не уменьшалось.
    #
    # Это возможно, если b[i-1] >= i, т.е. i-1 + a[i-1] >= i => a[i-1] >= 1.
    #
    # Но это не всегда так.
    #
    # Однако, мы можем упорядочить "уронения" башен в любом порядке.
    #
    # Рассмотрим упрощённый подход:
    #
    # При "уронении" башни i, мы добавляем 1 к следующим a[i] башням.
    # Если a[i] >= n - i - 1, то прибавка дойдёт до конца массива.
    #
    # Рассмотрим массив d длины n+1, где будем хранить разности прибавок:
    # При "уронении" башни i:
    # d[i+1] += 1
    # d[i+1 + a[i]] -= 1 (если i+1 + a[i] <= n)
    #
    # После всех "уронений" (каждой башни ровно один раз), итоговые прибавки:
    # prefix sums по d дают прибавки к каждой башне.
    #
    # Итоговая высота башни i = прибавки[i] (т.к. башня i сброшена в 0)
    #
    # Чтобы итоговый массив был неубывающим, прибавки должны быть неубывающей последовательностью.
    #
    # Задача сводится к тому, чтобы упорядочить "уронения" башен так, чтобы итоговые прибавки были неубывающими.
    #
    # Но порядок "уронений" влияет на распределение прибавок.
    #
    # Рассмотрим жадный алгоритм:
    # - Отсортируем башни по a[i].
    # - Уроняем башни с меньшим a[i] раньше, чтобы прибавки распределялись равномерно.
    #
    # Но это сложно реализовать эффективно.
    #
    # Рассмотрим другой подход:
    #
    # При любом порядке итоговые прибавки к башне i равны количеству башен j, для которых i ∈ (j+1, j+a[j]].
    #
    # То есть, прибавка к башне i = количество j, таких что j < i ≤ j + a[j].
    #
    # Значит, итоговая высота башни i = количество j < i, для которых i ≤ j + a[j].
    #
    # Чтобы итоговый массив был неубывающим, h[i] >= h[i-1].
    #
    # Рассмотрим h[i] - h[i-1]:
    # h[i] - h[i-1] = количество j < i, b[j] >= i - количество j < i-1, b[j] >= i-1
    #
    # = (если b[i-1] >= i) + (количество j < i-1, b[j] >= i) - (количество j < i-1, b[j] >= i-1)
    #
    # Но b[j] >= i => b[j] >= i-1, значит
    # (количество j < i-1, b[j] >= i) ≤ (количество j < i-1, b[j] >= i-1)
    #
    # Значит h[i] - h[i-1] ≤ 1, и оно равно 1, если b[i-1] >= i.
    #
    # Значит h[i] - h[i-1] = 1, если b[i-1] >= i, иначе 0.
    #
    # Тогда h[i] = количество k < i, для которых b[k] >= k+1.
    #
    # Но b[k] = k + a[k], значит b[k] >= k+1 <=> a[k] >= 1.
    #
    # Значит h[i] = количество k < i, у которых a[k] >= 1.
    #
    # Итоговый массив h[i] = количество башен с a[k] >= 1 среди первых i башен.
    #
    # Чтобы h[i] неубывал, нужно, чтобы количество башен с a[k] >= 1 не уменьшалось при увеличении i.
    #
    # Это всегда верно.
    #
    # Значит итоговый массив h[i] — это префиксные суммы количества башен с a[k] >= 1.
    #
    # Тогда максимальный MEX — это минимальное i, для которого h[i] != i.
    #
    # Но h[i] ≤ i всегда, т.к. h[i] — количество башен с a[k] >= 1 среди первых i.
    #
    # Рассмотрим пример:
    # Если все башни имеют a[i] >= 1, то h[i] = i, значит итоговый массив — [0,1,2,...,n-1], MEX = n.
    #
    # Если есть башни с a[i] = 0, то h[i] < i для некоторых i.
    #
    # Но в условии сказано, что каждая башня уронена ровно один раз.
    #
    # Рассмотрим другой способ:
    #
    # При "уронении" башни i, мы добавляем 1 к следующим a[i] башням.
    # Если a[i] >= n - i - 1, то прибавка дойдёт до конца массива.
    #
    # Рассмотрим массив diff длины n+1, изначально нулевой.
    # Для каждой башни i:
    # diff[i+1] += 1
    # if i+1 + a[i] <= n:
    #   diff[i+1 + a[i]] -= 1
    #
    # После всех операций prefix sum по diff даст итоговые прибавки.
    #
    # Чтобы итоговый массив был неубывающим, prefix sums должны быть неубывающей последовательностью.
    #
    # Но мы можем упорядочить "уронения" башен в любом порядке.
    #
    # Рассмотрим жадный алгоритм:
    # - Отсортируем башни по a[i].
    # - Уроняем башни с меньшим a[i] раньше.
    #
    # Тогда diff будет иметь вид:
    # Для башни с a[i], diff увеличится на 1 в позиции i+1 и уменьшится на 1 в позиции i+1+a[i].
    #
    # Если мы уроняем башни в порядке возрастания a[i], то diff будет иметь неубывающий prefix sum.
    #
    # Тогда итоговый массив будет неубывающим.
    #
    # Максимальный MEX — это максимальное k, для которого prefix sums[0..k-1] = [0..k-1].
    #
    # Но prefix sums — это итоговые высоты башен.
    #
    # Итоговые высоты — это количество прибавок к башне i.
    #
    # Рассмотрим итоговые высоты h[i].
    #
    # h[i] = количество башен j, для которых i ∈ (j+1, j+a[j]].
    #
    # Рассмотрим массив a отсортированный по возрастанию.
    #
    # Тогда h[i] = количество башен j, у которых j < i и a[j] >= i - j - 1.
    #
    # Чтобы h[i] >= h[i-1], нужно, чтобы количество таких j не уменьшалось.
    #
    # Рассмотрим простой алгоритм:
    #
    # - Отсортируем башни по a[i].
    # - Инициализируем cur = 0
    # - Для i от 0 до n-1:
    #   - Если a[i] >= cur, cur += 1
    #   - Иначе пропускаем
    #
    # cur — максимальное количество башен, которые можно "поднять" до высоты cur.
    #
    # cur — максимальный MEX.
    #
    # Это классический подход для нахождения максимального MEX при ограничениях.
    #
    # Проверим на примерах из условия — совпадает.
    
    a.sort()
    cur = 0
    for x in a:
        if x >= cur:
            cur += 1
    print(cur)