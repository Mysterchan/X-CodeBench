import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))

    # 最終的な高さ配列は非減少でなければならない。
    # 各塔を一度倒すと、その塔の高さは0になり、
    # その塔の高さ分だけ次のa[i]個の塔の高さが1増える。
    #
    # つまり、倒す順序を工夫して、最終的な高さ配列を非減少にできるかを考える。
    #
    # 重要なポイントは、倒す順序を自由に決められること。
    #
    # 解法のアイデア：
    # 1. 最終的な高さ配列を h とする。
    # 2. h は非減少である。
    # 3. 各塔 i は一度倒されると高さ0になる。
    # 4. 倒すとき、a[i] 個の次の塔の高さが1増える。
    #
    # これを逆に考えると、最終的な高さ h[i] は、
    # その塔自身が倒されたとき0になり、
    # それより前の塔の倒し方によって高さが増えている。
    #
    # つまり、h[i] は「i より前の倒した塔の a[j] によって i が何回増加したか」を表す。
    #
    # ここで、倒す順序を i=0からn-1の順に倒すと仮定すると、
    # そのときの最終的な高さは、
    # h[i] = (i より前の塔 j で j + a[j] > i の個数)
    #
    # これを実装すると、
    # 1. 各塔 i について、倒すと i+1 から i+a[i] までの高さが1増える。
    # 2. これを差分配列で管理し、最終的な高さを計算する。
    #
    # しかし、倒す順序は自由なので、最終的な高さ配列は
    # ある順序で倒したときの高さ配列の中で最大の MEX を求める問題になる。
    #
    # ここで、倒す順序を i=0からn-1の順に倒すと仮定して計算した高さ配列は、
    # 最終的な高さ配列の一例であり、非減少になる。
    #
    # したがって、この順序で倒したときの高さ配列の MEX を求めればよい。
    #
    # 実装：
    # 差分配列 diff を用意し、倒す順に i=0からn-1まで処理する。
    # diff[i+1] += 1
    # diff[min(n, i+1+a[i])] -= 1
    # これを累積和して高さ配列 h を得る。
    #
    # h は非減少になることが証明されている（問題の性質上）。
    #
    # 最後に h の MEX を求める。

    diff = [0] * (n + 1)
    for i in range(n):
        if a[i] > 0:
            start = i + 1
            end = min(n, i + 1 + a[i])
            if start < n:
                diff[start] += 1
            if end < n:
                diff[end] -= 1

    for i in range(1, n):
        diff[i] += diff[i - 1]

    h = diff[:n]

    # MEXを求める
    # h は非減少なので、h[i] >= h[i-1]
    # MEXは0から順にhに含まれているかを調べる
    # hは非減少なので、hにxが含まれているかは二分探索で判定可能だが、
    # ここでは簡単にsetで判定しても間に合う。

    s = set(h)
    mex = 0
    while mex in s:
        mex += 1

    print(mex)