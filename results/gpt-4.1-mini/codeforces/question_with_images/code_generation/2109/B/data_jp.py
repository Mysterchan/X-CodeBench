import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, m, a, b = map(int, input().split())
    # ムーフは毎ターン、行または列のどちらかを切って領域を狭める。
    # ファウドはモンスターを残った領域内の任意のセルに移動可能。
    #
    # ムーフはターン数を最小化、ファウドは最大化したい。
    #
    # 最終的に領域は1セルになるまで続く。
    #
    # 最適戦略を考えると、ムーフは毎ターン、行か列のどちらかを半分に近い形で切る。
    # ファウドはモンスターを切られた側に移動し、ムーフの切断を最大限に遅らせる。
    #
    # つまり、ムーフは行方向と列方向の両方で領域を1に縮める必要がある。
    # ファウドはモンスターを常に「切りにくい」側に移動させる。
    #
    # このゲームは「二分探索的に」行と列を1に縮める操作を交互に行うようなもの。
    #
    # したがって、ターン数は
    # 行方向の縮小に必要なターン数 + 列方向の縮小に必要なターン数
    # となる。
    #
    # 行方向の縮小ターン数は、現在の行数nを1にするまでの最小ターン数。
    # ただし、ファウドはモンスターを切りにくい側に移動させるため、
    # ムーフは最悪の場合、モンスターがいる側の大きい方を残すことになる。
    #
    # つまり、行方向のターン数は n を1にするまでの「最大の二分探索の深さ」。
    # これは n の最大の半分を残す操作を繰り返すことに相当する。
    #
    # 具体的には、ムーフは毎回、モンスターの位置aを考慮し、
    # 左側のサイズ a と右側のサイズ n - a + 1 のうち大きい方を残す。
    #
    # これを繰り返すと、行方向のターン数は
    # max(a - 1, n - a) のビット長（2進数の桁数）に相当する。
    #
    # 同様に列方向も max(b - 1, m - b) のビット長に相当する。
    #
    # ただし、n,m >= 2 なので、max(...) は 0 以上。
    #
    # 例:
    # n=3, a=2
    # 左側サイズ = a-1=1, 右側サイズ = n - a=1
    # max=1 -> 1のビット長は1 -> 行方向ターン数=1
    #
    # これを行方向と列方向で足すのが答え。
    #
    # ただし、ビット長は0の場合があるので、0の場合は0ターン。
    #
    # まとめると、
    # 行方向ターン数 = max(a-1, n - a).bit_length()
    # 列方向ターン数 = max(b-1, m - b).bit_length()
    # 答え = 行方向ターン数 + 列方向ターン数

    row_turns = max(a - 1, n - a).bit_length()
    col_turns = max(b - 1, m - b).bit_length()
    print(row_turns + col_turns)