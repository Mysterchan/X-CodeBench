import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    n, m, a, b = map(int, input().split())
    # Муф хочет минимизировать количество ходов, Фуад — максимизировать.
    # На каждом ходе Муф режет сетку по строке или столбцу, оставляя часть с монстром.
    # Фуад может переместить монстра в любую ячейку оставшейся сетки.
    #
    # Оптимальная стратегия Фуада — после разреза переместить монстра в ту часть,
    # которая даст максимальное количество оставшихся ходов.
    #
    # Рассмотрим размеры частей, в которые можно разрезать:
    # По вертикали: части с шириной b и m - b
    # По горизонтали: части с высотой a и n - a
    #
    # После разреза и перемещения монстра в часть с максимальным размером,
    # количество ходов будет 1 (текущий ход) + количество ходов для этой части.
    #
    # Игра заканчивается, когда сетка 1x1.
    #
    # Таким образом, максим количество ходов — это сумма максимальных размеров по вертикали и горизонтали минус 2:
    # (максимальная высота - 1) + (максимальная ширина - 1) = max(a, n - a + 1) - 1 + max(b, m - b + 1) - 1
    #
    # Но индексация с 1, поэтому:
    # max(a, n - a + 1) = max(a, n - a + 1)
    # max(b, m - b + 1) = max(b, m - b + 1)
    #
    # В итоге:
    # ходов = max(a, n - a + 1) + max(b, m - b + 1) - 2

    # Однако, в условии строки и столбцы нумеруются с 1, поэтому n - a + 1 — количество строк снизу от a включительно
    # Аналогично для столбцов.

    # Проверим на примерах из условия:
    # 2 2 1 1 -> max(1, 2-1+1)=max(1,2)=2; max(1,2-1+1)=2; 2+2-2=2 -> совпадает
    # 3 3 2 2 -> max(2,3-2+1)=max(2,2)=2; max(2,3-2+1)=2; 2+2-2=2 (но в примере 4)
    # Значит надо считать иначе.

    # Пересмотр:
    # В примере 3 3 2 2 ответ 4.
    # Если считать как (max(a, n - a) + max(b, m - b)) то:
    # max(2, 3-2)=max(2,1)=2
    # max(2, 3-2)=2
    # 2+2=4 -> совпадает.

    # Значит правильная формула:
    # ходов = max(a - 1, n - a) + max(b - 1, m - b)

    res = max(a - 1, n - a) + max(b - 1, m - b)
    print(res)