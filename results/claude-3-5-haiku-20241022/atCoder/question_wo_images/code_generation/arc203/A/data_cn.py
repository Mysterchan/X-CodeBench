import sys

def solve(N, M):
    # 每个队伍有M名选手，总共N个队伍
    # 每名选手要参加N-1场比赛（与其他N-1个队伍各打一场）
    # 要获得完美纪录，一名选手需要赢得所有N-1场比赛
    
    # 关键观察：
    # 1. 每场队伍间的比赛，M名选手对M名选手
    # 2. 如果一个队伍要有k名选手获得完美纪录，
    #    那么这k名选手在与其他每个队伍的比赛中都必须获胜
    # 3. 这意味着其他N-1个队伍，每个队伍至少要有k名选手输掉所有比赛
    
    # 每个队伍最多可以"贡献"M名必输的选手
    # 如果一个队伍有k名选手完美，那么：
    # - 这个队伍需要k名选手在所有N-1场比赛中都赢
    # - 其他N-1个队伍每个都需要至少k名选手在与这个队伍的比赛中输
    
    # 反过来想：
    # 如果要最大化完美选手数量，可以让一个队伍有尽可能多的完美选手
    # 限制条件是：其他每个队伍都要有足够的"可输"选手
    
    # 设一个队伍有k名完美选手
    # 其他N-1个队伍，每个队伍至少需要k名选手来"接受失败"
    # 所以 k ≤ M（每个其他队伍最多贡献M名选手）
    
    # 最优策略：让一个队伍的min(M, M)名选手完美
    # 但我们可以让多个队伍都有完美选手吗？
    
    # 如果两个队伍都要有完美选手，它们之间比赛时必须有一方输
    # 所以最多只有一个队伍能有完美选手
    
    # 答案就是 min(M, M * (N-1) / (N-1)) = M
    # 但这不对...
    
    # 重新思考：
    # 如果队伍A有k名完美选手
    # 在A vs B的比赛中，A的这k名选手都要赢
    # 所以B必须派k名选手来输给他们
    # B有M名选手，所以k ≤ M
    
    # 对于所有N-1个其他队伍，每个都要贡献k名"牺牲"选手
    # 总共需要 (N-1) * k 个"牺牲"选手位置
    # 总共有 (N-1) * M 个其他队伍的选手位置
    
    # 所以 k ≤ M
    
    # 答案是 min(M, M) = M？
    
    # 看例子1：N=3, M=3，答案是4
    # 看例子2：N=5, M=1，答案是1
    
    # 对于M=1的情况，每个队伍只有1名选手
    # 最多1名选手可以完美（因为只有1个队伍能全赢）
    
    # 对于N=3, M=3的情况，答案是4
    # 这意味着可能不止一个队伍有完美选手
    
    # 重新理解：可以有多个队伍各有一些完美选手
    # 关键是这些完美选手不能互相对战
    
    # 总共有N*M名选手
    # 最大完美选手数 = min(M, (N-1)*M的某个函数)
    
    # 答案：min((N-1)*M, N*M - (N-1)) = min((N-1)*M, N*M-N+1)
    # 当M=1: min(N-1, N-N+1) = min(N-1, 1) = 1 ✓
    # 当N=3,M=3: min(6, 9-2) = min(6, 7) = 6 ✗
    
    # 答案是 min(M*(N-1), M+N-1)
    # N=3,M=3: min(6, 5) = 5 ✗
    
    # 答案是 M + N - 1
    # N=3,M=3: 3+3-1=5 ✗
    # N=5,M=1: 5+1-1=5 ✗
    
    return min(M * (N - 1), M + N - 1)

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    print(solve(N, M))