def solve():
    n = int(input())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    
    # Создаем массив (размер, цвет, исходная_позиция)
    slimes = [(p[i], c[i], i) for i in range(n)]
    
    # Сортируем по размеру, чтобы получить целевой порядок
    target = sorted(range(n), key=lambda i: p[i])
    
    # Инверсии - это пары (i, j) где i < j, но p[i] > p[j]
    # Нам нужно, чтобы слаймы с разными цветами могли обмениваться
    # Если есть инверсия и цвета одинаковые, нужно изменить цвет
    
    # DP подход: для каждой позиции определяем минимальную стоимость
    # для достижения хорошей последовательности
    
    # Ключевая идея: последовательность хорошая, если нет инверсий
    # среди слаймов одного цвета
    
    # Перебираем все возможные присвоения цветов
    # Используем битовые маски или жадный подход
    
    # Альтернативный подход: находим циклы в перестановке
    # и проверяем, можно ли их разрешить
    
    # Для каждой позиции i в отсортированном порядке
    # нужно найти, где находится слайм с размером i+1
    
    # Создаем массив позиций
    pos = [0] * (n + 1)
    for i in range(n):
        pos[p[i]] = i
    
    # Минимальная стоимость через DP по раскраске
    INF = float('inf')
    
    # dp[mask] = минимальная стоимость для обработанных слаймов
    # где mask показывает какие цвета используются
    
    # Упрощенный подход: жадно находим конфликты
    min_cost = 0
    colors = c[:]
    
    # Находим все инверсии и группируем по циклам
    visited = [False] * n
    
    for start in range(n):
        if visited[start]:
            continue
        
        # Находим цикл
        cycle = []
        curr = start
        while not visited[curr]:
            visited[curr] = True
            cycle.append(curr)
            # Следующая позиция - где должен быть текущий элемент
            target_val = curr + 1  # размер который должен быть на позиции curr
            # Ищем где сейчас этот размер
            curr = pos[target_val]
        
        if len(cycle) <= 1:
            continue
        
        # Проверяем цвета в цикле
        cycle_colors = [colors[i] for i in cycle]
        
        # Если все цвета разные или можно разрешить обменами
        # Нужно проверить инверсии внутри цикла
        
        # Для цикла проверяем конфликты
        for i in range(len(cycle)):
            for j in range(i + 1, len(cycle)):
                pos_i = cycle[i]
                pos_j = cycle[j]
                
                if pos_i > pos_j and colors[pos_i] == colors[pos_j]:
                    # Есть инверсия с одинаковым цветом
                    # Нужно изменить цвет одного из них
                    min_cost += colors[pos_i]
                    colors[pos_i] = 0  # Меняем на уникальный
                    break
    
    print(min_cost)

solve()