def solve(X, Y, Z):
    # 条件: A_i の両隣のうち A_i 未満のものがちょうど A_i 個
    # 0 の場合: 両隣のうち 0 未満(存在しない)が 0 個 → 常に満たされる
    # 1 の場合: 両隣のうち 0 が 1 個必要
    # 2 の場合: 両隣のうち 0 または 1 が 2 個必要
    
    # 循環列なので、各値について条件を考える
    # 0: 両隣に制約なし
    # 1: 両隣のうち 1 個が 0
    # 2: 両隣の両方が 0 または 1
    
    # パターン分析:
    # - 1 は片方が 0 でもう片方は何でもよい
    # - 2 は両方が 0 または 1
    
    # 具体的な配置を考える
    # 2 の両隣は必ず 0 または 1
    # 1 の片隣は必ず 0
    
    # 0 が X 個、1 が Y 個、2 が Z 個
    
    # 特殊ケース
    if Z == 0:
        # 2 がない場合
        if Y == 0:
            # 0 のみ → Yes
            return "Yes"
        # 0 と 1 がある
        # 1 は片隣が 0 なので、0-1 の交互配置が可能か
        # X >= Y かつ X <= Y + 1
        if Y <= X <= Y + 1:
            return "Yes"
        else:
            return "No"
    
    # Z > 0 の場合
    # 2 の両隣は 0 または 1 でなければならない
    # 2 が連続する場合を考える
    
    # 1 の条件: 片隣が 0
    # 2 の条件: 両隣が 0 or 1
    
    # 2 を配置すると、その両隣は 0 or 1
    # 1 を配置すると、片隣は 0
    
    # パターン: 0 の周りに 1 と 2 を配置
    # 2 は両隣が 0 or 1 なので、2 同士は隣接可能
    # 1 は片隣が 0 なので、1-1 は不可能(両方の 1 の片隣が 0 になれない)
    
    # 実際には、1 同士は隣接可能(片方ずつ 0 の隣)
    # でも両方の条件を同時に満たすのは難しい
    
    # より正確には:
    # - 2 の塊: 両端が 0 or 1
    # - 1: 片隣が 0
    
    # 特殊パターンを確認
    if X == 0:
        # 0 がない場合、1 と 2 のみ
        # 1 の片隣は 0 なので不可能
        return "No"
    
    # X > 0, Z > 0 の場合
    # 2 * Z <= X + Y (2 の両隣が 0 or 1)
    # Y <= X + Z (1 の片隣が 0、もう片方は 0, 1, or 2)
    
    if 2 * Z <= X + Y and Y <= X + Z:
        return "Yes"
    else:
        return "No"

T = int(input())
for _ in range(T):
    X, Y, Z = map(int, input().split())
    print(solve(X, Y, Z))