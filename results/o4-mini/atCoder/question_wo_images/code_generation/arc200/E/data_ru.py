import sys
input = sys.stdin.readline

MOD = 998244353

# Предварительно вычислим факториалы и обратные факториалы для биномиальных коэффициентов
# Максимум M может быть до 998244352, слишком большой для прямого вычисления.
# Но нам нужны только C(M,0), C(M,1), C(M,2).
# C(M,0) = 1
# C(M,1) = M
# C(M,2) = M*(M-1)//2

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    # Количество чисел в диапазоне [0, 2^M)
    # Условие: для любых i<j popcount(A_i XOR A_j) ≤ 2
    # Это значит, что все элементы последовательности лежат в "кластере" с диаметром ≤ 2 по метрике popcount.
    #
    # Рассмотрим множество чисел, где расстояние по XOR (popcount) между любыми двумя элементами ≤ 2.
    # Это множество либо:
    # - все элементы равны (popcount=0)
    # - либо все элементы отличаются максимум в 1 или 2 битах от некоторого "центра"
    #
    # Множество с диаметром ≤ 2 по Hamming distance (popcount) может быть:
    # - множество из 1 элемента
    # - множество из 2 элементов, отличающихся в 1 или 2 битах
    # - множество из 3 элементов, где все пары отличаются ≤ 2 битами
    # - множество из 4 элементов, где все пары отличаются ≤ 2 битами
    #
    # Но нам нужно количество последовательностей длины N, где все пары элементов удовлетворяют условию.
    #
    # Рассмотрим множество чисел, которые отличаются от некоторого "центра" не более чем в 2 битах.
    # Количество таких чисел:
    # - выбрать 0 битов для изменения: C(M,0) = 1
    # - выбрать 1 бит для изменения: C(M,1) = M
    # - выбрать 2 бита для изменения: C(M,2) = M*(M-1)//2
    #
    # Итого: 1 + M + M*(M-1)//2 = 1 + M + M*(M-1)//2 = 1 + M + (M^2 - M)/2 = 1 + M + M^2/2 - M/2 = 1 + M/2 + M^2/2
    #
    # Это множество образует "шар" радиуса 2 в пространстве {0,1}^M.
    #
    # Все элементы последовательности должны принадлежать этому множеству, иначе расстояние между элементами будет > 2.
    #
    # Значит, все элементы A_i принадлежат одному и тому же "шару" радиуса 2.
    #
    # Количество таких чисел в шаре: S = 1 + M + M*(M-1)//2
    #
    # Тогда количество последовательностей длины N: S^N по модулю.
    #
    # Ответ: (1 + M + M*(M-1)//2)^N mod 998244353

    S = (1 + M + (M*(M-1)//2)) % MOD

    # Быстрое возведение в степень по модулю
    def mod_pow(base, exp, mod):
        result = 1
        cur = base
        e = exp
        while e > 0:
            if e & 1:
                result = (result * cur) % mod
            cur = (cur * cur) % mod
            e >>= 1
        return result

    ans = mod_pow(S, N, MOD)
    print(ans)