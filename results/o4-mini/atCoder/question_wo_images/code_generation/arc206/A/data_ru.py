import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

# Идея решения:
# При выборе (L,R) мы заменяем A_L,...,A_R на A_L.
# В итоге последовательность изменится только на отрезке [L,R],
# где все элементы станут равны A_L.
# Элементы вне отрезка не меняются.

# Рассмотрим, как выглядит итоговая последовательность:
# Для i < L: A_i unchanged
# Для L ≤ i ≤ R: A_i = A_L
# Для i > R: A_i unchanged

# Значит, итоговая последовательность определяется тройкой:
# - L (начало отрезка)
# - R (конец отрезка, R ≥ L)
# - A_L (значение, на которое заменяем)

# Но разные пары (L,R) могут привести к одинаковой итоговой последовательности.
# Нужно посчитать количество различных итоговых последовательностей.

# Рассмотрим, как можно отличить итоговые последовательности.
# Итоговая последовательность отличается от исходной на отрезке [L,R],
# где элементы заменены на A_L.

# Если мы фиксируем L, то для разных R ≥ L
# итоговая последовательность будет иметь вид:
# A[0..L-2], затем (R-L+1) раз A_L, затем A[R..N-1]

# Различие между итоговыми последовательностями с одним L
# возникает, если меняется R, и при этом итоговые последовательности отличаются.

# Но если для двух разных R1 < R2 итоговые последовательности совпадают,
# значит, замена на большем отрезке не меняет итог.

# Рассмотрим, когда итоговые последовательности совпадают.
# Пусть для фиксированного L и R1 < R2
# итоговые последовательности совпадают, тогда:
# A[0..L-2] одинаковы (не меняются)
# На отрезке [L,R1] все элементы заменены на A_L
# На отрезке [L,R2] все элементы заменены на A_L
# На отрезке [R1+1,R2] элементы исходные (т.к. в первом случае они не менялись)
# Но итоговые последовательности совпадают, значит:
# A_i = A_L для i in [R1+1,R2], иначе они бы отличались.

# Значит, для фиксированного L, если элементы после R1 до R2 равны A_L,
# то итоговые последовательности для R1 и R2 совпадают.

# Следовательно, для фиксированного L, максимальный R, для которого
# все элементы A[L..R] равны A_L, определяет максимальный отрезок,
# на котором замена даст уникальную итоговую последовательность.

# Таким образом, для каждого L нам нужно найти максимальный R ≥ L,
# такой что A[L..R] = A_L (все элементы равны A_L).

# Тогда для каждого L количество уникальных итоговых последовательностей,
# которые можно получить при фиксированном L, равно длине максимального
# однородного отрезка, начинающегося в L.

# Итоговое количество уникальных последовательностей равно сумме
# по всем L длины максимального однородного отрезка, начинающегося в L.

# Но при этом мы должны учитывать, что разные L могут давать одинаковые
# итоговые последовательности, если итоговые последовательности совпадают.

# Рассмотрим пример:
# A = [1,1,2,3]
# L=1, A_L=1, максимальный R=2 (т.к. A[1]=1)
# длина = 2
# Значит для L=1 можно получить 2 уникальных последовательности:
# R=1: (1,1,2,3) -> заменяем только A_1
# R=2: (1,1,2,3) -> заменяем A_1,A_2 (оба 1)
# Но они совпадают? Нет, они разные, т.к. замена на большем отрезке.

# L=2, A_L=1, максимальный R=2 (только один элемент)
# длина=1
# L=3, A_L=2, максимальный R=3
# длина=1
# L=4, A_L=3, максимальный R=4
# длина=1

# Сумма = 2+1+1+1=5, но в примере ответ 4.

# Значит, нужно учесть, что некоторые итоговые последовательности совпадают
# при разных L и R.

# Рассмотрим, что итоговая последовательность определяется:
# - префиксом до L-1 (не меняется)
# - заменённым отрезком [L,R], где все элементы равны A_L
# - суффиксом после R (не меняется)

# Если для двух пар (L1,R1) и (L2,R2) итоговые последовательности совпадают,
# значит:
# - префиксы до min(L1,L2)-1 совпадают
# - заменённые отрезки совпадают (одинаковая длина и значение)
# - суффиксы после max(R1,R2) совпадают

# Но проще рассмотреть, что итоговая последовательность определяется
# тройкой (L, R, A_L), и итоговая последовательность уникальна,
# если она отличается хотя бы в одном элементе.

# Чтобы эффективно посчитать количество уникальных итоговых последовательностей,
# можно рассмотреть все возмож пары (L,R), где R ≥ L и A[L..R] = A_L (однородный отрезок),
# и посчитать количество таких пар.

# Но перебор всех пар невозможен при N=10^6.

# Оптимизация:
# Для каждого индекса i найдём длину максимального однородного отрезка,
# начинающегося в i.

# Тогда количество пар (L,R) с фиксированным L равно длине этого отрезка.

# Но нужно исключить дубликаты итоговых последовательностей,
# которые могут возникнуть, если итоговые последовательности совпадают
# для разных L.

# Рассмотрим, что итоговая последовательность определяется:
# - префиксом до L-1
# - заменённым отрезком [L,R] на A_L
# - суффиксом после R

# Если для двух разных L1 и L2 итоговые последовательности совпадают,
# значит:
# - префиксы до min(L1,L2)-1 совпадают
# - заменённые отрезки совпадают
# - суффиксы после max(R1,R2) совпадают

# Но если L1 < L2, то префикс до L1-1 короче, чем до L2-1,
# значит они не совпадают, если A[L1-1] != A[L2-1].

# Значит, итоговые последовательности с разными L отличаются,
# если префиксы до L-1 различны.

# Следовательно, итоговые последовательности с разными L не совпадают,
# если префиксы до L-1 различны.

# Но если префиксы совпадают, то итоговые последовательности могут совпадать.

# Однако префиксы различны для разных L, т.к. L меняется.

# Значит, итоговые последовательности с разными L не совпадают.

# Следовательно, итоговые последовательности уникальны для каждой пары (L,R),
# где R в пределах максимального однородного отрезка, начинающегося в L.

# Итог: ответ = сумма по i=1..N длины максимального однородного отрезка,
# начинающегося в i.

# Реализация:
# Пройдём с конца массива, для каждого i посчитаем длину однородного отрезка,
# начинающегося в i.

# Тогда ответ = сумма этих длин.

lengths = [0]*N
lengths[-1] = 1
for i in range(N-2, -1, -1):
    if A[i] == A[i+1]:
        lengths[i] = lengths[i+1] + 1
    else:
        lengths[i] = 1

print(sum(lengths))