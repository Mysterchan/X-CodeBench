import sys
import bisect

input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    A.sort()
    B.sort()

    # Aの要素を使い切るためにリストで管理
    from bisect import bisect_left

    # Aをリストとして保持し、使ったら削除する方法はO(N^2)になるので、
    # ここではAをソート済みリストとして保持し、二分探索で適切な要素を選び、
    # 選んだ要素はリストから削除するのはコストが高い。
    # 代わりに、Aの要素をmultiset的に管理するために
    # Pythonの標準ライブラリにはmultisetがないため、
    # ここではAを配列として保持し、使った要素を記録する方法を考える。

    # しかし、Nの総和が3*10^5なので、O(N log N)の操作は許容される。
    # そこで、Aをリストとして保持し、使った要素を削除するために
    # bisectで位置を探し、delで削除する方法をとる。

    # ただしdelはO(N)なので、Tが大きい場合は厳しい。
    # そこで、Aを配列として保持し、使った要素をフラグで管理し、
    # 使える要素のインデックスを管理する方法を考える。

    # しかし、より簡単な方法として、Aをソートし、
    # Bをソートした順に処理し、Aの中から条件を満たす最小の要素を選ぶ方法をとる。

    # 具体的には、Aをソート済みリストとして保持し、
    # B[i]に対して、x = (M - B[i]) % M を計算し、
    # Aの中からx以上の最小の要素を二分探索で探す。
    # 見つかればそれを使い、なければAの中で最小の要素を使う。

    # 使った要素はリストから削除する必要があるが、delはO(N)なので、
    # ここではcollections.dequeを使って、Aをソート済みリストとして保持し、
    # 使った要素をポップする方法は使えない。

    # そこで、Aをmultiset的に管理するために、bisect.insortで挿入と削除を行う。
    # しかし、削除はO(N)なので、Tが大きい場合は厳しい。

    # 代替案として、Aをソート済みリストとして保持し、
    # Bをソート済みリストとして保持し、
    # Aの要素を使い切るために、Aの要素を順に使う方法を考える。

    # しかし、問題の本質は、Aの要素を並び替えて、
    # max((A_i + B_i) mod M)を最小化すること。

    # これは「A_i + B_i >= M となるようにA_iを選ぶ」ことが理想的。
    # つまり、A_i >= M - B_i (mod M) の条件を満たすA_iを選ぶ。

    # そこで、Aをソート済みリストとして保持し、
    # Bをソート済みリストとして保持し、
    # Bの小さい順に処理し、Aの中から条件を満たす最小の要素を二分探索で探し、
    # 見つからなければAの中で最小の要素を使う。

    # 使った要素はリストから削除する必要があるが、delはO(N)なので、
    # ここではAを配列として保持し、使った要素を管理するために
    # bisectで位置を探し、Aの要素を使ったらリストから削除する方法をとる。

    # これでO(N log N)で処理可能。

    res = [0] * N
    from bisect import bisect_left

    # Aをリストとして保持
    A_list = A

    for i in range(N):
        x = (M - B[i]) % M
        idx = bisect_left(A_list, x)
        if idx == len(A_list):
            # 条件を満たす要素がないので最小の要素を使う
            idx = 0
        res[i] = (A_list[idx] + B[i]) % M
        del A_list[idx]

    print(max(res))