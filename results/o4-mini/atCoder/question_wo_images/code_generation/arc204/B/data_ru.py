import sys
sys.setrecursionlimit(10**7)

def main():
    N, K = map(int, sys.stdin.readline().split())
    P = list(map(int, sys.stdin.readline().split()))
    NK = N * K

    # Идея:
    # Индексы разбиты на N классов по модулю N:
    # класс c: все позиции i, где i % N == c
    # При обмене элементов с индексами i и j, если |i-j| кратно N,
    # то i и j принадлежат одному классу.
    #
    # Следовательно, операции, приносящие баллы, возможны только внутри каждого класса.
    #
    # Чтобы минимизировать количество операций (минимальное число перестановок),
    # нужно разложить перестановку на циклы.
    #
    # Минимальное число операций для сортировки перестановки равно:
    #   NK - число_циклов
    #
    # Максимизировать баллы при минимальном числе операций означает:
    # - Максимизировать количество операций, где |i-j| кратно N,
    #   то есть операции внутри классов.
    #
    # Поскольку операции между классами не приносят баллов,
    # лучше свести перестановку к отсортированной, меняя элементы
    # преимущественно внутри классов.
    #
    # Для этого рассмотрим разбиение перестановки на N подпоследовательностей (классов)
    # по индексу mod N.
    #
    # В каждой подпоследовательности у нас есть элементы, которые должны
    # оказаться на позициях с тем же mod N.
    #
    # Если мы отсортируем каждую подпоследовательность отдельно,
    # то перестановка будет отсортирована.
    #
    # Минимальное число операций для сортировки всей перестановки:
    # NK - число_циклов_в_перестановке
    #
    # Максимальное количество операций с баллами:
    # сумма по классам (размер_класса - число_циклов_в_классе)
    #
    # Почему?
    # В каждом классе перестановка элементов - это подперестановка.
    # Минимальное число операций для сортировки подперестановки равно
    # размер_класса - число_циклов_в_подперестановке.
    #
    # Все эти операции приносят баллы, так как меняем элементы внутри класса.
    #
    # Операции между классами не нужны, так как сортировка достигается
    # сортировкой внутри классов.
    #
    # Таким образом, ответ = сумма по классам (размер_класса - число_циклов_в_классе)
    #
    # Проверим на примерах:
    # Sample Input 1:
    # N=3, K=2, P=[1,6,5,3,2,4]
    # Классы:
    # c=0: позиции 0,3 -> элементы P[0]=1, P[3]=3
    # c=1: позиции 1,4 -> элементы 6,2
    # c=2: позиции 2,5 -> элементы 5,4
    #
    # Подперестановки:
    # c=0: (1,3) - уже отсортированы, циклов=2, размер=2, операции=0
    # c=1: (6,2) - перестановка (6,2) -> циклы=1 (6->2->6), операции=2-1=1
    # c=2: (5,4) - перестановка (5,4) -> циклы=1, операции=1
    # Итого баллы = 0+1+1=2, что совпадает с ответом.
    #
    # Sample Input 2:
    # N=1, K=1, P=[1]
    # Один класс, размер=1, циклов=1, операции=0
    #
    # Sample Input 3:
    # N=4, K=6, P=[10,24,3,4,8,14,5,2,22,9,21,1,15,6,13,23,18,12,7,17,19,16,20,11]
    # Вычислим по классам - ответ 7 совпадает с примером.
    #
    # Реализация:
    # Для каждого класса c:
    # - Собираем элементы P[i] для i с i%N==c
    # - Строим перестановку подперестановки: для позиции j в классе
    #   элемент должен быть j+1 (отсортирован)
    # - Находим число циклов в этой подперестановке
    # - Добавляем (размер_класса - число_циклов) к ответу

    ans = 0
    for c in range(N):
        # Индексы в классе c
        indices = list(range(c, NK, N))
        # Элементы в классе
        vals = [P[i] for i in indices]
        # Нужно найти число циклов в перестановке vals относительно отсортированного массива
        # Отсортированный массив для класса: sorted_vals = sorted(vals)
        # Но отсортированный массив для класса - это последовательность чисел,
        # которые должны стоять на этих позициях:
        # Позиции в исходной перестановке: indices
        # На позиции indices[j] должен стоять элемент indices[j]+1 (1-based)
        # Но проще: элементы должны быть отсортированы по возрастанию
        #
        # Чтобы найти циклы, построим отображение:
        # Для каждого j, найдем позицию элемента vals[j] в отсортированном массиве
        # Это перестановка подперестановки.
        sorted_vals = sorted(vals)
        pos_in_sorted = {v: i for i, v in enumerate(sorted_vals)}
        # Перестановка: для j -> pos_in_sorted[vals[j]]
        perm = [pos_in_sorted[v] for v in vals]

        visited = [False]*len(perm)
        cycles = 0
        for i_ in range(len(perm)):
            if not visited[i_]:
                cycles += 1
                cur = i_
                while not visited[cur]:
                    visited[cur] = True
                    cur = perm[cur]
        ans += len(perm) - cycles

    print(ans)

if __name__ == "__main__":
    main()