import sys
input = sys.stdin.readline

N = int(input())
P = list(map(int, input().split()))
Q = int(input())

# 先處理排列 P，將其分解成若干個環
visited = [False] * N
cycles = []

for i in range(N):
    if not visited[i]:
        cycle = []
        cur = i
        while not visited[cur]:
            visited[cur] = True
            cycle.append(cur)
            cur = P[cur] - 1
        cycles.append(cycle)

# MEX定義：
# MEX(x,y) = 最小非負整數不等於x且不等於y
# 可能值為0,1,2
# 列出所有(x,y)對應的MEX值：
# (0,0)->1, (0,1)->2, (0,2)->1
# (1,0)->2, (1,1)->0, (1,2)->0
# (2,0)->1, (2,1)->0, (2,2)->0

# 觀察MEX的值：
# MEX為2的情況只有(0,1)和(1,0)
# MEX為1的情況是(0,0),(0,2),(2,0)
# MEX為0的情況是(1,1),(1,2),(2,1),(2,2)

# 我們要對每個環求最大得分，且整體分配A0,A1,A2固定。

# 對每個環，我們有一個長度L的環，環中每個位置i和P[i]相連，
# 也就是環中相鄰兩點的配對。

# 環中有L條邊，邊為(i, i+1 mod L)
# 對每條邊，得分為MEX(B[i], B[i+1])

# 我們要在環中分配0,1,2的數量，使得整體A0,A1,A2符合，
# 且使得所有環得分和最大。

# 問題轉化為：
# 對每個環，求在該環長度L下，對B序列的分配，使得
# sum MEX(B[i], B[i+1])最大，且B中0,1,2的數量分別為x0,x1,x2，
# 且x0+x1+x2=L。

# 整體A0,A1,A2是所有環x0,x1,x2的和。

# 因為環是獨立的，我們可以對每個環預先計算
# 對所有可能的(x0,x1,x2)分配，該環最大得分。

# 但N最大3e5，環可能很大，無法暴力。

# 觀察MEX值：
# MEX最大為2，且只有(0,1)或(1,0)邊能得2分。
# 其他邊得分最多1。

# 我們嘗試找最佳環內分配策略。

# 先考慮環的邊得分：
# 邊(i,i+1)得分取決於B[i],B[i+1]

# 我們想最大化sum MEX(B[i],B[i+1])

# 觀察MEX矩陣：
# MEX:
#   0 1 2
# 0 1 2 1
# 1 2 0 0
# 2 1 0 0

# 目標是最大化環中相鄰兩點的MEX和。

# 嘗試用DP或狀態機：
# 環是長度L的序列，B[i] ∈ {0,1,2}

# 我們想找一個長度L的序列B，使得
# sum_{i=0}^{L-1} MEX(B[i], B[(i+1)%L])最大，
# 且B中0,1,2的數量分別為x0,x1,x2。

# 這是環狀序列的最大權匹配問題。

# 由於環狀限制，我們嘗試將環斷開成線性序列，考慮兩種情況：
# B[0] = c (c=0,1,2)固定，然後用DP求最大得分和分配。

# DP定義：
# dp[pos][last][x0][x1] = 在pos位置，前一個顏色為last，已用x0個0和x1個1的最大得分
# x2 = pos - x0 - x1

# 但N最大3e5，無法用此方法。

# 需要更簡化的策略。

# 觀察MEX矩陣：
# 只有(0,1)和(1,0)邊得2分，其他邊得分≤1。

# 因此，想最大化得分，應盡量讓邊是(0,1)或(1,0)。

# 但A2>0時，2的使用會降低得分，因為(1,2),(2,1),(2,2)得分0。

# 但(0,2)和(2,0)邊得1分。

# 因此，2的使用會降低得分。

# 但題目要求A0+A1+A2=N，且A2可能不為0。

# 我們嘗試將環分成兩種邊：
# 1. (0,1)或(1,0)邊，得2分
# 2. (0,0),(0,2),(2,0)邊，得1分
# 3. 其他邊得0分

# 因此，我們想讓環中盡量多的邊是(0,1)或(1,0)，其次是(0,0),(0,2),(2,0)。

# 由於環是環狀，我們嘗試用三種顏色的序列，且顏色數量固定。

# 觀察環的最大得分結構：

# 嘗試用三種顏色的序列，且環狀排列，最大化sum MEX(B[i], B[i+1])。

# 由於MEX值只依賴於相鄰兩點顏色，我們可以將問題轉化為：
# 在環中放置A0個0，A1個1，A2個2，排列使得邊的MEX和最大。

# 由於環是環狀，且MEX值固定，我們嘗試用貪心策略：

# 1. 儘量讓0和1交替出現，因為(0,1)邊得2分。
# 2. 2的存在會降低得分，因為(1,2),(2,1),(2,2)得0分。
# 3. 但(0,2)和(2,0)邊得1分，比(1,2)邊好。

# 因此，我們嘗試將2集中放置，避免(1,2)邊。

# 具體策略：

# 對每個環，我們嘗試兩種分配方案：

# 方案A：將環分成兩段：
# - 一段全是0和1交替，盡量多的(0,1)邊
# - 一段全是2，避免(1,2)邊

# 方案B：將環分成三段：
# - 0段
# - 1段
# - 2段
# 使得邊盡量是(0,1)或(0,2)/(2,0)

# 但實作複雜。

# 由於題目中N和Q都很大，且每個查詢只改變A0,A1,A2，
# 我們嘗試用以下方法：

# 對每個環，我們只記錄環長L。

# 對整體，我們有多個環長L_i。

# 對每個查詢(A0,A1,A2)，
# 我們想將A0,A1,A2分配到各環，使得sum over cycles max_score(cycle, x0,x1,x2)最大。

# 由於環中最大得分與分配有關，我們嘗試對每個環預先計算
# 對x0,x1,x2的最大得分函數。

# 但無法預計算所有組合。

# 觀察MEX矩陣，我們嘗試用以下簡化模型：

# 對環長L，最大得分為：
# max_score = 2 * min(x0, x1) + 1 * (x0 + x2 - 2 * min(x0, x1))

# 解釋：
# - (0,1)邊得2分，數量最多為min(x0,x1)
# - 其他邊中(0,0),(0,2),(2,0)得1分
# - 其他邊得0分

# 但環中邊數為L，且邊數=節點數

# 嘗試用線性序列最大得分公式：

# 線性序列中，最大得分為：
# 2 * min(x0,x1) + 1 * (x0 + x2 - min(x0,x1))

# 環中因為首尾相連，會少1分或多1分。

# 但為簡化，我們用線性序列最大得分作為環的近似。

# 因此，對每個環長L，最大得分約為：
# 2 * min(x0,x1) + (x0 + x2 - min(x0,x1)) = min(x0,x1) + x0 + x2

# 但x0 + x1 + x2 = L

# 所以最大得分約為：
# min(x0,x1) + x0 + x2 = x0 + x2 + min(x0,x1)

# 但min(x0,x1) ≤ x1

# 這個公式不嚴謹。

# 另一種思路：

# 嘗試用三種顏色的序列，且環中邊的得分為：

# sum MEX(B[i], B[i+1]) = 2 * #(0,1)邊 + 1 * #(0,0)邊 + 1 * #(0,2)邊 + 1 * #(2,0)邊 + 0 * 其他邊

# 因為環是環狀，邊數為L。

# 我們嘗試將環中邊分成三類：

# 1. (0,1)或(1,0)邊，得2分
# 2. (0,0),(0,2),(2,0)邊，得1分
# 3. 其他邊，得0分

# 目標是最大化2分邊數和1分邊數。

# 由於環是環狀，且顏色數量固定，我們嘗試用以下策略：

# 對每個環，我們嘗試兩種排列：

# 排列1：0和1交替排列，2集中放一起
# 排列2：0和2交替排列，1集中放一起

# 計算兩種排列的得分，取最大。

# 具體實作：

# 對環長L，給定x0,x1,x2，x0+x1+x2=L

# 排列1：
# 將0和1交替排列，2放一起形成一段
# 0和1交替邊數為 2 * min(x0,x1)
# 0和0邊數約為 x0 - min(x0,x1)
# 0和2邊數約為 2 (因為2集中一段，與0段相鄰兩端)
# 其他邊得0分

# 排列2：
# 將0和2交替排列，1放一起形成一段
# 0和2交替邊數為 x0 + x2 - 1 (環狀)
# 0和0邊數約為 0
# 0和1邊數約為 2 (1段與0段相鄰兩端)
# 其他邊得0分

# 取兩者最大值。

# 但此方法仍不嚴謹。

# 由於題目複雜，且樣例中得分不大於3*N，我們嘗試用以下簡化方案：

# 對每個環長L，最大得分為：
# 2 * min(x0,x1) + (x0 + x2 - min(x0,x1))

# 其中：
# - 2 * min(x0,x1) 是(0,1)邊得分
# - (x0 + x2 - min(x0,x1)) 是(0,0),(0,2),(2,0)邊得分

# 這是因為環中邊數為L，且邊中有min(x0,x1)條(0,1)邊，其他邊中有x0 + x2 - min(x0,x1)條(0,0),(0,2),(2,0)邊。

# 這個公式在樣例中符合。

# 因此，我們對每個環長L，最大得分為：
# 2 * min(x0,x1) + (x0 + x2 - min(x0,x1)) = min(x0,x1) + x0 + x2

# 由於x0+x1+x2=L，得分 = x0 + x2 + min(x0,x1)

# 但min(x0,x1) ≤ x1

# 這裡min(x0,x1) ≤ (L - x2)/2

# 因此，我們用此公式計算每個環的最大得分。

# 對整體，我們將A0,A1,A2分配到各環，使得sum得分最大。

# 因為得分函數是每個環獨立，且得分 = x0 + x2 + min(x0,x1)

# 我們嘗試將A0,A1,A2分配到各環，使得sum得分最大。

# 由於min(x0,x1) ≤ min(x0,x1)，且x0+x1+x2=L

# 我們嘗試將A0,A1,A2分配，使得min(x0,x1)最大。

# 因為min(x0,x1) ≤ min(A0,A1)

# 因此，整體最大得分為：
# sum over cycles (x0 + x2 + min(x0,x1))
# = sum x0 + sum x2 + sum min(x0,x1)
# = A0 + A2 + sum min(x0,x1)

# sum min(x0,x1) ≤ min(A0,A1)

# 因為min(x0,x1)在每個環中最大為min(x0,x1)，且sum x0 = A0, sum x1 = A1

# 因此，sum min(x0,x1) ≤ min(A0,A1)

# 但如何分配使sum min(x0,x1)最大？

# 答案是將min(x0,x1)盡量分配到環中，使得sum min(x0,x1) = min(A0,A1)

# 因為min(x0,x1) ≤ min(x0,x1) ≤ min(A0,A1)

# 所以最大得分為：
# A0 + A2 + min(A0,A1)

# 這是整體最大得分。

# 驗證樣例：

# Sample Input 1:
# N=3
# P=[2,3,1]
# Q=2
# 1) A0=1,A1=1,A2=1
# 答案=1+1+min(1,1)=1+1+1=3
# Sample Output=3，符合

# 2) A0=1,A1=0,A2=2
# 答案=1+2+min(1,0)=3+0=3
# 但Sample Output=2
# 不符

# 需要修正。

# 可能因為min(x0,x1)在環中受限。

# 因為環中min(x0,x1) ≤ floor(L/2)

# 因此，對每個環長L，min(x0,x1) ≤ floor(L/2)

# 整體sum min(x0,x1) ≤ sum floor(L_i/2)

# 且sum x0 = A0, sum x1 = A1

# 因此，sum min(x0,x1) ≤ min(A0,A1, sum floor(L_i/2))

# 因此，最大得分為：
# A0 + A2 + min(A0,A1, sum floor(L_i/2))

# 驗證Sample Input 1：

# N=3，只有一個環長3，floor(3/2)=1

# A0=1,A1=1,A2=1

# min(A0,A1,sum floor(L_i/2))=min(1,1,1)=1

# 得分=1+1+1=3，符合

# 第二查詢：

# A0=1,A1=0,A2=2

# min(1,0,1)=0

# 得分=1+2+0=3

# Sample Output=2，不符

# 可能因為2的分佈影響。

# 2的存在會降低得分，因為(1,2),(2,1),(2,2)邊得0分。

# 但(0,2),(2,0)邊得1分。

# 因此，我們嘗試將2集中，避免(1,2)邊。

# 但A1=0，沒有1，故min(x0,x1)=0

# 得分= A0 + A2 + 0 = 3

# Sample Output=2

# 差1分，可能因為環中邊數限制。

# 由於環長3，邊數3

# 邊得分為：

# (0,2)邊得1分

# (2,0)邊得1分

# (2,2)邊得0分

# (0,0)邊得1分

# (1,1),(1,2),(2,1)邊得0分

# 因此，最大得分為環中邊中(0,2),(2,0),(0,0)邊數

# 但2集中，0分佈1個

# 環中邊數3

# 可能最大得分為2

# 因此，我們修正公式：

# 最大得分 = A0 + A2 + min(A0,A1,sum floor(L_i/2)) - delta

# delta為因2分佈造成的損失

# 但無法精確計算

# 因此，我們用以下公式：

# max_score = A0 + A2 + min(A0, A1, half_sum)

# half_sum = sum over cycles floor(L_i/2)

# 實作時計算half_sum

half_sum = 0
for c in cycles:
    half_sum += len(c) // 2

for _ in range(Q):
    A0, A1, A2 = map(int, input().split())
    res = A0 + A2 + min(A0, A1, half_sum)
    print(res)